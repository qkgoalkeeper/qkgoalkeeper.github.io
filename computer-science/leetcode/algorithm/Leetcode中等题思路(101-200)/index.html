



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="c++" />


<link rel="canonical" href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/">



  <title>
Leetcode中等题思路（101-100） - 算法题思路 - Leetcode - 计算机科学 |
Kun Qian = Qkgoalkeeper's blog</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Leetcode中等题思路（101-100）
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-04-22 14:45:48">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-04-22T14:45:48+08:00">2024-04-22</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Kun Qian</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://cdn.jsdelivr.net/gh/qkgoalkeeper/blogImage@main/img/leetcode.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/leetcode/" itemprop="item" rel="index" title="分类于 Leetcode"><span itemprop="name">Leetcode</span></a>
<meta itemprop="position" content="2" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/leetcode/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/" itemprop="item" rel="index" title="分类于 算法题思路"><span itemprop="name">算法题思路</span></a>
<meta itemprop="position" content="3" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Kun Qian">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Qkgoalkeeper's blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历</span></h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = [1]
输出：[[1]]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>经典bfs，队列每次处理一层，将下一层节点入队</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        if(!root) return res;
        queue&lt;TreeNode*&gt; queue1;
        queue1.push(root);
        while(!queue1.empty())&#123;
            int size = queue1.size();
            vector&lt;int&gt; level;
            for(int i=0;i&lt;size;i++)&#123;
                TreeNode* temp = queue1.front();
                level.push_back(temp-&gt;val);
                queue1.pop();
                if(temp-&gt;left)&#123;
                    queue1.push(temp-&gt;left);
                &#125;
                if(temp-&gt;right)&#123;
                    queue1.push(temp-&gt;right);
                &#125;
            &#125;
            res.push_back(level);
        &#125;
        return res;

    &#125;
&#125;;
</code></pre>
<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS16aWd6YWctbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">103. 二叉树的锯齿形层序遍历</span></h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = [1]
输出：[[1]]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历</span>类似，每层放入队列时根据标识符判断是正向入队还是反向入队，这里的队列简单一点用deque双向队列表示</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;
        if(!root) return &#123;&#125;;
        vector&lt;vector&lt;int&gt;&gt; answer;
        deque&lt;TreeNode*&gt; q;
        q.push_back(root);
        int flag = 1;
        while(q.size()&gt;0)&#123;
            int len = q.size();
            vector&lt;int&gt; temp;
            if(flag&gt;0)&#123;
                for(int i=0;i&lt;len;i++)&#123;
                    TreeNode* t = q.front();
                    temp.push_back(t-&gt;val);
                    q.pop_front();
                    if(t-&gt;left)&#123;
                        q.push_back(t-&gt;left);
                    &#125;
                    if(t-&gt;right)&#123;
                        q.push_back(t-&gt;right);
                    &#125;
                &#125;
            &#125;
            else&#123;
                for(int i=0;i&lt;len;i++)&#123;
                    TreeNode* t = q.back();
                    temp.push_back(t-&gt;val);
                    q.pop_back();
                    if(t-&gt;right)&#123;
                        q.push_front(t-&gt;right);
                    &#125;
                    if(t-&gt;left)&#123;
                        q.push_front(t-&gt;left);
                    &#125;

                &#125;

            &#125;
            answer.push_back(temp);
            flag = -flag;
        &#125;


        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1wcmVvcmRlci1hbmQtaW5vcmRlci10cmF2ZXJzYWwv">105. 从前序与中序遍历序列构造二叉树</span></h1><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<pre><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: preorder = [-1], inorder = [-1]
输出: [-1]
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>前序遍历的第一个数为中间节点，从中序遍历找到这个数后左右划分，再找到前序遍历中对应部分便能形成两个子问题，所以dfs分治递归即可</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder,int prestart,int preend,int instart,int inend)&#123;
        if(prestart&gt;preend)&#123;
            return nullptr;
        &#125;
        TreeNode* answer = new TreeNode(preorder[prestart]);
        
        int midnum = preorder[prestart];
        int pos;
        for(int i=instart;i&lt;=inend;i++)&#123;
            if(inorder[i]==midnum)&#123;
                pos=i;
                break;
            &#125;
        &#125;
        int leftsize = pos-instart;
        int rightsize = inend-pos;

        answer-&gt;left = dfs(preorder,inorder,prestart+1,prestart+leftsize,instart,pos-1);

        answer-&gt;right = dfs(preorder,inorder,prestart+leftsize+1,preend,pos+1,inend);

        return answer;
    &#125;

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
        return dfs(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);
    &#125;
&#125;;
</code></pre>
<h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb25zdHJ1Y3QtYmluYXJ5LXRyZWUtZnJvbS1pbm9yZGVyLWFuZC1wb3N0b3JkZXItdHJhdmVyc2FsLw==">106. 从中序与后序遍历序列构造二叉树</span></h1><h2 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<pre><code>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入：inorder = [-1], postorder = [-1]
输出：[-1]
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>
<li><code>postorder.length == inorder.length</code></li>
<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>
<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>
<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>
<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>
<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>后序遍历的最后一个数为中间节点，从中序遍历找到这个数后左右划分，再找到后序遍历中对应部分便能形成两个子问题，所以dfs分治递归即可</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* dfs(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder,int istart,int iend,int pstart,int pend)&#123;
        if(pend&lt;pstart)&#123;
            return nullptr;
        &#125;
        int pos;
        int midnum = postorder[pend];
        for(int i=istart;i&lt;iend;i++)&#123;
            if(inorder[i]==midnum)&#123;
                pos = i;
                break;
            &#125;
        &#125;

        TreeNode* answer = new TreeNode(midnum);

        answer-&gt;left = dfs(inorder,postorder,istart,pos-1,pstart,pstart+pos-istart-1);
        answer-&gt;right = dfs(inorder,postorder,pos+1,iend,pstart+pos-istart,pend-1);
        return answer;

    &#125;

    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;

        return dfs(inorder,postorder,0,inorder.size()-1,0,postorder.size()-1);

    &#125;
&#125;;
</code></pre>
<h1 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwtaWkv">107. 二叉树的层序遍历 II</span></h1><h2 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<pre><code>输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = [1]
输出：[[1]]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>正常层序遍历，最后答案逆序即可</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; reverseres;
    if(!root) return res;
    queue&lt;TreeNode*&gt; qu;
    qu.push(root);
    while(!qu.empty())
    &#123;
        vector&lt;int&gt; tmp;
        int len=qu.size();
        for(int i=0;i&lt;len;i++)&#123;
            TreeNode* node=qu.front();
            qu.pop();
            tmp.push_back(node-&gt;val);
            if(node-&gt;left) qu.push(node-&gt;left);
            if(node-&gt;right) qu.push(node-&gt;right);
        &#125;
    res.push_back(tmp);
    &#125;

    reverseres=res;
    reverse(reverseres.begin(),reverseres.end());
    return reverseres;
    &#125;
&#125;;
</code></pre>
<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb252ZXJ0LXNvcnRlZC1saXN0LXRvLWJpbmFyeS1zZWFyY2gtdHJlZS8=">109. 有序链表转换二叉搜索树</span></h1><h2 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h2><p>给定一个单链表的头节点  <code>head</code> ，其中的元素 <strong>按升序排序</strong> ，将其转换为 </p>
<p>平衡</p>
<p> 二叉搜索树。</p>
<p><strong>示例 1:</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/17/linked.jpg" alt="img"></p>
<pre><code>输入: head = [-10,-3,0,5,9]
输出: [0,-3,9,-10,null,5]
解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: head = []
输出: []
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>head</code> 中的节点数在<code>[0, 2 * 104]</code> 范围内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>分支法，每次用快慢指针找到中间项slow作为当前树节点（同时记录slow前一个点），随slow左右后分割成两个新链表分别是当前树节点的左子树和右子树，代码示例中是链表递归法。另一种是先遍历链表得到vector数组，再用同样的方法分治理，因为每次取的是中间值，因此二叉搜索树的平衡性可以保证</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:

    TreeNode* dfs(ListNode* head)&#123;
        if(!head)&#123;
            return nullptr;
        &#125;
        ListNode* dummy = new ListNode();
        dummy-&gt;next = head;
        ListNode* before = dummy;
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast)&#123;
            fast = fast-&gt;next;
            if(fast&amp;&amp;fast-&gt;next)&#123;
                fast = fast-&gt;next;
            &#125;else&#123;
                break;
            &#125;
            slow = slow-&gt;next;
            before = before-&gt;next;
        &#125;
        TreeNode* now = new TreeNode(slow-&gt;val);
        before-&gt;next = nullptr;
        ListNode* left = dummy-&gt;next;
        ListNode* right = slow-&gt;next;
        slow-&gt;next = nullptr;

        now-&gt;left = dfs(left);
        now-&gt;right = dfs(right);

        return now;

    &#125;



    TreeNode* sortedListToBST(ListNode* head) &#123;
        return dfs(head);
    &#125;
&#125;;
</code></pre>
<h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS8=">113. 路径总和 II</span></h1><h2 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h2><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<pre><code>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<pre><code>输入：root = [1,2,3], targetSum = 5
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = [1,2], targetSum = 0
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>dfs记录路径和target值，叶子节点满足时添加路径到答案</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; answer;
    vector&lt;int&gt; temp;

    void dfs(TreeNode* root, int targetSum)&#123;
        if(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;
            if(targetSum==root-&gt;val)&#123;
                temp.push_back(root-&gt;val);
                answer.push_back(temp);
                temp.pop_back();
            &#125;
        &#125;
        else&#123;
            if(root-&gt;left)&#123;
                temp.push_back(root-&gt;val);
                dfs(root-&gt;left,targetSum-root-&gt;val);
                temp.pop_back();
            &#125;
            if(root-&gt;right)&#123;
                temp.push_back(root-&gt;val);
                dfs(root-&gt;right,targetSum-root-&gt;val);
                temp.pop_back();
            &#125;
        &#125;
    &#125;


    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
        if(!root) return &#123;&#125;;
        dfs(root,targetSum);
        return answer;

    &#125;
&#125;;
</code></pre>
<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGF0dGVuLWJpbmFyeS10cmVlLXRvLWxpbmtlZC1saXN0Lw==">114. 二叉树展开为链表</span></h1><h2 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<pre><code>输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = [0]
输出：[0]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>dfs前向遍历，用一个dummy节点记录最终答案，temp从dummy开始每前序遍历一个向right指针添加，注意要实现原地算法前向遍历root时预先记录left和right后将root-&gt;left和root-&gt;right设置为nullptr，再dfs（left）和dfs（right）</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    void flatten(TreeNode* root) &#123;
        if(!root)&#123;
            return;
        &#125;
        TreeNode* dummy = new TreeNode();
    
        TreeNode* temp = dummy;

        function&lt;void(TreeNode*)&gt; dfs = [&amp;](TreeNode* root)&#123;

            TreeNode* left = root-&gt;left;
            TreeNode* right = root-&gt;right;

            root-&gt;left = nullptr;
            root-&gt;right = nullptr;

            temp-&gt;right = root;
            temp = temp-&gt;right;


            if(left)&#123;
                dfs(left);
            &#125;
            
            if(right)&#123;
                dfs(right);
            &#125;
        &#125;;

        dfs(root);
    &#125;
&#125;;
</code></pre>
<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLw==">116. 填充每个节点的下一个右侧节点指针</span></h1><h2 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h2><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<pre><code>struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
</code></pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p>
<pre><code>输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li>
<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>层次遍历时记录每层，对每次的节点更新right即可</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/*
// Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;
&#125;;
*/

class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        queue&lt;Node*&gt; queue1=queue&lt;Node*&gt;();
        if(root==nullptr) return root;
        queue1.push(root);
        while(queue1.size()&gt;0)&#123;
            int levelNum = queue1.size();
            Node* first = queue1.front();
            queue1.pop();
            levelNum--;
            if(first-&gt;left!=nullptr)&#123;
                queue1.push(first-&gt;left);
            &#125;
            if(first-&gt;right!=nullptr)&#123;
                queue1.push(first-&gt;right);
            &#125;

            while(levelNum&gt;0)&#123;
                Node* second = queue1.front();
                queue1.pop();
                levelNum--;
                if(second-&gt;left!=nullptr)&#123;
                    queue1.push(second-&gt;left);
                &#125;
                if(second-&gt;right!=nullptr)&#123;
                    queue1.push(second-&gt;right);
                &#125;
                first-&gt;next=second;
                first = second;
            &#125;
        &#125;
        return root;

    &#125;
&#125;;
</code></pre>
<h1 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3B1bGF0aW5nLW5leHQtcmlnaHQtcG9pbnRlcnMtaW4tZWFjaC1ub2RlLWlpLw==">117. 填充每个节点的下一个右侧节点指针 II</span></h1><h2 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h2><p>给定一个二叉树：</p>
<pre><code>struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
</code></pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p>
<pre><code>输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 6000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li>
</ul>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>层次遍历时记录每层，对每次的节点更新right即可</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/*
// Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;
&#125;;
*/

class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        if(!root)&#123;
            return nullptr;
        &#125;
        queue&lt;Node*&gt; qu;
        qu.push(root);
        while(qu.size()&gt;0)&#123;
            int level_size = qu.size();
            for(int i=0;i&lt;level_size;i++)&#123;
                Node* temp = qu.front();
                qu.pop();
                if(temp-&gt;left!=nullptr)&#123;
                    qu.push(temp-&gt;left);
                &#125;
                if(temp-&gt;right!=nullptr)&#123;
                    qu.push(temp-&gt;right);
                &#125;    
                if(i&lt;level_size-1)&#123;
                    temp-&gt;next = qu.front();
                &#125;else&#123;
                    temp-&gt;next = nullptr;
                &#125;
            &#125;
        &#125;

        return root;

    &#125;
&#125;;
</code></pre>
<h1 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmlhbmdsZS8=">120. 三角形最小路径和</span></h1><h2 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h2><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：triangle = [[-10]]
输出：-10
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= triangle.length &lt;= 200</code></li>
<li><code>triangle[0].length == 1</code></li>
<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>
<li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li>
</ul>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>动态规划，对于每个层的0位置，其等于f[i][0] &#x3D; f[i - 1][0] + triangle[i][0];</p>
<p>中间位置为f[i][j] &#x3D; min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];</p>
<p>末尾位置为f[i][i] &#x3D; f[i - 1][i - 1] + triangle[i][i];</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;
        int n = triangle.size();
        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n));
        f[0][0] = triangle[0][0];
        for (int i = 1; i &lt; n; ++i) &#123;
            f[i][0] = f[i - 1][0] + triangle[i][0];
            for (int j = 1; j &lt; i; ++j) &#123;
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
            &#125;
            f[i][i] = f[i - 1][i - 1] + triangle[i][i];
        &#125;
        return *min_element(f[n - 1].begin(), f[n - 1].end());
    &#125;
&#125;;

</code></pre>
<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">122. 买卖股票的最佳时机 II</span></h1><h2 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>贪心，每次取相邻两个后减前之差大于0的放入答案</p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int p=0;
        int i;
        for(i=1; i&lt;prices.size(); ++i)
            p += max(0,prices[i]-prices[i-1]);
        return p;

    &#125;
&#125;;
</code></pre>
<h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlLw==">128. 最长连续序列</span></h1><h2 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>并查集或者哈希表。对于哈希表来说先去重放入set然后找开头元素，枚举nums[i]，如果nums[i]-1不在set中则跳过，否则从nums[i]开始计数，直到nums[i]+k不在set中，更新当前答案</p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
        unordered_set&lt;int&gt; num_set;
        for (const int&amp; num : nums) &#123;
            num_set.insert(num);
        &#125;

        int longestStreak = 0;

        for (const int&amp; num : num_set) &#123;
            if (!num_set.count(num - 1)) &#123;
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) &#123;
                    currentNum += 1;
                    currentStreak += 1;
                &#125;

                longestStreak = max(longestStreak, currentStreak);
            &#125;
        &#125;

        return longestStreak;           
    &#125;
&#125;;

</code></pre>
<h1 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tcm9vdC10by1sZWFmLW51bWJlcnMv">129. 求根节点到叶节点数字之和</span></h1><h2 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h2><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p>
<pre><code>输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1-&gt;2 代表数字 12
从根到叶子节点路径 1-&gt;3 代表数字 13
因此，数字总和 = 12 + 13 = 25
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p>
<pre><code>输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491
从根到叶子节点路径 4-&gt;0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>dfs把每条路径存起来，最后求和</p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    int answer;

    void dfs(TreeNode* root,int num)&#123;
        if(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;
            answer+=num*10+root-&gt;val;
            return;
        &#125;
        if(root-&gt;left)&#123;
            dfs(root-&gt;left,num*10+root-&gt;val);
        &#125;
        if(root-&gt;right)&#123;
            dfs(root-&gt;right,num*10+root-&gt;val);
        &#125;
    &#125;

    int sumNumbers(TreeNode* root) &#123;
        answer = 0;
        dfs(root,0);
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdXJyb3VuZGVkLXJlZ2lvbnMv">130. 被围绕的区域</span></h1><h2 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p>
<pre><code>输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]
输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#39;O&#39; 都不会被填充为 &#39;X&#39;。 任何不在边界上，或不与边界上的 &#39;O&#39; 相连的 &#39;O&#39; 最终都会被填充为 &#39;X&#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：board = [[&quot;X&quot;]]
输出：[[&quot;X&quot;]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>board[i][j]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li>
</ul>
<h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><p>对周围一圈的O作为起点dfs遍历将其设置为Y，最后遍历二维数组将剩余的O改为X，剩余的Y恢复为O</p>
<h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j)&#123;
        if(board[i][j]==&#39;O&#39;)&#123;
            board[i][j]=&#39;Y&#39;;
        &#125;else if(board[i][j]==&#39;X&#39;||board[i][j]==&#39;Y&#39;)&#123;
            return;
        &#125;

        for(int k=0;k&lt;4;k++)&#123;
            if(i+dir[k][0]&gt;=0&amp;&amp;i+dir[k][0]&lt;board.size()&amp;&amp;j+dir[k][1]&gt;=0&amp;&amp;j+dir[k][1]&lt;board[0].size())&#123;
                dfs(board,i+dir[k][0],j+dir[k][1]);
            &#125;
        &#125;
    &#125;

    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        for(int i=0;i&lt;board.size();i++)&#123;
            dfs(board,i,0);
            dfs(board,i,board[0].size()-1);
        &#125;

        for(int i=0;i&lt;board[0].size();i++)&#123;
            dfs(board,0,i);
            dfs(board,board.size()-1,i);
        &#125;

        for(int i=0;i&lt;board.size();i++)&#123;
            for(int j=0;j&lt;board[0].size();j++)&#123;
                if(board[i][j]==&#39;O&#39;)&#123;
                    board[i][j]=&#39;X&#39;;
                &#125;
            &#125;
        &#125;
        for(int i=0;i&lt;board.size();i++)&#123;
            for(int j=0;j&lt;board[0].size();j++)&#123;
                if(board[i][j]==&#39;Y&#39;)&#123;
                    board[i][j]=&#39;O&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLXBhcnRpdGlvbmluZy8=">131. 分割回文串</span></h1><h2 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 </p>
<p><strong>回文串</strong></p>
<p> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;aab&quot;
输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;a&quot;
输出：[[&quot;a&quot;]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><p>本题动态规划结合dfs，先通过构建dp[i][j]动态规划判断i到j是否是回文，判断方法是边界预设好后对于剩下的值如果s[i]&#x3D;&#x3D;s[j]则其答案等于dp[i+1][j-1]</p>
<p>随后用dfs每次取当前一个合适的回文串再dfs下一个回溯到末尾则添加答案</p>
<h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; f;
    vector&lt;vector&lt;string&gt;&gt; ret;
    vector&lt;string&gt; ans;
    int n;

public:
    void dfs(const string&amp; s, int i) &#123;
        if (i == n) &#123;
            ret.push_back(ans);
            return;
        &#125;
        for (int j = i; j &lt; n; ++j) &#123;
            if (f[i][j]) &#123;
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            &#125;
        &#125;
    &#125;

    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        n = s.size();
        f.assign(n, vector&lt;int&gt;(n, true));

        for (int i = n - 1; i &gt;= 0; --i) &#123;
            for (int j = i + 1; j &lt; n; ++j) &#123;
                f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + 1][j - 1];
            &#125;
        &#125;

        dfs(s, 0);
        return ret;
    &#125;
&#125;;
</code></pre>
<h1 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jbG9uZS1ncmFwaC8=">133. 克隆图</span></h1><h2 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h2><p>给你无向 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQkYlOUUlRTklODAlOUElRTUlOUIlQkUvNjQ2MDk5NT9mcj1hbGFkZGlu">连通</span></strong> 图中一个节点的引用，请你返回该图的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p>
<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<pre><code>class Node &#123;
    public int val;
    public List&lt;Node&gt; neighbors;
&#125;
</code></pre>
<p><strong>测试用例格式：</strong></p>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>
<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>
<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img"></p>
<pre><code>输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png" alt="img"></p>
<pre><code>输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>这张图中的节点数在 <code>[0, 100]</code> 之间。</li>
<li><code>1 &lt;= Node.val &lt;= 100</code></li>
<li>每个节点值 <code>Node.val</code> 都是唯一的，</li>
<li>图中没有重复的边，也没有自环。</li>
<li>图是连通图，你可以从给定节点访问到所有节点。</li>
</ul>
<h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><p>哈希表存现在图的各个节点和已复制的节点的对应关系</p>
<p>随后dfs图，如果遇到添加的节点还未new过，则new 一个节点存哈希表，如果已经存在了就直接取地址，不用哈希表的话就可能重复复制</p>
<h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/*
// Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; neighbors;
    Node() &#123;
        val = 0;
        neighbors = vector&lt;Node*&gt;();
    &#125;
    Node(int _val) &#123;
        val = _val;
        neighbors = vector&lt;Node*&gt;();
    &#125;
    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;
        val = _val;
        neighbors = _neighbors;
    &#125;
&#125;;
*/

class Solution &#123;
public:
    Node* cloneGraph(Node* node) &#123;
        unordered_map&lt;Node*,Node*&gt; mirror;
        function&lt;Node*(Node*)&gt; dfs = [&amp;](Node* a)-&gt;Node*&#123;
            if(!a)&#123;
                return nullptr;
            &#125;
            if(mirror.count(a))&#123;
                return mirror[a];
            &#125;
            Node* clone = new Node(a-&gt;val);
            mirror[a] = clone;

            for(int i=0;i&lt;a-&gt;neighbors.size();i++)&#123;
                if(!mirror.count(a-&gt;neighbors[i]))&#123;
                    Node* temp = dfs(a-&gt;neighbors[i]);
                    mirror[a]-&gt;neighbors.emplace_back(temp);
                &#125;else&#123;
                    mirror[a]-&gt;neighbors.emplace_back(mirror[a-&gt;neighbors[i]]);
                &#125;
            &#125;

            return mirror[a];
        &#125;;

        return dfs(node);

    &#125;
&#125;;
</code></pre>
<h1 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=">134. 加油站</span></h1><h2 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li>
</ul>
<h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><p>枚举各个位置看其是否能走通环路，但是可以贪心法去跳过某些不必要的起始点，贪心的做法是每次跳过至当前轮次走过的最远路径节点</p>
<h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int n = gas.size();
        int i = 0;
        while (i &lt; n) &#123;
            int sumOfGas = 0, sumOfCost = 0;
            int cnt = 0;
            while (cnt &lt; n) &#123;
                int j = (i + cnt) % n;
                sumOfGas += gas[j];
                sumOfCost += cost[j];
                if (sumOfCost &gt; sumOfGas) &#123;
                    break;
                &#125;
                cnt++;
            &#125;
            if (cnt == n) &#123;
                return i;
            &#125; else &#123;
                i = i + cnt + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;

</code></pre>
<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtbnVtYmVyLWlpLw==">137. 只出现一次的数字 II</span></h1><h2 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [2,2,3,2]
输出：3
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,1,0,1,0,1,99]
输出：99
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>
</ul>
<h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><p>不允许用哈希表，就用位运算，由于数字最大为2^32位，枚举每个二进制数字位0-32，对于非答案的数字其在该数字位上出现0次或者3次被三整除，而对于只出现一次的数字来说其出现0次或者1次，因此如果该数字出现则该数字位出现1的次数必定是3k+1个，因此每个数字位计数后判断其是否不能被三整除将答案的该位置设为1 ，最后各个位置构成的二进制数就是答案</p>
<h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;
        int ans = 0;
        for (int i = 0; i &lt; 32; ++i) &#123;
            int total = 0;
            for (int num: nums) &#123;
                total += ((num &gt;&gt; i) &amp; 1);
            &#125;
            if (total % 3) &#123;
                ans |= (1 &lt;&lt; i);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3B5LWxpc3Qtd2l0aC1yYW5kb20tcG9pbnRlci8=">138. 随机链表的复制</span></h1><h2 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjclQjElRTYlOEIlQjclRTglQjQlOUQvMjI3ODUzMTc/ZnI9YWxhZGRpbg==">深拷贝</span><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p>
<pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p>
<pre><code>输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
</code></pre>
<p><strong>示例 3：</strong></p>
<p><strong><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p>
<pre><code>输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
<li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li>
</ul>
<h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><p>凡是带有指针的数据结构的复制，就是用哈希表维护原node和复制node的对应关系，如果哈希表没有就new一个有就直接获取指针</p>
<h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/*
// Definition for a Node.
class Node &#123;
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) &#123;
        val = _val;
        next = NULL;
        random = NULL;
    &#125;
&#125;;
*/

class Solution &#123;
public:
    unordered_map&lt;Node*,Node*&gt; mp;
    Node* copyRandomList(Node* head) &#123;
        if(!head)&#123;
            return nullptr;
        &#125;
        Node* temp = head;
        Node* copyHead = new Node(head-&gt;val);
        mp[head] = copyHead;
        
        while(temp)&#123;
            if(temp-&gt;next==nullptr)&#123;
                mp[temp]-&gt;next = nullptr;
            &#125;else&#123;
                if(mp.count(temp-&gt;next))&#123;
                    mp[temp]-&gt;next = mp[temp-&gt;next];
                &#125;else&#123;
                    Node* copy = new Node(temp-&gt;next-&gt;val);
                    mp[temp-&gt;next] = copy;
                    mp[temp]-&gt;next = mp[temp-&gt;next];
                &#125;
            &#125;

            if(temp-&gt;random==nullptr)&#123;
                mp[temp]-&gt;random = nullptr;
            &#125;else&#123;
                if(mp.count(temp-&gt;random))&#123;
                    mp[temp]-&gt;random = mp[temp-&gt;random];
                &#125;else&#123;
                    Node* copy = new Node(temp-&gt;random-&gt;val);
                    mp[temp-&gt;random] = copy;
                    mp[temp]-&gt;random = mp[temp-&gt;random];
                &#125;
            &#125;


            temp = temp-&gt;next;
        &#125;

        return mp[head];
        
    &#125;
&#125;;
</code></pre>
<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLWJyZWFrLw==">139. 单词拆分</span></h1><h2 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
输出: true
解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。
     注意，你可以重复使用字典中的单词。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
输出: false
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><p>记忆化搜索，即dfs的时候加缓存判断dfs的位置是否已经访问过，先将字典转化为哈希表，dfs（s,index）表示下一个单词从s[index]开始取，枚举单词结束的位置next，如果取到了单词，则dfs(s,next)，如果next已经到了末尾说明找到答案</p>
<p>此外可以动态规划，dp[i]表示到i位置可以满足，每次遍历dp[0]到dp[i-1]看上一个true位置后到当前位置的substr是否在set里，只要有一个能满足则当前的dp[i]就是true</p>
<h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    unordered_set&lt;string&gt; st;
    unordered_map&lt;int,int&gt; visited;
    bool answer;

    void dfs(string s,int index)&#123;
        if(answer==true)&#123;
            return;
        &#125;
        if(index==s.size())&#123;
            answer = true;
            return;
        &#125;
        int next = index+1;
        for(int next=index+1;next&lt;=s.size();next++)&#123;
            if(visited.count(next)&amp;&amp;visited[next]&gt;0)&#123;
                continue;
            &#125;else if(st.count(s.substr(index,next-index))&gt;0)&#123;
                visited[next] = 1;
                dfs(s,next);
            &#125;
        &#125;
    &#125;;


    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        answer = false;
        for(auto x:wordDict)&#123;
            st.insert(x);
        &#125;
        dfs(s,0);

        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS1paS8=">142. 环形链表 II</span></h1><h2 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<pre><code>输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<pre><code>输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre>
<p><strong>示例 3：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<pre><code>输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><p>快慢指针加上数学的分析（也可以找规律），找到重合位置Node a，再令temp1 &#x3D; a，temp2&#x3D;head，让这两个指针同步向前，它们的再次重合的位置Node b即为答案</p>
<h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 */
 class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        ListNode *fast = head;
        ListNode *slow = head;
        bool hascycle = false;
        while(fast)&#123;
            fast = fast-&gt;next;
            slow = slow-&gt;next;
            if(!fast||!fast-&gt;next)&#123;
               break; 
            &#125;
            fast = fast-&gt;next;
            if(fast==slow)&#123;
                hascycle = true;
                break;
            &#125;
        &#125;
        if(!hascycle)&#123;return nullptr;&#125;
        else&#123;
            ListNode *temp=head;
            while(temp!=slow)&#123;
                temp = temp-&gt;next;
                slow = slow-&gt;next;
            &#125;
            return slow;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW9yZGVyLWxpc3Qv">143. 重排链表</span></h1><h2 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h2><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<pre><code>L0 → L1 → … → Ln - 1 → Ln
</code></pre>
<p>请将其重新排列后变为：</p>
<pre><code>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
</code></pre>
<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png" alt="img"></p>
<pre><code>输入：head = [1,2,3,4]
输出：[1,4,2,3]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://pic.leetcode-cn.com/1626420320-YUiulT-image.png" alt="img"></p>
<pre><code>输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为 <code>[1, 5 * 104]</code></li>
<li><code>1 &lt;= node.val &lt;= 1000</code></li>
</ul>
<h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><p>链表的大部分问题无非是用到合并两个链表、翻转链表、快慢指针找链表中点，本题就是先找到链表中点，断开成两个链表A,B，将链表B翻转为B‘，最后按照顺序合并A和B’</p>
<h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* reverselist(ListNode* head)&#123;
        ListNode* pre = nullptr;
        ListNode* now = head;

        while(now)&#123;
            ListNode* nxt = now-&gt;next;
            now-&gt;next = pre;
            pre = now;
            now = nxt;
        &#125;

        return pre;

    &#125;



    void reorderList(ListNode* head) &#123;
        if(!head||!head-&gt;next)&#123;
            return ;
        &#125;

        ListNode* dummy = new ListNode();
        dummy-&gt;next = head;
        int length = 0;
        ListNode* help = head;
        while(help)&#123;
            length++;
            help = help-&gt;next;
        &#125;
        int mid;
        if(length%2==0)&#123;
            mid = length/2;
        &#125;else&#123;
            mid = length/2+1;
        &#125;

        help = dummy;
        for(int i=0;i&lt;mid;i++)&#123;
            help = help-&gt;next;
        &#125;

        ListNode* order2 = help-&gt;next;

        help-&gt;next = nullptr;


        order2 = reverselist(order2);
        ListNode* order1 = dummy-&gt;next;


        ListNode* dummy2 = new ListNode();
        help = dummy2;

        int flag = 1;

        while(order1||order2)&#123;

            if(flag==1)&#123;
                flag = -flag; 
                help-&gt;next = order1;
                help = help-&gt;next;
                if(order1)&#123;
                    order1 = order1-&gt;next; 
                &#125;  
            &#125;else&#123;
                flag = -flag;
                help-&gt;next = order2;
                help = help-&gt;next;
                if(order2)&#123;
                    order2 = order2-&gt;next;
                &#125;  
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUv">146. LRU 缓存</span></h1><h2 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h2><p>请你设计并实现一个满足 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9MUlU=">LRU (最近最少使用) 缓存</span> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<pre><code>输入
[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;
lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><p>用到了哈希表和双向链表，哈希表记录key的节点，使用双向链表是为了删除节点方便，lru的思想是如果get或者put了说明使用了，将当前节点删除，添加到双向链表的头部，如果是put则判断是否超过cache size，超过则删除尾部节点</p>
<h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">struct DLinkedNode &#123;
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;
&#125;;

class LRUCache &#123;
private:
    unordered_map&lt;int, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    &#125;
    
    int get(int key) &#123;
        if (!cache.count(key)) &#123;
            return -1;
        &#125;
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node-&gt;value;
    &#125;
    
    void put(int key, int value) &#123;
        if (!cache.count(key)) &#123;
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size &gt; capacity) &#123;
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed-&gt;key);
                // 防止内存泄漏
                delete removed;
                --size;
            &#125;
        &#125;
        else &#123;
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node-&gt;value = value;
            moveToHead(node);
        &#125;
    &#125;

    void addToHead(DLinkedNode* node) &#123;
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    &#125;
    
    void removeNode(DLinkedNode* node) &#123;
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    &#125;

    void moveToHead(DLinkedNode* node) &#123;
        removeNode(node);
        addToHead(node);
    &#125;

    DLinkedNode* removeTail() &#123;
        DLinkedNode* node = tail-&gt;prev;
        removeNode(node);
        return node;
    &#125;
&#125;;

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
</code></pre>
<h1 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnRpb24tc29ydC1saXN0Lw==">147. 对链表进行插入排序</span></h1><h2 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h2><p>给定单个链表的头 <code>head</code> ，使用 <strong>插入排序</strong> 对链表进行排序，并返回 <em>排序后链表的头</em> 。</p>
<p><strong>插入排序</strong> 算法的步骤:</p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<p>下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。</p>
<p>对链表进行插入排序。</p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"></p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg" alt="img"></p>
<pre><code>输入: head = [4,2,1,3]
输出: [1,2,3,4]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg" alt="img"></p>
<pre><code>输入: head = [-1,5,3,4,0]
输出: [-1,0,3,4,5]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数在 <code>[1, 5000]</code>范围内</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><p>遍历链表然后插入排序，注意dummy节点的使用，最后返回dummy节点的next</p>
<h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    ListNode *insert(ListNode *head, ListNode *node) &#123;//将节点node插入head为头的有序链表, 返回插入后的有序链表头部
        ListNode *h0 = new ListNode(-1, head);
        ListNode *cur = h0;
        while (cur-&gt;next &amp;&amp; node-&gt;val &gt; cur-&gt;next-&gt;val)
            cur = cur-&gt;next;
        node-&gt;next = cur-&gt;next;
        cur-&gt;next = node;
        return h0-&gt;next;
    &#125;

    ListNode *insertionSortList(ListNode *head) &#123;
        ListNode *h = nullptr;
        for (ListNode *cur = head, *next; cur; cur = next) &#123;//遍历链表中的节点
            next = cur-&gt;next;
            h = insert(h, cur);
        &#125;
        return h;
    &#125;
&#125;;
</code></pre>
<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWxpc3Qv">148. 排序链表</span></h1><h2 id="题干-25"><a href="#题干-25" class="headerlink" title="题干"></a>题干</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<pre><code>输入：head = [4,2,1,3]
输出：[1,2,3,4]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<pre><code>输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：head = []
输出：[]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><p>可以使用之前做过的插入排序，但是效率低，更好的是使用链表的归并排序，这里用到了快慢指针找到链表的中点以及合并两个有序链表的代码，自上而下归并即可</p>
<h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    ListNode* sortList(ListNode* head) &#123;
        return sortList(head, nullptr);
    &#125;

    ListNode* sortList(ListNode* head, ListNode* tail) &#123;
        if (head == nullptr) &#123;
            return head;
        &#125;
        if (head-&gt;next == tail) &#123;
            head-&gt;next = nullptr;
            return head;
        &#125;
        ListNode* slow = head, *fast = head;
        while (fast != tail) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
            if (fast != tail) &#123;
                fast = fast-&gt;next;
            &#125;
        &#125;
        ListNode* mid = slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    &#125;

    ListNode* merge(ListNode* head1, ListNode* head2) &#123;
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;
            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;
                temp-&gt;next = temp1;
                temp1 = temp1-&gt;next;
            &#125; else &#123;
                temp-&gt;next = temp2;
                temp2 = temp2-&gt;next;
            &#125;
            temp = temp-&gt;next;
        &#125;
        if (temp1 != nullptr) &#123;
            temp-&gt;next = temp1;
        &#125; else if (temp2 != nullptr) &#123;
            temp-&gt;next = temp2;
        &#125;
        return dummyHead-&gt;next;
    &#125;
&#125;;

</code></pre>
<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi8=">150. 逆波兰表达式求值</span></h1><h2 id="题干-26"><a href="#题干-26" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODAlODYlRTYlQjMlQTIlRTUlODUlQjAlRTUlQkMlOEYvMTI4NDM3">逆波兰表示法</span> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><p>用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;int&gt; stk;
        int n = tokens.size();
        for (int i = 0; i &lt; n; i++) &#123;
            string&amp; token = tokens[i];
            if (isNumber(token)) &#123;
                stk.push(atoi(token.c_str()));
            &#125; else &#123;
                int num2 = stk.top();
                stk.pop();
                int num1 = stk.top();
                stk.pop();
                switch (token[0]) &#123;
                    case &#39;+&#39;:
                        stk.push(num1 + num2);
                        break;
                    case &#39;-&#39;:
                        stk.push(num1 - num2);
                        break;
                    case &#39;*&#39;:
                        stk.push(num1 * num2);
                        break;
                    case &#39;/&#39;:
                        stk.push(num1 / num2);
                        break;
                &#125;
            &#125;
        &#125;
        return stk.top();
    &#125;

    bool isNumber(string&amp; token) &#123;
        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);
    &#125;
&#125;;
</code></pre>
<h1 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">151. 反转字符串中的单词</span></h1><h2 id="题干-27"><a href="#题干-27" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;the sky is blue&quot;
输出：&quot;blue is sky the&quot;
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;  hello world  &quot;
输出：&quot;world hello&quot;
解释：反转后的字符串中不能存在前导空格和尾随空格。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;a good   example&quot;
输出：&quot;example good a&quot;
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>c++关于split或者类型转换时先想到stringstream，不能满足时再自己写split函数，本题split后重新倒序拼接单词即可</p>
<h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string reverseWords(string s) &#123;
        vector&lt;string&gt; v;
        stringstream ss(s);
        string temp;
        while(ss&gt;&gt;temp)&#123;
            v.emplace_back(temp);
        &#125;

        string answer;
        for(int i=v.size()-1;i&gt;=0;i--)&#123;
            answer += v[i];
            if(i!=0)&#123;
                answer+=&quot; &quot;;
            &#125;
        &#125;

        return answer;

    &#125;
&#125;;
</code></pre>
<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkv">152. 乘积最大子数组</span></h1><h2 id="题干-28"><a href="#题干-28" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续</p>
<p>子数组</p>
<p>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li>
</ul>
<h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><p>两个数组的动态规划（其实就是二维），一个维度记录历史乘积最小值，一个记录最大值，这是因为当前数字可能是正可能是负，正的找上一个正的最大，负的找上一个负的最小</p>
<h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; maxF(nums.size());
        vector&lt;int&gt; minF(nums.size());

        maxF[0] = nums[0];
        minF[0] = nums[0];

        int answer = nums[0];

        for(int i=1;i&lt;nums.size();i++)&#123;
            maxF[i] = max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));
            if(maxF[i]&gt;answer)&#123;
                answer = maxF[i];
            &#125;
            minF[i] = min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1pbmltdW0taW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">153. 寻找旋转排序数组中的最小值</span></h1><h2 id="题干-29"><a href="#题干-29" class="headerlink" title="题干"></a>题干</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><p>二分法，根据mid和right的比较判断最小值接下来在哪个区域</p>
<h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int findMin(vector&lt;int&gt;&amp; nums) &#123;
        int left = 0;
        int right = nums.size()-1;
        while(left&lt;right)&#123;
            int mid = left+(right-left)/2;
            if(nums[mid]&gt;nums[right])&#123;
                left = mid+1;
            &#125;else&#123;
                right = mid;
            &#125;
        &#125;

        return nums[right];


    &#125;
&#125;;
</code></pre>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">155. 最小栈</span></h1><h2 id="题干-30"><a href="#题干-30" class="headerlink" title="题干"></a>题干</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><code>输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= val &lt;= 231 - 1</code></li>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
<li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li>
</ul>
<h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><p>用两个栈，一个栈就是普通的栈，另一个是用来同步当前最小值的同步栈，push和pop都同步操作</p>
<h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class MinStack &#123;
public:
    vector&lt;int&gt; stack;
    vector&lt;int&gt; minStack;
    MinStack() &#123;
    &#125;
    
    void push(int val) &#123;
        if(stack.size()==0)&#123;
            minStack.emplace_back(val);
        &#125;else&#123;
            minStack.emplace_back(min(val,minStack.back()));
        &#125;
        stack.emplace_back(val);
       
    &#125;
    
    void pop() &#123;
        stack.pop_back();
        minStack.pop_back();
    &#125;
    
    int top() &#123;
        return stack.back();
    &#125;
    
    int getMin() &#123;
        return minStack.back();

    &#125;
&#125;;

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
</code></pre>
<h1 id="156-上下翻转二叉树"><a href="#156-上下翻转二叉树" class="headerlink" title="156. 上下翻转二叉树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS11cHNpZGUtZG93bi8=">156. 上下翻转二叉树</span></h1><h2 id="题干-31"><a href="#题干-31" class="headerlink" title="题干"></a>题干</h2><p>给你一个二叉树的根节点 <code>root</code> ，请你将此二叉树上下翻转，并返回新的根节点。</p>
<p>你可以按下面的步骤翻转一棵二叉树：</p>
<ol>
<li>原来的左子节点变成新的根节点</li>
<li>原来的根节点变成新的右子节点</li>
<li>原来的右子节点变成新的左子节点</li>
</ol>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/29/main.jpg" alt="img"></p>
<p>上面的步骤逐层进行。题目数据保证每个右节点都有一个同级节点（即共享同一父节点的左节点）且不存在子节点。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/29/updown.jpg" alt="img"></p>
<pre><code>输入：root = [1,2,3,4,5]
输出：[4,5,2,null,null,3,1]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：root = []
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：root = [1]
输出：[1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 10]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 10</code></li>
<li>树中的每个右节点都有一个同级节点（即共享同一父节点的左节点）</li>
<li>树中的每个右节点都没有子节点</li>
</ul>
<h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><p>dfs递归，每次传入father，l，r三个节点，下次递归是l，l.left，l.right，其中l.left，l.right每次要单独存下来（因为l的left要连到上次递归的节点上）</p>
<h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* upsideDownBinaryTree(TreeNode* root) &#123;
        if(!root||!root-&gt;left)&#123;
            return root;
        &#125;
        
        function&lt;TreeNode*(TreeNode*,TreeNode*,TreeNode*)&gt; dfs = [&amp;](TreeNode* father,TreeNode* l,TreeNode* r)&#123;
            if(!l)&#123;
                return father;
            &#125;

            TreeNode* nextLeft = l-&gt;left;
            TreeNode* nextRight = l-&gt;right;

            l-&gt;left = r;
            l-&gt;right = father;

            return dfs(l,nextLeft,nextRight);

        &#125;;
        return dfs(nullptr,root,nullptr);

    &#125;
&#125;;
</code></pre>
<h1 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159. 至多包含两个不同字符的最长子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRoLWF0LW1vc3QtdHdvLWRpc3RpbmN0LWNoYXJhY3RlcnMv">159. 至多包含两个不同字符的最长子串</span></h1><h2 id="题干-32"><a href="#题干-32" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 <code>s</code> ，请你找出 <strong>至多</strong> 包含 <strong>两个不同字符</strong> 的最长子串，并返回该子串的长度。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;eceba&quot;
输出：3
解释：满足题目要求的子串是 &quot;ece&quot; ，长度为 3 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;ccaabbb&quot;
输出：5
解释：满足题目要求的子串是 &quot;aabbb&quot; ，长度为 5 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由英文字母组成</li>
</ul>
<h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口加哈希表，求出所有满足题意的子数组，求最长那个</p>
<h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int lengthOfLongestSubstringTwoDistinct(string s) &#123;
        unordered_map&lt;char,int&gt; mp;
        int diff_num = 0;
        int answer = 0;
        int l = 0;
        for(int r=0;r&lt;s.size();r++)&#123;
            mp[s[r]]+=1;
            if(mp.size()&lt;=2)&#123;
                answer = max(answer,r-l+1);
            &#125;else&#123;
                while(mp.size()&gt;2)&#123;
                    mp[s[l]]--;
                    if(mp[s[l]]==0)&#123;
                        mp.erase(s[l]);
                    &#125;    
                    l++;
                &#125;
                answer = max(answer,r-l+1);
            &#125;
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="161-相隔为-1-的编辑距离"><a href="#161-相隔为-1-的编辑距离" class="headerlink" title="161. 相隔为 1 的编辑距离"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vbmUtZWRpdC1kaXN0YW5jZS8=">161. 相隔为 1 的编辑距离</span></h1><h2 id="题干-33"><a href="#题干-33" class="headerlink" title="题干"></a>题干</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，如果它们的编辑距离为 <code>1</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>字符串 <code>s</code> 和字符串 <code>t</code> 之间满足编辑距离等于 1 有三种可能的情形：</p>
<ul>
<li>往 <code>s</code> 中插入 <strong>恰好一个</strong> 字符得到 <code>t</code></li>
<li>从 <code>s</code> 中删除 <strong>恰好一个</strong> 字符得到 <code>t</code></li>
<li>在 <code>s</code> 中用 <strong>一个不同的字符</strong> 替换 <strong>恰好一个</strong> 字符得到 <code>t</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入: s = &quot;ab&quot;, t = &quot;acb&quot;
输出: true
解释: 可以将 &#39;c&#39; 插入字符串 s 来得到 t。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: s = &quot;cab&quot;, t = &quot;ad&quot;
输出: false
解释: 无法通过 1 步操作使 s 变为 t。
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 104</code></li>
<li><code>s</code> 和 <code>t</code> 由小写字母，大写字母和数字组成</li>
</ul>
<h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><p>按照编辑距离<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">72. 编辑距离</span>做二维dp，判断右下角答案是否为1</p>
<h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool isOneEditDistance(string s, string t) &#123;
        vector&lt;vector&lt;int&gt;&gt; distance(s.size()+1,vector&lt;int&gt;(t.size()+1));
        int temp = 0;
        for(int i=0;i&lt;distance.size();i++)&#123;
            distance[i][0] = temp;
            temp++;
        &#125;

        temp = 0;

        for(int j=0;j&lt;distance[0].size();j++)&#123;
            distance[0][j] = temp;
            temp++;
        &#125;

        for(int i=1;i&lt;distance.size();i++)&#123;
            for(int j=1;j&lt;distance[0].size();j++)&#123;
                if(s[i-1]==t[j-1])&#123;
                    distance[i][j] = min(distance[i-1][j-1],min(distance[i-1][j]+1,distance[i][j-1]+1));

                &#125;else&#123;
                    distance[i][j] = min(distance[i-1][j-1]+1,min(distance[i-1][j]+1,distance[i][j-1]+1));
                &#125;
            &#125;
        &#125;
        return distance[s.size()][t.size()]==1;


    &#125;
&#125;;
</code></pre>
<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBlYWstZWxlbWVudC8=">162. 寻找峰值</span></h1><h2 id="题干-34"><a href="#题干-34" class="headerlink" title="题干"></a>题干</h2><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>
</ul>
<h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><p>二分查找，爬坡法，判断mid在上坡还是下坡，从而判断在那个半边继续二分</p>
<h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;
        int left = 0, right = nums.size() - 1;
        while (left &lt; right) &#123;
            int mid = (left + right) &gt;&gt; 1;
            if (nums[mid] &gt; nums[mid + 1]) &#123;
                right = mid;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;
    &#125;
&#125;;

</code></pre>
<h1 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWdhcC8=">164. 最大间距</span></h1><h2 id="题干-35"><a href="#题干-35" class="headerlink" title="题干"></a>题干</h2><p>给定一个无序的数组 <code>nums</code>，返回 <em>数组在排序之后，相邻元素之间最大的差值</em> 。如果数组元素个数小于 2，则返回 <code>0</code> 。</p>
<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: nums = [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><p>基数排序（桶排序）后复杂度O（nk），k为排序的轮数（数组中最大值的位数），随后寻找相邻的最大值即可</p>
<h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int maximumGap(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        //如果数组元素个数小于 2，则返回 0
        if(n &lt; 2)
        &#123;
            return 0;
        &#125;
        vector&lt;int&gt; buf(n);             //buf为临时顺组，用于存储每次排完序的数组
        int maxVal = *max_element(nums.begin(), nums.end());
        int time = maxBit(maxVal);      //计算出需要最高位数，即需要排多少次
        int dev = 1;
        //开始从低位到高位基数排序
        for(int i = 0; i &lt; time; i++)&#123;
            vector&lt;vector&lt;int&gt;&gt; count(10);      //桶
            //统计每个桶中有多少个数
            for(int j = 0; j &lt; n; j++)&#123;
                int digit = (nums[j] / dev) % 10;     //digit 为nums[j]的第i位数
                count[digit].emplace_back(nums[j]);
            &#125;
            int index = n-1;

            for(int number = 9;number&gt;=0;number--)&#123;
                while(count[number].size()&gt;0)&#123;
                    nums[index] = count[number].back();
                    count[number].pop_back();
                    index--;
                &#125;
            &#125;
            dev *= 10;
        &#125;
        //找到相邻元素最大差值
        int ret = 0;
        for (int i = 1; i &lt; n; i++) &#123;
            ret = max(ret, nums[i] - nums[i - 1]);
        &#125;
        return ret;
    &#125;
    int maxBit(int maxVal)&#123;
        int p = 10;
        int d = 1;
        while(maxVal &gt;= p)&#123;
            p *= 10;
            d++;
        &#125;
        return d;
    &#125;
&#125;;
</code></pre>
<h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21wYXJlLXZlcnNpb24tbnVtYmVycy8=">165. 比较版本号</span></h1><h2 id="题干-36"><a href="#题干-36" class="headerlink" title="题干"></a>题干</h2><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li>
<li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li>
<li>除此之外返回 <code>0</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;
输出：0
解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;
输出：-1
解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>
<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>&#39;.&#39;</code></li>
<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>
<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>
</ul>
<h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2><p>把版本号按照‘.’分割（自己写分割或者使用stringstream），分别将每段转int后存入两个vector中，对于短的vector在后面补充0至齐平，最后从位置0开始比较两个vector的对应位置大小</p>
<h2 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int compareVersion(string version1, string version2) &#123;
        vector&lt;int&gt; v1;
        vector&lt;int&gt; v2;


        int start = 0;
        int end = 0;
        while(end!=version1.size())&#123;
            end++;
            if(version1[end]==&#39;.&#39;)&#123;
                string temp = version1.substr(start,end-start);
                v1.emplace_back(atoi(temp.c_str()));
                start = end+1;
                end = start;
            &#125;
        &#125;

        if(end&gt;start)&#123;
            string temp = version1.substr(start,end-start);
            v1.emplace_back(atoi(temp.c_str()));
        &#125;

        start = 0;
        end = 0;
        while(end!=version2.size())&#123;
            end++;
            if(version2[end]==&#39;.&#39;)&#123;
                string temp = version2.substr(start,end-start);
                v2.emplace_back(atoi(temp.c_str()));
                start = end+1;
                end = start;
            &#125;
        &#125;

        if(end&gt;start)&#123;
            string temp = version2.substr(start,end-start);
            v2.emplace_back(atoi(temp.c_str()));
        &#125;

        while(v1.size()&lt;v2.size())&#123;
            v1.emplace_back(0);
        &#125;

        while(v2.size()&lt;v1.size())&#123;
            v2.emplace_back(0);
        &#125;


        for(int i=0;i&lt;v1.size();i++)&#123;
            if(v1[i]&gt;v2[i])&#123;
                return 1;
            &#125;
            if(v1[i]&lt;v2[i])&#123;
                return -1;
            &#125;
        &#125;

        return 0;

    &#125;
&#125;;
</code></pre>
<h1 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166. 分数到小数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mcmFjdGlvbi10by1yZWN1cnJpbmctZGVjaW1hbC8=">166. 分数到小数</span></h1><h2 id="题干-37"><a href="#题干-37" class="headerlink" title="题干"></a>题干</h2><h2 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string fractionToDecimal(int numerator, int denominator) &#123;
        long numeratorLong = numerator;
        long denominatorLong = denominator;
        if (numeratorLong % denominatorLong == 0) &#123;
            return to_string(numeratorLong / denominatorLong);
        &#125;

        string ans;
        if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) &#123;
            ans.push_back(&#39;-&#39;);
        &#125;

        // 整数部分
        numeratorLong = abs(numeratorLong);
        denominatorLong = abs(denominatorLong);
        long integerPart = numeratorLong / denominatorLong;
        ans += to_string(integerPart);
        ans.push_back(&#39;.&#39;);

        // 小数部分
        string fractionPart;
        unordered_map&lt;long, int&gt; remainderIndexMap;
        long remainder = numeratorLong % denominatorLong;
        int index = 0;
        while (remainder != 0 &amp;&amp; !remainderIndexMap.count(remainder)) &#123;
            remainderIndexMap[remainder] = index;
            remainder *= 10;
            fractionPart += to_string(remainder / denominatorLong);
            remainder %= denominatorLong;
            index++;
        &#125;
        if (remainder != 0) &#123; // 有循环节
            int insertIndex = remainderIndexMap[remainder];
            fractionPart = fractionPart.substr(0,insertIndex) + &#39;(&#39; + fractionPart.substr(insertIndex);
            fractionPart.push_back(&#39;)&#39;);
        &#125;
        ans += fractionPart;

        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="166-分数到小数-1"><a href="#166-分数到小数-1" class="headerlink" title="166. 分数到小数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mcmFjdGlvbi10by1yZWN1cnJpbmctZGVjaW1hbC8=">166. 分数到小数</span></h1><h2 id="题干-38"><a href="#题干-38" class="headerlink" title="题干"></a>题干</h2><p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>
<p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>104</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：numerator = 1, denominator = 2
输出：&quot;0.5&quot;
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：numerator = 2, denominator = 1
输出：&quot;2&quot;
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：numerator = 4, denominator = 333
输出：&quot;0.(012)&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li>
<li><code>denominator != 0</code></li>
</ul>
<h2 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h2><p>模拟长除法，整数部分直接除法取整即可，小数部分哈希表记录remainder（当前被除数）和对应index，如果发现重复了说明是循环小数就退出长除</p>
<h2 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string fractionToDecimal(int numerator, int denominator) &#123;
        long numeratorLong = numerator;
        long denominatorLong = denominator;
        if (numeratorLong % denominatorLong == 0) &#123;
            return to_string(numeratorLong / denominatorLong);
        &#125;

        string ans;
        if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) &#123;
            ans.push_back(&#39;-&#39;);
        &#125;

        // 整数部分
        numeratorLong = abs(numeratorLong);
        denominatorLong = abs(denominatorLong);
        long integerPart = numeratorLong / denominatorLong;
        ans += to_string(integerPart);
        ans.push_back(&#39;.&#39;);

        // 小数部分
        string fractionPart;
        unordered_map&lt;long, int&gt; remainderIndexMap;
        long remainder = numeratorLong % denominatorLong;
        int index = 0;
        while (remainder != 0 &amp;&amp; !remainderIndexMap.count(remainder)) &#123;
            remainderIndexMap[remainder] = index;
            remainder *= 10;
            fractionPart += to_string(remainder / denominatorLong);
            remainder %= denominatorLong;
            index++;
        &#125;
        
        if (remainder != 0) &#123; // 有循环节
            int insertIndex = remainderIndexMap[remainder];
            fractionPart = fractionPart.substr(0,insertIndex) + &#39;(&#39; + fractionPart.substr(insertIndex);
            fractionPart.push_back(&#39;)&#39;);
        &#125;
        ans += fractionPart;

        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLWlpLWlucHV0LWFycmF5LWlzLXNvcnRlZC8=">167. 两数之和 II - 输入有序数组</span></h1><h2 id="题干-39"><a href="#题干-39" class="headerlink" title="题干"></a>题干</h2><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p>
<p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p>
<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li><strong>仅存在一个有效答案</strong></li>
</ul>
<h2 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h2><p>可以用<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==">1. 两数之和</span>去做，但是本题已经有序的话可以按顺序固定一个数，再在这个数之后的数组中二分查找另一个数，找到说明有答案</p>
<h2 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;
        for (int i = 0; i &lt; numbers.size(); ++i) &#123;
            int low = i + 1, high = numbers.size() - 1;
            while (low &lt;= high) &#123;
                int mid = (high - low) / 2 + low;
                if (numbers[mid] == target - numbers[i]) &#123;
                    return &#123;i + 1, mid + 1&#125;;
                &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;
                    high = mid - 1;
                &#125; else &#123;
                    low = mid + 1;
                &#125;
            &#125;
        &#125;
        return &#123;-1, -1&#125;;
    &#125;
&#125;;
</code></pre>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mYWN0b3JpYWwtdHJhaWxpbmctemVyb2VzLw==">172. 阶乘后的零</span></h1><h2 id="题干-40"><a href="#题干-40" class="headerlink" title="题干"></a>题干</h2><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p>
<p>提示 <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：n = 0
输出：0
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>你可以设计并实现对数时间复杂度的算法来解决此问题吗？</p>
<h2 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h2><p>小学奥数题，由于10&#x3D;5*2，对于阶乘来说5的数量远远大于2的数量，因此本题转化为各个数字中存在多少5，累加即可</p>
<h2 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int trailingZeroes(int n) &#123;
        int ans = 0;
        for (int i = 5; i &lt;= n; i += 5) &#123;
            for (int x = i; x % 5 == 0; x /= 5) &#123;
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLXRyZWUtaXRlcmF0b3Iv">173. 二叉搜索树迭代器</span></h1><h2 id="题干-41"><a href="#题干-41" class="headerlink" title="题干"></a>题干</h2><p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>
<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>
</ul>
<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<p><strong>示例：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></p>
<pre><code>输入
[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 106</code></li>
<li>最多调用 <code>105</code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>
</ul>
<h2 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h2><p>用栈模拟中序dfs，维护当前访问的Treenode即可</p>
<h2 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class BSTIterator &#123;
private:
    TreeNode* cur;
    stack&lt;TreeNode*&gt; stk;
public:
    BSTIterator(TreeNode* root): cur(root) &#123;&#125;
    
    int next() &#123;
        while (cur != nullptr) &#123;
            stk.push(cur);
            cur = cur-&gt;left;
        &#125;
        cur = stk.top();
        stk.pop();
        int ret = cur-&gt;val;
        cur = cur-&gt;right;
        return ret;
    &#125;
    
    bool hasNext() &#123;
        return cur != nullptr || !stk.empty();
    &#125;
&#125;;

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj-&gt;next();
 * bool param_2 = obj-&gt;hasNext();
 */
</code></pre>
<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LW51bWJlci8=">179. 最大数</span></h1><h2 id="题干-42"><a href="#题干-42" class="headerlink" title="题干"></a>题干</h2><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [10,2]
输出：&quot;210&quot;
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [3,30,34,5,9]
输出：&quot;9534330&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h2 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h2><p>转化成vector&lt;string&gt;后自定义排序并拼接，这里的string a和string b的排序规则是a+b&gt;b+a</p>
<h2 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;string&gt; strs;
        for(int i=0;i&lt;nums.size();i++)&#123;
            strs.emplace_back(to_string(nums[i]));
        &#125;

        sort(strs.begin(),strs.end(),[&amp;](const string &amp;a,const string &amp;b)&#123;
            return a+b&gt;b+a;
        &#125;);
        int notzero = 0;
        string answer=&quot;&quot;;
        for(auto &amp;x:strs)&#123;
            answer+=x;
        &#125;

        string answer2=&quot;&quot;;
        int zero = 0;
        for(int i=0;i&lt;answer.size();i++)&#123;
            if(zero==0&amp;&amp;answer[i]==&#39;0&#39;)&#123;
                continue;
            &#125;else&#123;
                zero = 1;
                answer2+=answer[i];
            &#125;
        &#125;

        return answer2.size()==0?&quot;0&quot;:answer2;

    &#125;
&#125;;
</code></pre>
<h1 id="186-反转字符串中的单词-II"><a href="#186-反转字符串中的单词-II" class="headerlink" title="186. 反转字符串中的单词 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpLw==">186. 反转字符串中的单词 II</span></h1><h2 id="题干-43"><a href="#题干-43" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符数组 <code>s</code> ，反转其中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 的定义为：单词是一个由非空格字符组成的序列。<code>s</code> 中的单词将会由单个空格分隔。</p>
<p>必须设计并实现 <strong>原地</strong> 解法来解决此问题，即不分配额外的空间。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = [&quot;t&quot;,&quot;h&quot;,&quot;e&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;]
输出：[&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;t&quot;,&quot;h&quot;,&quot;e&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = [&quot;a&quot;]
输出：[&quot;a&quot;]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 可以是一个英文字母（大写或小写）、数字、或是空格 <code>&#39; &#39;</code> 。</li>
<li><code>s</code> 中至少存在一个单词</li>
<li><code>s</code> 不含前导或尾随空格</li>
<li>题目数据保证：<code>s</code> 中的每个单词都由单个空格分隔</li>
</ul>
<h2 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h2><p>先整体翻转，再双指针确定每个单词的left和right，对于[left,right]范围内的字符进行reverse</p>
<h2 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:

    void reverseOneWord(vector&lt;char&gt;&amp; s,int left,int right)&#123;
        while(left&lt;right)&#123;
            int temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--; 
        &#125;
    &#125;

    void reverseWords(vector&lt;char&gt;&amp; s) &#123;
        reverse(s.begin(),s.end());

        int start = 0;
        int end = 0;
        int n = s.size();
        while(end+1&lt;n)&#123;
            if(s[end+1]==&#39; &#39;)&#123;
                reverseOneWord(s, start, end);
                start = end+2;
                end = start;
            &#125;else&#123;
                end++;
            &#125;
        &#125;
        reverseOneWord(s, start, end); //最后一个单词
    &#125;
&#125;;
</code></pre>
<h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBlYXRlZC1kbmEtc2VxdWVuY2VzLw==">187. 重复的DNA序列</span></h1><h2 id="题干-44"><a href="#题干-44" class="headerlink" title="题干"></a>题干</h2><p><strong>DNA序列</strong> 由一系列核苷酸组成，缩写为 <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code>.。</p>
<ul>
<li>例如，<code>&quot;ACGAATTCCG&quot;</code> 是一个 <strong>DNA序列</strong> 。</li>
</ul>
<p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p>
<p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的 <strong>长度为 <code>10</code></strong> 的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;
输出：[&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;AAAAAAAAAAAAA&quot;
输出：[&quot;AAAAAAAAAA&quot;]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]``==``&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> or <code>&#39;T&#39;</code></li>
</ul>
<h2 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口加哈希表，这里的优化技巧是将字母映射为数字然后用位运算保存int值，如果该int值出现过两次则将序列加入答案</p>
<h2 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
    const int L = 10;
    unordered_map&lt;char, int&gt; bin = &#123;&#123;'A', 0&#125;, &#123;'C', 1&#125;, &#123;'G', 2&#125;, &#123;'T', 3&#125;&#125;;
public:
    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;
        vector&lt;string&gt; ans;
        int n = s.length();
        if (n &lt;= L) &#123;
            return ans;
        &#125;
        int x = 0;
        for (int i = 0; i &lt; L-1 ; ++i) &#123;
            x = (x &lt;&lt; 2) | bin[s[i]];
        &#125;
        unordered_map&lt;int, int&gt; cnt;

        for (int i = 0; i &lt;= n - L; ++i) &#123;
            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; (L * 2)) - 1);
            if (++cnt[x] == 2) &#123;
                ans.push_back(s.substr(i, L));
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtYXJyYXkv">189. 轮转数组</span></h1><h2 id="题干-45"><a href="#题干-45" class="headerlink" title="题干"></a>题干</h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h2 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h2><p>将轮转转化为三次翻转，可以举个例子翻转试试看</p>
<h2 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        while (start &lt; end) &#123;
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        &#125;
    &#125;

    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    &#125;
&#125;;

</code></pre>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ob3VzZS1yb2JiZXIv">198. 打家劫舍</span></h1><h2 id="题干-46"><a href="#题干-46" class="headerlink" title="题干"></a>题干</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<h2 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h2><p>一维动态规划，dp[i]表示到i位置结尾时的最大值，dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p>
<h2 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size()==0) &#123;
            return 0;
        &#125;
        int size = nums.size();
        if (size == 1) &#123;
            return nums[0];
        &#125;
        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i &lt; size; i++) &#123;
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        &#125;
        return dp[size - 1];
    &#125;
&#125;;
</code></pre>
<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">199. 二叉树的右视图</span></h1><h2 id="题干-47"><a href="#题干-47" class="headerlink" title="题干"></a>题干</h2><ul>
<li><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1:</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p>
<pre><code>输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [1,null,3]
输出: [1,3]
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: []
输出: []
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</li>
</ul>
<h2 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h2><p>bfs树，每次记录每一层的最后一个值即可</p>
<h2 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; q;
        vector&lt;int&gt; answer;
        if(!root) return &#123;&#125;;
        q.push(root);
        
        while(q.size()&gt;0)&#123;
            int len = q.size();
            for(int i=0;i&lt;len;i++)&#123;

                TreeNode* temp = q.front();
                q.pop();
                if(temp-&gt;left)&#123;
                    q.push(temp-&gt;left);
                &#125;
                if(temp-&gt;right)&#123;
                    q.push(temp-&gt;right);
                &#125;

                if(i==len-1)&#123;
                    answer.push_back(temp-&gt;val);
                &#125;
            &#125;
        &#125;

        return answer;


    &#125;
&#125;;
</code></pre>
<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">200. 岛屿数量</span></h1><h2 id="题干-48"><a href="#题干-48" class="headerlink" title="题干"></a>题干</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
输出：1
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
输出：3
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<h2 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h2><p>对每个点进行dfs，建立visited数组，每次dfs会将一个岛屿的所有点都设置为visited&#x3D;1，因此只要visited&#x3D;0且grid[i][j]&#x3D;1说明有一个新岛屿</p>
<h2 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int dx[4]=&#123;0,-1,0,1&#125;;
    int dy[4]=&#123;1,0,-1,0&#125;;
    int answer = 0;
    vector&lt;vector&lt;int&gt;&gt; isReached;

    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int x, int y) &#123;
        if(grid[x][y]==&#39;1&#39;&amp;&amp;isReached[x][y]==0)&#123;
            isReached[x][y] = 1;
            int xLength=grid.size();
            int yLength=grid[0].size();
            for(int i=0;i&lt;4;i++)&#123;
                if(x+dx[i]&gt;=0&amp;&amp;x+dx[i]&lt;xLength&amp;&amp;y+dy[i]&gt;=0&amp;&amp;y+dy[i]&lt;yLength)
                &#123;
                    dfs(grid,x+dx[i],y+dy[i]);
                &#125;
            &#125;
        &#125;
    &#125;

    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        int xLength=grid.size();
        int yLength=grid[0].size();
        isReached = vector&lt;vector&lt;int&gt;&gt;(xLength, vector&lt;int&gt;(yLength));

        for(int i=0;i&lt;grid.size();i++)&#123;
            for(int j=0;j&lt;grid[0].size();j++)&#123;
                if(grid[i][j]==&#39;1&#39;&amp;&amp;isReached[i][j]==0)&#123;
                    answer++;
                    dfs(grid,i,j);
                &#125;
            &#125;
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>

      <div class="tags">
          <a href="/tags/c/" rel="tag"><i class="ic i-tag"></i> c++</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-05-03 00:27:43" itemprop="dateModified" datetime="2024-05-03T00:27:43+08:00">2024-05-03</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Kun Qian <i class="ic i-at"><em>@</em></i>Qkgoalkeeper's blog
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" title="Leetcode中等题思路（101-100）">https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode中等题思路(101-200)/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;qkgoalkeeper&#x2F;blogImage@main&#x2F;img&#x2F;leetcode.png" title="Leetcode中等题思路（1-100）">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 算法题思路</span>
  <h3>Leetcode中等题思路（1-100）</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/computer-science/leetcode/method/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;qkgoalkeeper&#x2F;blogImage@main&#x2F;img&#x2F;leetcode.png" title="并查集专题">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Leetcode</span>
  <h3>并查集专题</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">102. 二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2"><span class="toc-number">1.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-1"><span class="toc-number">2.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-2"><span class="toc-number">3.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-3"><span class="toc-number">4.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">4.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II"><span class="toc-number">5.</span> <span class="toc-text">107. 二叉树的层序遍历 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-4"><span class="toc-number">5.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">5.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">5.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">109. 有序链表转换二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-5"><span class="toc-number">6.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">6.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">6.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="toc-number">7.</span> <span class="toc-text">113. 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-6"><span class="toc-number">7.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">7.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">7.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">114. 二叉树展开为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-7"><span class="toc-number">8.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">8.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">8.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">116. 填充每个节点的下一个右侧节点指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-8"><span class="toc-number">9.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">9.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">9.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="toc-number">10.</span> <span class="toc-text">117. 填充每个节点的下一个右侧节点指针 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-9"><span class="toc-number">10.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">10.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">10.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">11.</span> <span class="toc-text">120. 三角形最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-10"><span class="toc-number">11.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">11.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">11.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-number">12.</span> <span class="toc-text">122. 买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-11"><span class="toc-number">12.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">12.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-number">12.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">13.</span> <span class="toc-text">128. 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-12"><span class="toc-number">13.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">13.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-number">13.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#129-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="toc-number">14.</span> <span class="toc-text">129. 求根节点到叶节点数字之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-13"><span class="toc-number">14.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">14.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-number">14.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="toc-number">15.</span> <span class="toc-text">130. 被围绕的区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-14"><span class="toc-number">15.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">15.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-number">15.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">16.</span> <span class="toc-text">131. 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-15"><span class="toc-number">16.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">16.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-number">16.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#133-%E5%85%8B%E9%9A%86%E5%9B%BE"><span class="toc-number">17.</span> <span class="toc-text">133. 克隆图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-16"><span class="toc-number">17.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">17.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-number">17.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">18.</span> <span class="toc-text">134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-17"><span class="toc-number">18.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-number">18.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-number">18.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II"><span class="toc-number">19.</span> <span class="toc-text">137. 只出现一次的数字 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-18"><span class="toc-number">19.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-number">19.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-number">19.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">20.</span> <span class="toc-text">138. 随机链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-19"><span class="toc-number">20.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-number">20.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-number">20.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">21.</span> <span class="toc-text">139. 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-20"><span class="toc-number">21.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-number">21.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-number">21.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-number">22.</span> <span class="toc-text">142. 环形链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-21"><span class="toc-number">22.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-number">22.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-number">22.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">23.</span> <span class="toc-text">143. 重排链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-22"><span class="toc-number">23.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-number">23.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-number">23.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-number">24.</span> <span class="toc-text">146. LRU 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-23"><span class="toc-number">24.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-number">24.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-number">24.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">25.</span> <span class="toc-text">147. 对链表进行插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-24"><span class="toc-number">25.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-number">25.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-number">25.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">26.</span> <span class="toc-text">148. 排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-25"><span class="toc-number">26.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-number">26.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-number">26.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">27.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-26"><span class="toc-number">27.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-number">27.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-number">27.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">28.</span> <span class="toc-text">151. 反转字符串中的单词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-27"><span class="toc-number">28.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-number">28.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-number">28.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">29.</span> <span class="toc-text">152. 乘积最大子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-28"><span class="toc-number">29.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-number">29.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-number">29.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">30.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-29"><span class="toc-number">30.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-number">30.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-number">30.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">31.</span> <span class="toc-text">155. 最小栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-30"><span class="toc-number">31.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-number">31.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-number">31.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#156-%E4%B8%8A%E4%B8%8B%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">32.</span> <span class="toc-text">156. 上下翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-31"><span class="toc-number">32.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-number">32.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-number">32.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#159-%E8%87%B3%E5%A4%9A%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">33.</span> <span class="toc-text">159. 至多包含两个不同字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-32"><span class="toc-number">33.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-number">33.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-number">33.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#161-%E7%9B%B8%E9%9A%94%E4%B8%BA-1-%E7%9A%84%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">34.</span> <span class="toc-text">161. 相隔为 1 的编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-33"><span class="toc-number">34.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-number">34.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-number">34.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">35.</span> <span class="toc-text">162. 寻找峰值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-34"><span class="toc-number">35.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-number">35.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-number">35.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#164-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D"><span class="toc-number">36.</span> <span class="toc-text">164. 最大间距</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-35"><span class="toc-number">36.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-number">36.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-number">36.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">37.</span> <span class="toc-text">165. 比较版本号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-36"><span class="toc-number">37.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-number">37.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-number">37.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">166. 分数到小数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-37"><span class="toc-number">38.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-number">38.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-number">38.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0-1"><span class="toc-number">39.</span> <span class="toc-text">166. 分数到小数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-38"><span class="toc-number">39.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-number">39.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-number">39.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">40.</span> <span class="toc-text">167. 两数之和 II - 输入有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-39"><span class="toc-number">40.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-number">40.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-number">40.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="toc-number">41.</span> <span class="toc-text">172. 阶乘后的零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-40"><span class="toc-number">41.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-number">41.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-number">41.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">42.</span> <span class="toc-text">173. 二叉搜索树迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-41"><span class="toc-number">42.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-number">42.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-number">42.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-number">43.</span> <span class="toc-text">179. 最大数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-42"><span class="toc-number">43.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-number">43.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-number">43.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#186-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-II"><span class="toc-number">44.</span> <span class="toc-text">186. 反转字符串中的单词 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-43"><span class="toc-number">44.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-number">44.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-number">44.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="toc-number">45.</span> <span class="toc-text">187. 重复的DNA序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-44"><span class="toc-number">45.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-number">45.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-number">45.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">46.</span> <span class="toc-text">189. 轮转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-45"><span class="toc-number">46.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-number">46.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-number">46.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">47.</span> <span class="toc-text">198. 打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-46"><span class="toc-number">47.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-number">47.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-number">47.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">48.</span> <span class="toc-text">199. 二叉树的右视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-47"><span class="toc-number">48.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-number">48.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-number">48.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">49.</span> <span class="toc-text">200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-48"><span class="toc-number">49.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-number">49.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-number">49.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" rel="bookmark" title="Leetcode中等题思路（1-100）">Leetcode中等题思路（1-100）</a></li><li><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(301-400)/" rel="bookmark" title="Leetcode中等题思路（1-100）">Leetcode中等题思路（1-100）</a></li><li class="active"><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" rel="bookmark" title="Leetcode中等题思路（101-100）">Leetcode中等题思路（101-100）</a></li><li><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(201-300)/" rel="bookmark" title="Leetcode中等题思路（201-300）">Leetcode中等题思路（201-300）</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Kun Qian"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Kun Qian</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">37</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">7</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">12</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FrZ29hbGtlZXBlcg==" title="https:&#x2F;&#x2F;github.com&#x2F;qkgoalkeeper"><i class="ic i-github"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9oYW8tbGFpLXd1LXNob3UtbWVuLXl1YW4=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-lai-wu-shou-men-yuan"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM5MjU2NzE4Nw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;392567187"><i class="ic i-cloud-music"></i></span>
      <a href="/about/" title="&#x2F;about&#x2F;" class="item about"><i class="ic i-address-card"></i></a>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/computer-science/leetcode/method/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
</div>

    <span><a href="/computer-science/leetcode/method/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/" title="并查集专题">并查集专题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/" title="分类于 算法题思路">算法题思路</a>
</div>

    <span><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" title="Leetcode中等题思路（101-100）">Leetcode中等题思路（101-100）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/method/c++%20std%E7%9A%84map%E5%8E%9F%E7%90%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E4%BD%BF%E7%94%A8/" title="剑指 Offer II 001. 整数除法">剑指 Offer II 001. 整数除法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/study/" title="分类于 研究生学习">研究生学习</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/study/paper/" title="分类于 论文源码解读">论文源码解读</a>
</div>

    <span><a href="/computer-science/study/paper/Spooky%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" title="SPOOKY论文解读">SPOOKY论文解读</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/method/c++%20std%20vector%E3%80%81queue%E3%80%81stack%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="剑指 Offer II 001. 整数除法">剑指 Offer II 001. 整数除法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/method/acm%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/" title="剑指 Offer II 001. 整数除法">剑指 Offer II 001. 整数除法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20008.%20%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%20target%20%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/" title="剑指 Offer II 008. 和大于等于 target 的最短子数组">剑指 Offer II 008. 和大于等于 target 的最短子数组</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/method/%E5%9B%BE%E8%B7%AF%E5%BE%84%E4%B8%93%E9%A2%98/" title="剑指 Offer II 001. 整数除法">剑指 Offer II 001. 整数除法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/method/%E8%AE%BE%E8%AE%A1%E7%B1%BB%E4%B8%93%E9%A2%98%EF%BC%88LRU%E3%80%81trie%EF%BC%89/" title="剑指 Offer II 001. 整数除法">剑指 Offer II 001. 整数除法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20003.%20%E5%89%8D%20n%20%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%201%20%E7%9A%84%E4%B8%AA%E6%95%B0/" title="剑指 Offer II 003. 前 n 个数字二进制中 1 的个数">剑指 Offer II 003. 前 n 个数字二进制中 1 的个数</a></span>
  </li>

  </ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Kun Qian @ Kun Qian</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'computer-science/leetcode/algorithm/Leetcode中等题思路(101-200)/',
    favicon: {
      show: "qkgoalkeeper's blog",
      hide: "qkgoalkeeper's blog"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
