



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="">
  <link rel="manifest" href="/images/manifest.json">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="Qkgoalkeeper's blog" href="https://qkgoalkeeper.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="c++" />


<link rel="canonical" href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/">



  <title>
Leetcode中等题思路（1-100） - 算法题思路 - Leetcode - 计算机科学 |
Kun Qian = Qkgoalkeeper's blog</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Leetcode中等题思路（1-100）
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2024-04-06 14:45:48">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2024-04-06T14:45:48+08:00">2024-04-06</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Kun Qian</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://cdn.jsdelivr.net/gh/qkgoalkeeper/blogImage@main/img/leetcode.png">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/leetcode/" itemprop="item" rel="index" title="分类于 Leetcode"><span itemprop="name">Leetcode</span></a>
<meta itemprop="position" content="2" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/leetcode/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/" itemprop="item" rel="index" title="分类于 算法题思路"><span itemprop="name">算法题思路</span></a>
<meta itemprop="position" content="3" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Kun Qian">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Qkgoalkeeper's blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv">2. 两数相加</span></h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<pre><code>输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：l1 = [0], l2 = [0]
输出：[0]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) &#123;
            int n1 = l1 ? l1-&gt;val: 0;
            int n2 = l2 ? l2-&gt;val: 0;
            int sum = n1 + n2 + carry;
            if (!head) &#123;
                head = tail = new ListNode(sum % 10);
            &#125; else &#123;
                tail-&gt;next = new ListNode(sum % 10);
                tail = tail-&gt;next;
            &#125;
            carry = sum / 10;
            if (l1) &#123;
                l1 = l1-&gt;next;
            &#125;
            if (l2) &#123;
                l2 = l2-&gt;next;
            &#125;
        &#125;
        if (carry &gt; 0) &#123;
            tail-&gt;next = new ListNode(carry);
        &#125;
        return head;
    &#125;
&#125;;
</code></pre>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==">3. 无重复字符的最长子串</span></h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong></p>
<p> 的长度。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: s = &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: s = &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: s = &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>滑动窗口，固定右端点，不满足条件时左端点移动，此处的条件是窗口内不含有重复字符（用哈希表去重）</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        if(s.size() == 0) return 0;
        unordered_set&lt;char&gt; lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i &lt; s.size(); i++)&#123;
            while (lookup.find(s[i]) != lookup.end())&#123;
                lookup.erase(s[left]);
                left ++;
            &#125;
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
    &#125;
        return maxStr;
        
    &#125;
&#125;;
</code></pre>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy8=">5. 最长回文子串</span></h1><h2 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;babad&quot;
输出：&quot;bab&quot;
解释：&quot;aba&quot; 同样是符合题意的答案。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;cbbd&quot;
输出：&quot;bb&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单的方法是遍历每个i向外中心扩散，这会有很多重复计算，这里改用动态规划。令dp动态规划数组表示从l到r的区间是否是回文<code>dp[l][r]=true</code> 并且(<code>l-1</code>)和（<code>r+1</code>)两个位置为相同的字符，此时 <code>dp[l-1][r+1]=true</code>。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

class Solution &#123;
public:
    string longestPalindrome(string s) &#123;
        int n = s.size();
        if (n &lt; 2) &#123;
            return s;
        &#125;

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i &lt; n; i++) &#123;
            dp[i][i] = true;
        &#125;
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L &lt;= n; L++) &#123;
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i &lt; n; i++) &#123;
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j &gt;= n) &#123;
                    break;
                &#125;

                if (s[i] != s[j]) &#123;
                    dp[i][j] = false;
                &#125; else &#123;
                    if (j - i &lt; 3) &#123;
                        dp[i][j] = true;
                    &#125; else &#123;
                        dp[i][j] = dp[i + 1][j - 1];
                    &#125;
                &#125;

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;
                    maxLen = j - i + 1;
                    begin = i;
                &#125;
            &#125;
        &#125;
        return s.substr(begin, maxLen);
    &#125;
&#125;;
</code></pre>
<h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy96aWd6YWctY29udmVyc2lvbi8=">6. Z 字形变换</span></h1><h2 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h2><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<pre><code>P   A   H   N
A P L S I I G
Y   I   R
</code></pre>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre><code>string convert(string s, int numRows);
</code></pre>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3
输出：&quot;PAHNAPLSIIGYIR&quot;
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4
输出：&quot;PINALSIGYAHRPI&quot;
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;A&quot;, numRows = 1
输出：&quot;A&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
<li><code>1 &lt;= numRows &lt;= 1000</code></li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>每行维护一个长度为numRows长度的vector&lt;vector&lt;char&gt;&gt; s(numRow.size())，设置一个flag表示下一个vector的顺序是正还是负，遍历字符串，按原字符串顺序依次放入s[0],…s[numsRow.size()-1],当达到numsRow.size()-1时flag转为负，遇到0下标时再转为正</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string convert(string s, int numRows) &#123;
        if (numRows &lt; 2)
            return s;
        vector&lt;string&gt; rows(numRows);
        int i = 0, flag = -1;
        for (char c : s) &#123;
            rows[i].push_back(c);
            if (i == 0 || i == numRows -1)
                flag = - flag;
            i += flag;
        &#125;
        string res;
        for (const string &amp;row : rows)
            res += row;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWludGVnZXIv">7. 整数反转</span></h1><h2 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：x = 123
输出：321
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：x = -123
输出：-321
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：x = 120
输出：21
</code></pre>
<p><strong>示例 4：</strong></p>
<pre><code>输入：x = 0
输出：0
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>用%和&#x2F;取到反转数，关键在于如何判断反转后是否越界INT_MIN和INT_MAX，记住一个结论是rev &#x3D; rev * 10 + digit;之前判断if (rev &lt; INT_MIN &#x2F; 10 || rev &gt; INT_MAX &#x2F; 10) </p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int reverse(int x) &#123;
        int rev = 0;
        while (x != 0) &#123;
            if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123;
                return 0;
            &#125;
            int digit = x % 10;
            x /= 10;
            rev = rev * 10 + digit;
        &#125;
        return rev;
    &#125;
&#125;;
</code></pre>
<h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdHJpbmctdG8taW50ZWdlci1hdG9pLw==">8. 字符串转换整数 (atoi)</span></h1><h2 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li>
<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>直接遍历字符串模拟，同样注意溢出问题，溢出的边界是INT_MAX&#x2F;10要记住</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int myAtoi(string s) &#123;
        int res = 0, bndry = INT_MAX / 10;
        int i = 0, sign = 1, length = s.size();
        if(length == 0) return 0;
        while(s[i] == &#39; &#39;)
            if(++i == length) return 0;
        if(s[i] == &#39;-&#39;) sign = -1;
        if(s[i] == &#39;-&#39; || s[i] == &#39;+&#39;) i++;
        for(int j = i; j &lt; length; j++) &#123;
            if(s[j] &lt; &#39;0&#39; || s[j] &gt; &#39;9&#39;) break;
            if(res &gt; bndry || res == bndry &amp;&amp; s[j] &gt; &#39;7&#39;)
                return sign == 1 ? INT_MAX : INT_MIN;
            res = res * 10 + (s[j] - &#39;0&#39;);
        &#125;
        return sign * res;
    &#125;
&#125;;

</code></pre>
<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLw==">11. 盛最多水的容器</span></h1><h2 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<pre><code>输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：height = [1,1]
输出：1
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>贪心法，双指针指向数组两端点，每次移动值较短的那个指针向中心靠拢，更新最大值</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int maxArea(vector&lt;int&gt;&amp; height) &#123;
        int i = 0, j = height.size() - 1, res = 0;
        while(i &lt; j) &#123;
            res = height[i] &lt; height[j] ? 
                max(res, (j - i) * height[i++]): 
                max(res, (j - i) * height[j--]); 
        &#125;
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlZ2VyLXRvLXJvbWFuLw==">12. 整数转罗马数字</span></h1><h2 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h2><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</code></pre>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: num = 3
输出: &quot;III&quot;
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: num = 4
输出: &quot;IV&quot;
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: num = 9
输出: &quot;IX&quot;
</code></pre>
<p><strong>示例 4:</strong></p>
<pre><code>输入: num = 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
</code></pre>
<p><strong>示例 5:</strong></p>
<pre><code>输入: num = 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 3999</code></li>
</ul>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>题干都提示了，本质上就类似自定义的进制转换，在题目1，5，10，50，100，500，1000的基础上额外添加4，9，40，90，400，900的表示，随后对一个数字进行贪心选取每次取最大的数表示放入最后答案</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">const pair&lt;int, string&gt; valueSymbols[] = &#123;
    &#123;1000, &quot;M&quot;&#125;,
    &#123;900,  &quot;CM&quot;&#125;,
    &#123;500,  &quot;D&quot;&#125;,
    &#123;400,  &quot;CD&quot;&#125;,
    &#123;100,  &quot;C&quot;&#125;,
    &#123;90,   &quot;XC&quot;&#125;,
    &#123;50,   &quot;L&quot;&#125;,
    &#123;40,   &quot;XL&quot;&#125;,
    &#123;10,   &quot;X&quot;&#125;,
    &#123;9,    &quot;IX&quot;&#125;,
    &#123;5,    &quot;V&quot;&#125;,
    &#123;4,    &quot;IV&quot;&#125;,
    &#123;1,    &quot;I&quot;&#125;,
&#125;;

class Solution &#123;
public:
    string intToRoman(int num) &#123;
        string roman;
        for (const auto &amp;[value, symbol] : valueSymbols) &#123;
            while (num &gt;= value) &#123;
                num -= value;
                roman += symbol;
            &#125;
            if (num == 0) &#123;
                break;
            &#125;
        &#125;
        return roman;
    &#125;
&#125;;

</code></pre>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtLw==">15. 三数之和</span></h1><h2 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>先排序，随后第一次循环固定第一个数a，题目转换为在【a下标+1，末尾】的数组中的两数之和，用双指针解决两数之和，注意指针指向时如果新的数和上一个数完全相同则跳过</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        // 枚举 a
        for (int first = 0; first &lt; n; ++first) &#123;
            // 需要和上一次枚举的数不相同
            if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) &#123;
                continue;
            &#125;
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second &lt; n; ++second) &#123;
                // 需要和上一次枚举的数不相同
                if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) &#123;
                    continue;
                &#125;
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;
                    --third;
                &#125;
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
                if (second == third) &#123;
                    break;
                &#125;
                if (nums[second] + nums[third] == target) &#123;
                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;

</code></pre>
<h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtLWNsb3Nlc3Qv">16. 最接近的三数之和</span></h1><h2 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,0,0], target = 1
输出：0
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>类似三数之和，先排序，枚举第一个元素，随后双指针法找到第二第三元素，每次指针移动后计算新的答案是否比已有答案小</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int best = 1e7;

        // 根据差值的绝对值来更新答案
        auto update = [&amp;](int cur) &#123;
            if (abs(cur - target) &lt; abs(best - target)) &#123;
                best = cur;
            &#125;
        &#125;;

        // 枚举 a
        for (int i = 0; i &lt; n; ++i) &#123;
            // 保证和上一次枚举的元素不相等
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
                continue;
            &#125;
            // 使用双指针枚举 b 和 c
            int j = i + 1, k = n - 1;
            while (j &lt; k) &#123;
                int sum = nums[i] + nums[j] + nums[k];
                // 如果和为 target 直接返回答案
                if (sum == target) &#123;
                    return target;
                &#125;
                update(sum);
                if (sum &gt; target) &#123;
                    // 如果和大于 target，移动 c 对应的指针
                    int k0 = k - 1;
                    // 移动到下一个不相等的元素
                    while (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) &#123;
                        --k0;
                    &#125;
                    k = k0;
                &#125; else &#123;
                    // 如果和小于 target，移动 b 对应的指针
                    int j0 = j + 1;
                    // 移动到下一个不相等的元素
                    while (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) &#123;
                        ++j0;
                    &#125;
                    j = j0;
                &#125;
            &#125;
        &#125;
        return best;
    &#125;
&#125;;

</code></pre>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXR0ZXItY29tYmluYXRpb25zLW9mLWEtcGhvbmUtbnVtYmVyLw==">17. 电话号码的字母组合</span></h1><h2 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：digits = &quot;23&quot;
输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：digits = &quot;&quot;
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：digits = &quot;2&quot;
输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>经典dfs回溯法，用哈希表存每个数字对应的多个char，随后dfs过程中存取答案返回条件是长度等于题目给出的长度</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        vector&lt;string&gt; combinations;
        if (digits.empty()) &#123;
            return combinations;
        &#125;
        unordered_map&lt;char, string&gt; phoneMap&#123;
            &#123;&#39;2&#39;, &quot;abc&quot;&#125;,
            &#123;&#39;3&#39;, &quot;def&quot;&#125;,
            &#123;&#39;4&#39;, &quot;ghi&quot;&#125;,
            &#123;&#39;5&#39;, &quot;jkl&quot;&#125;,
            &#123;&#39;6&#39;, &quot;mno&quot;&#125;,
            &#123;&#39;7&#39;, &quot;pqrs&quot;&#125;,
            &#123;&#39;8&#39;, &quot;tuv&quot;&#125;,
            &#123;&#39;9&#39;, &quot;wxyz&quot;&#125;
        &#125;;
        string combination;
        backtrack(combinations, phoneMap, digits, 0, combination);
        return combinations;
    &#125;

    void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) &#123;
        if (index == digits.length()) &#123;
            combinations.push_back(combination);
        &#125; else &#123;
            char digit = digits[index];
            const string&amp; letters = phoneMap.at(digit);
            for (const char&amp; letter: letters) &#123;
                combination.push_back(letter);
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.pop_back();
            &#125;
        &#125;
    &#125;
&#125;;

</code></pre>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy80c3VtLw==">18. 四数之和</span></h1><h2 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>和三数循环一模一样，就是多了一层枚举，还是先排序，然后枚举第一个数字，再枚举第二个数字，最后两个数字用双指针，这里可以注意找到第一个数字时如果接下来三个连续的数字加上去已经大于target了就可以剪枝返回，或者加上最后三个数字还是小于target也剪枝返回</p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; quadruplets;
        if (nums.size() &lt; 4) &#123;
            return quadruplets;
        &#125;
        sort(nums.begin(), nums.end());
        int length = nums.size();
        for (int i = 0; i &lt; length - 3; i++) &#123;
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
                continue;
            &#125;
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;
                break;
            &#125;
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                continue;
            &#125;
            for (int j = i + 1; j &lt; length - 2; j++) &#123;
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;
                    continue;
                &#125;
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;
                    break;
                &#125;
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                    continue;
                &#125;
                int left = j + 1, right = length - 1;
                while (left &lt; right) &#123;
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum == target) &#123;
                        quadruplets.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);
                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;
                            left++;
                        &#125;
                        left++;
                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;
                            right--;
                        &#125;
                        right--;
                    &#125; else if (sum &lt; target) &#123;
                        left++;
                    &#125; else &#123;
                        right--;
                    &#125;
                &#125;
            &#125;
        &#125;
        return quadruplets;
    &#125;
&#125;;

作者：力扣官方题解
链接：https://leetcode.cn/problems/4sum/solutions/436368/si-shu-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC8=">19. 删除链表的倒数第 N 个结点</span></h1><h2 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<pre><code>输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = [1], n = 1
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：head = [1,2], n = 1
输出：[1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>用两个指针，第一个指针比第二个指针超前n个，这样当第一个指针指向最后一个时，第二个指针正好是需要剪切的节点的父节点。注意链表题当发现存在边界特判问题时（比如只有n个节点倒数第n个就是第一个节点），可以使用dummy哑结点添加到头结点前</p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        ListNode* dummy = new ListNode(0, head);
        ListNode* first = head;
        ListNode* second = dummy;
        for (int i = 0; i &lt; n; ++i) &#123;
            first = first-&gt;next;
        &#125;
        while (first) &#123;
            first = first-&gt;next;
            second = second-&gt;next;
        &#125;
        second-&gt;next = second-&gt;next-&gt;next;
        ListNode* ans = dummy-&gt;next;
        delete dummy;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZW5lcmF0ZS1wYXJlbnRoZXNlcy8=">22. 括号生成</span></h1><h2 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 3
输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1
输出：[&quot;()&quot;]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>回溯法dfs，每次添加括号时判断左括号的数量是否大于右括号才能dfs下一个右括号，左括号的添加只取决于括号的总数量</p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
    void backtrack(vector&lt;string&gt;&amp; ans, string&amp; cur, int open, int close, int n) &#123;
        if (cur.size() == n * 2) &#123;
            ans.push_back(cur);
            return;
        &#125;
        if (open &lt; n) &#123;
            cur.push_back(&#39;(&#39;);
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        &#125;
        if (close &lt; open) &#123;
            cur.push_back(&#39;)&#39;);
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        &#125;
    &#125;
public:
    vector&lt;string&gt; generateParenthesis(int n) &#123;
        vector&lt;string&gt; result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    &#125;
&#125;;
</code></pre>
<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zd2FwLW5vZGVzLWluLXBhaXJzLw==">24. 两两交换链表中的节点</span></h1><h2 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<pre><code>输入：head = [1,2,3,4]
输出：[2,1,4,3]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = []
输出：[]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：head = [1]
输出：[1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><p>链表递归法，swapPairs（a）交换节点a和b(a-&gt;next)后a的下一个指针指向swapPairs(b)根据这个规律写递归函数</p>
<h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        if(!head||!head-&gt;next)&#123;
            return head;
        &#125;
        ListNode* a = head;
        ListNode* b = head-&gt;next;

        ListNode* c = b-&gt;next;
        
        b-&gt;next = a;
        a-&gt;next = swapPairs(c);
        
        return b;
    &#125;
&#125;;
</code></pre>
<h1 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtdHdvLWludGVnZXJzLw==">29. 两数相除</span></h1><h2 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h2><p>给你两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。</p>
<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的 <strong>商</strong> 。</p>
<p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−231, 231 − 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>231 − 1</code> ，则返回 <code>231 − 1</code> ；如果商 <strong>严格小于</strong> <code>-231</code> ，则返回 <code>-231</code> 。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = 3.33333.. ，向零截断后得到 3 。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = -2.33333.. ，向零截断后得到 -2 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= dividend, divisor &lt;= 231 - 1</code></li>
<li><code>divisor != 0</code></li>
</ul>
<h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><p>将被除数和除数都变为负数，这样就不会有溢出的问题，记被除数为 X，除数为 Y，并且 X 和 Y都是负数。我们需要找出 X&#x2F;Y 的结果 Z。Z 一定是正数或 0。<em>Z</em>×<em>Y</em>≥<em>X</em>&gt;(<em>Z</em>+1)×<em>Y</em>，可以使用二分查找的方法得到 ZZ<em>Z</em>，即找出<strong>最大</strong>的 Z 使得 <em>Z</em>×<em>Y</em>≥<em>X</em> 成立。不能使用乘法运算符，因此我们需要使用「快速乘」算法得到 Z×YZ \times YZ×Y 的值。「快速乘」算法与「快速幂」类似，前者通过加法实现乘法，后者通过乘法实现幂运算。「快速幂」算法可以参考「50. Pow(x, n)」的官方题解] <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtdHdvLWludGVnZXJzL3NvbHV0aW9ucy8xMDQxOTM5L2xpYW5nLXNodS14aWFuZy1jaHUtYnktbGVldGNvZGUtc29sdXRpb24tNWhpYy8=">https://leetcode.cn/problems/divide-two-integers/solutions/1041939/liang-shu-xiang-chu-by-leetcode-solution-5hic/</span></p>
<h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int divide(int dividend, int divisor) &#123;
        // 考虑被除数为最小值的情况
        if (dividend == INT_MIN) &#123;
            if (divisor == 1) &#123;
                return INT_MIN;
            &#125;
            if (divisor == -1) &#123;
                return INT_MAX;
            &#125;
        &#125;
        // 考虑除数为最小值的情况
        if (divisor == INT_MIN) &#123;
            return dividend == INT_MIN ? 1 : 0;
        &#125;
        // 考虑被除数为 0 的情况
        if (dividend == 0) &#123;
            return 0;
        &#125;
        
        // 一般情况，使用二分查找
        // 将所有的正数取相反数，这样就只需要考虑一种情况
        bool rev = false;
        if (dividend &gt; 0) &#123;
            dividend = -dividend;
            rev = !rev;
        &#125;
        if (divisor &gt; 0) &#123;
            divisor = -divisor;
            rev = !rev;
        &#125;

        // 快速乘
        auto quickAdd = [](int y, int z, int x) &#123;
            // x 和 y 是负数，z 是正数
            // 需要判断 z * y &gt;= x 是否成立
            int result = 0, add = y;
            while (z) &#123;
                if (z &amp; 1) &#123;
                    // 需要保证 result + add &gt;= x
                    if (result &lt; x - add) &#123;
                        return false;
                    &#125;
                    result += add;
                &#125;
                if (z != 1) &#123;
                    // 需要保证 add + add &gt;= x
                    if (add &lt; x - add) &#123;
                        return false;
                    &#125;
                    add += add;
                &#125;
                // 不能使用除法
                z &gt;&gt;= 1;
            &#125;
            return true;
        &#125;;
        
        int left = 1, right = INT_MAX, ans = 0;
        while (left &lt;= right) &#123;
            // 注意溢出，并且不能使用除法
            int mid = left + ((right - left) &gt;&gt; 1);
            bool check = quickAdd(divisor, mid, dividend);
            if (check) &#123;
                ans = mid;
                // 注意溢出
                if (mid == INT_MAX) &#123;
                    break;
                &#125;
                left = mid + 1;
            &#125;
            else &#123;
                right = mid - 1;
            &#125;
        &#125;

        return rev ? -ans : ans;
    &#125;
&#125;;

</code></pre>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LXBlcm11dGF0aW9uLw==">31. 下一个排列</span></h1><h2 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU="> 原地 </span>**修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,3]
输出：[1,3,2]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [3,2,1]
输出：[1,2,3]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [1,1,5]
输出：[1,5,1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><p>思路是从后往前找第一个非增的数nums[i]，对这个数后面的数组排序，选择后面数组nums[i+1:]中的第一个大于nums[i]的数和nums[i]交换</p>
<h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;
        int i = nums.size()-1;
        while(i&gt;0&amp;&amp;nums[i-1]&gt;=nums[i])&#123;
            i--;
        &#125;

        if(i==0)&#123;
            sort(nums.begin(),nums.end());
        &#125;else&#123;
            sort(nums.begin()+i,nums.end());
            for(int j=i;j&lt;nums.size();j++)&#123;
                if(nums[i-1]&lt;nums[j])&#123;
                    int temp = nums[i-1];
                    nums[i-1] = nums[j];
                    nums[j] = temp;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkv">33. 搜索旋转排序数组</span></h1><h2 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [1], target = 0
输出：-1
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><p>在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分，二分的写法有多种注意模板</p>
<h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n = (int)nums.size();
        if (!n) &#123;
            return -1;
        &#125;
        if (n == 1) &#123;
            return nums[0] == target ? 0 : -1;
        &#125;
        int l = 0, r = n - 1;
        while (l &lt;= r) &#123;
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] &lt;= nums[mid]) &#123;
                if (nums[0] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;
                    r = mid - 1;
                &#125; else &#123;
                    l = mid + 1;
                &#125;
            &#125; else &#123;
                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) &#123;
                    l = mid + 1;
                &#125; else &#123;
                    r = mid - 1;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWFycmF5Lw==">34. 在排序数组中查找元素的第一个和最后一个位置</span></h1><h2 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [], target = 0
输出：[-1,-1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><p>考虑 target开始和结束位置，其实我们要找的就是数组中「第一个等于 target的位置」（记为 leftIdx）和「第一个大于 target 的位置减一」（记为 rightIdx），这里注意二分法找左边界的微调写法，忘记了去算法小抄那复习</p>
<h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123; 
public:
    int binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower) &#123;
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left &lt;= right) &#123;
            int mid = (left + right) / 2;
            if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;
                right = mid - 1;
                ans = mid;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return ans;
    &#125;

    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;
            return vector&lt;int&gt;&#123;leftIdx, rightIdx&#125;;
        &#125; 
        return vector&lt;int&gt;&#123;-1, -1&#125;;
    &#125;
&#125;;

</code></pre>
<h1 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1zdWRva3Uv">36. 有效的数独</span></h1><h2 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h2><p>请你判断一个 <code>9 x 9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 <code>&#39;.&#39;</code> 表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p>
<pre><code>输入：board = 
[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]
,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]
,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]
,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]
,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：board = 
[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]
,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]
,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]
,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]
,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]
,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>board.length == 9</code></li>
<li><code>board[i].length == 9</code></li>
<li><code>board[i][j]</code> 是一位数字（<code>1-9</code>）或者 <code>&#39;.&#39;</code></li>
</ul>
<h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><p>这道题没说数独一定有解（不是回溯），直接二维遍历判断每行每列每九宫格是否1-9数字不超过1即可</p>
<h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        int rows[9][9];
        int columns[9][9];
        int subboxes[3][3][9];
        
        memset(rows,0,sizeof(rows));
        memset(columns,0,sizeof(columns));
        memset(subboxes,0,sizeof(subboxes));
        for (int i = 0; i &lt; 9; i++) &#123;
            for (int j = 0; j &lt; 9; j++) &#123;
                char c = board[i][j];
                if (c != &#39;.&#39;) &#123;
                    int index = c - &#39;0&#39; - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || subboxes[i / 3][j / 3][index] &gt; 1) &#123;
                        return false;
                    &#125;
                &#125;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>
<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1hbmQtc2F5Lw==">38. 外观数列</span></h1><h2 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h2><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li><code>countAndSay(1) = &quot;1&quot;</code></li>
<li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>
</ul>
<p>前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;
</code></pre>
<p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<p>例如，数字字符串 <code>&quot;3322251&quot;</code> 的描述如下图：</p>
<p><img data-src="https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 1
输出：&quot;1&quot;
解释：这是一个基本样例。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 4
输出：&quot;1211&quot;
解释：
countAndSay(1) = &quot;1&quot;
countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot;
countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot;
countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 30</code></li>
</ul>
<h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><p>模拟遍历生成即可</p>
<h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string countAndSay(int n) &#123;
        string prev = &quot;1&quot;;
        for (int i = 2; i &lt;= n; ++i) &#123;
            string curr = &quot;&quot;;
            int start = 0;
            int pos = 0;

            while (pos &lt; prev.size()) &#123;
                while (pos &lt; prev.size() &amp;&amp; prev[pos] == prev[start]) &#123;
                    pos++;
                &#125;
                curr += to_string(pos - start) + prev[start];
                start = pos;
            &#125;
            prev = curr;
        &#125;
        
        return prev;
    &#125;
&#125;;

</code></pre>
<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. 组合总和</span></h1><h2 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入: candidates = [2], target = 1
输出: []
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><p>dfs回溯不断添加新数字，如果当前总和等于目标target则保存解，超过立即返回。注意到【2，2，3】和【3，2，2】在本题中等价的，因此dfs的时候按照数字的大小顺序进行dfs</p>
<h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;
        if (idx == candidates.size()) &#123;
            return;
        &#125;
        if (target == 0) &#123;
            ans.emplace_back(combine);
            return;
        &#125;
        // 直接跳过
        dfs(candidates, target, ans, combine, idx + 1);
        // 选择当前数
        if (target - candidates[idx] &gt;= 0) &#123;
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        &#125;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;
    &#125;
&#125;;

</code></pre>
<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWkv">40. 组合总和 II</span></h1><h2 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 100</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 50</code></li>
<li><code>1 &lt;= target &lt;= 30</code></li>
</ul>
<h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><p>类似<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. 组合总和</span>，dfs回溯不断添加新数字，如果当前总和等于目标target则保存解。区别在于，一是先把candidate数组排序，dfs改写为跳过时跳过所有等于下一个数的数，选择当前数时idx也要加一，要注意当idx等于candidate.size()的边界条件和上一题不一样</p>
<h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;
        if (idx == candidates.size()&amp;&amp;target==0) &#123;
            ans.emplace_back(combine);
            return;
        &#125;
        if (idx == candidates.size()) &#123;
            return;
        &#125;

        if (target == 0) &#123;
            ans.emplace_back(combine);
            return;
        &#125;


        // 直接跳过
        int nextidx = idx;
        while(nextidx&lt;candidates.size()&amp;&amp;candidates[nextidx]==candidates[idx])&#123;
            nextidx++;
        &#125;
        dfs(candidates, target, ans, combine, nextidx);
        // 选择当前数
        if (target - candidates[idx] &gt;= 0) &#123;
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx+1);
            combine.pop_back();
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        sort(candidates.begin(),candidates.end());
        vector&lt;vector&lt;int&gt;&gt; answer;
        vector&lt;int&gt; combine;
        dfs(candidates,target,answer,combine,0);
        return answer;

    &#125;
&#125;;
</code></pre>
<h1 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tdWx0aXBseS1zdHJpbmdzLw==">43. 字符串相乘</span></h1><h2 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h2><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;
输出: &quot;6&quot;
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;
输出: &quot;56088&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>
<li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li>
<li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li>
</ul>
<h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><p>换成字符串相加去做，例如123*456 &#x3D; 123*400+123*50+123*6</p>
<h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string multiply(string num1, string num2) &#123;
        if (num1 == &quot;0&quot; || num2 == &quot;0&quot;) &#123;
            return &quot;0&quot;;
        &#125;
        string ans = &quot;0&quot;;
        int m = num1.size(), n = num2.size();
        for (int i = n - 1; i &gt;= 0; i--) &#123;
            string curr;
            int add = 0;
            for (int j = n - 1; j &gt; i; j--) &#123;
                curr.push_back(0);
            &#125;
            int y = num2.at(i) - &#39;0&#39;;
            for (int j = m - 1; j &gt;= 0; j--) &#123;
                int x = num1.at(j) - &#39;0&#39;;
                int product = x * y + add;
                curr.push_back(product % 10);
                add = product / 10;
            &#125;
            while (add != 0) &#123;
                curr.push_back(add % 10);
                add /= 10;
            &#125;
            
            reverse(curr.begin(), curr.end());
            for (auto &amp;c : curr) &#123;
                c += &#39;0&#39;;
            &#125;

            ans = addStrings(ans, curr);
        &#125;
        return ans;
    &#125;

    string addStrings(string &amp;num1, string &amp;num2) &#123;
        int i = num1.size() - 1, j = num2.size() - 1, add = 0;
        string ans;
        while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;
            int x = i &gt;= 0 ? num1.at(i) - &#39;0&#39; : 0;
            int y = j &gt;= 0 ? num2.at(j) - &#39;0&#39; : 0;
            int result = x + y + add;
            ans.push_back(result % 10);
            add = result / 10;
            i--;
            j--;
        &#125;
        reverse(ans.begin(), ans.end());
        for (auto &amp;c: ans) &#123;
            c += &#39;0&#39;;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUtaWkv">45. 跳跃游戏 II</span></h1><h2 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: nums = [2,3,0,1,4]
输出: 2
</code></pre>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>nums[n-1]</code></li>
</ul>
<h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><p>「贪心」地进行正向查找，每次找到可到达的最远位置,例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1,从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int maxPos = 0, n = nums.size(), end = 0, step = 0;
        for (int i = 0; i &lt; n - 1; ++i) &#123;
            if (maxPos &gt;= i) &#123;
                maxPos = max(maxPos, i + nums[i]);
                if (i == end) &#123;
                    end = maxPos;
                    ++step;
                &#125;
            &#125;
        &#125;
        return step;
    &#125;
&#125;;
</code></pre>
<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">46. 全排列</span></h1><h2 id="题干-25"><a href="#题干-25" class="headerlink" title="题干"></a>题干</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,1]
输出：[[0,1],[1,0]]
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [1]
输出：[[1]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><p>回溯法，每个位置i每次分别和位置i到len-1进行交换，dfs下一个位置，返回时再swap恢复（另一种方法是使用<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LXBlcm11dGF0aW9uLw==">31. 下一个排列</span>去做）</p>
<h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;
        // 所有数都填完了
        if (first == len) &#123;
            res.emplace_back(output);
            return;
        &#125;
        for (int i = first; i &lt; len; ++i) &#123;
            // 动态维护数组
            swap(output[i], output[first]);
            // 继续递归填下一个数
            backtrack(res, output, first + 1, len);
            // 撤销操作
            swap(output[i], output[first]);
        &#125;
    &#125;
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt; &gt; res;
        backtrack(res, nums, 0, (int)nums.size());
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMtaWkv">47. 全排列 II</span></h1><h2 id="题干-26"><a href="#题干-26" class="headerlink" title="题干"></a>题干</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><p>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbnMv">46. 全排列</span>思路一样，区别在于每次for循环dfs下一层时用set记录是否重复，如果重复则跳过</p>
<h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; answer;
        int n = nums.size();

        function&lt;void(int)&gt; dfs = [&amp;](int i)&#123;
            if(i==n-1)&#123;
                answer.emplace_back(nums);
            &#125;
            unordered_set&lt;int&gt; st;
            for(int k=i;k&lt;n;k++)&#123;
                //如果这一轮交换重复则跳过
                if(st.count(nums[k]))&#123;
                    continue;
                &#125;
                st.insert(nums[k]);
                swap(nums[i],nums[k]);
                dfs(i+1);
                swap(nums[i],nums[k]);
            &#125;
        &#125;;
        dfs(0);
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">48. 旋转图像</span></h1><h2 id="题干-27"><a href="#题干-27" class="headerlink" title="题干"></a>题干</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU="> 原地</span>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p>
<pre><code>输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>做题不需要数学证明，通过观察例子将旋转改为等价的翻转，例如本题旋转90度等价于水平翻转加上主对角线（右上-左下）翻转</p>
<h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i &lt; n / 2; ++i) &#123;
            for (int j = 0; j &lt; n; ++j) &#123;
                swap(matrix[i][j], matrix[n - i - 1][j]);
            &#125;
        &#125;
        // 主对角线翻转
        for (int i = 0; i &lt; n; ++i) &#123;
            for (int j = 0; j &lt; i; ++j) &#123;
                swap(matrix[i][j], matrix[j][i]);
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy8=">49. 字母异位词分组</span></h1><h2 id="题干-28"><a href="#题干-28" class="headerlink" title="题干"></a>题干</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: strs = [&quot;&quot;]
输出: [[&quot;&quot;]]
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: strs = [&quot;a&quot;]
输出: [[&quot;a&quot;]]
</code></pre>
<h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><p>用哈希表存相同key的字符串，这里的key字符串一是可以设置为排序后的字符串（唯一），例如”nat”,”tan”的key是“nat”，二是可以计数作为key比如“1a1n1t”</p>
<h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;
        for (string&amp; str: strs) &#123;
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        &#125;
        vector&lt;vector&lt;string&gt;&gt; ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) &#123;
            ans.emplace_back(it-&gt;second);
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb3d4LW4v">50. Pow(x, n)</span></h1><h2 id="题干-29"><a href="#题干-29" class="headerlink" title="题干"></a>题干</h2><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，<code>xn</code> ）。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：x = 2.00000, n = 10
输出：1024.00000
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：x = 2.10000, n = 3
输出：9.26100
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>n</code> 是一个整数</li>
<li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><p>快速幂算法，用递归分治做，比如5^10化作5^5*5^5，这边就注意指数的奇偶性分别处理即可（奇数需要额外乘以一个底数x）</p>
<h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    double quickMul(double x, long long N) &#123;
        if (N == 0) &#123;
            return 1.0;
        &#125;
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    &#125;

    double myPow(double x, int n) &#123;
        long long N = n;
        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    &#125;
&#125;;

</code></pre>
<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN1YmFycmF5Lw==">53. 最大子数组和</span></h1><h2 id="题干-30"><a href="#题干-30" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong></p>
<p>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1]
输出：1
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [5,4,-1,7,8]
输出：23
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><p>一维动态规划，dp[i]表示以nums[i]为结尾的最长子数组和，转移方程为dp[i]&#x3D;max(nums[i],dp[i-1]+nums[i])</p>
<h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int pre = 0, maxAns = nums[0];
        for (const auto &amp;x: nums) &#123;
            pre = max(pre + x, x);
            maxAns = max(maxAns, pre);
        &#125;
        return maxAns;
    &#125;
&#125;;
</code></pre>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4Lw==">54. 螺旋矩阵</span></h1><h2 id="题干-31"><a href="#题干-31" class="headerlink" title="题干"></a>题干</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><p>模拟，设置四个方向，每次撞墙&#x2F;遇到已经标记过的数就顺时针换方向</p>
<h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;pair&lt;int,int&gt;&gt; eswn=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        vector&lt;vector&lt;int&gt;&gt; mask(matrix.size(),vector&lt;int&gt;(matrix[0].size(),0));
        vector&lt;int&gt; answer;
        int xsize = matrix.size();
        int ysize = matrix[0].size();
        int x=0;
        int y=0;
        int direct = 0;

        while(true)&#123;
            answer.emplace_back(matrix[x][y]);
            mask[x][y]=1;
            if(0&lt;=x+eswn[direct].first&amp;&amp;x+eswn[direct].first&lt;xsize&amp;&amp;0&lt;=y+eswn[direct].second&amp;&amp;y+eswn[direct].second&lt;ysize&amp;&amp;mask[x+eswn[direct].first][y+eswn[direct].second]==0)&#123;
                x = x+eswn[direct].first;
                y = y+eswn[direct].second;
            &#125;else&#123;
                direct = (direct+1)%4;
                if(0&lt;=x+eswn[direct].first&amp;&amp;x+eswn[direct].first&lt;xsize&amp;&amp;0&lt;=y+eswn[direct].second&amp;&amp;y+eswn[direct].second&lt;ysize&amp;&amp;mask[x+eswn[direct].first][y+eswn[direct].second]==0)&#123;
                    x = x+eswn[direct].first;
                    y = y+eswn[direct].second;
                &#125;else&#123;
                    break;
                &#125;

            &#125;
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9qdW1wLWdhbWUv">55. 跳跃游戏</span></h1><h2 id="题干-32"><a href="#题干-32" class="headerlink" title="题干"></a>题干</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><p>贪心，每次跳到当前能够达到的最大数字的位置</p>
<h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        int rightmost = 0;
        for (int i = 0; i &lt; n; ++i) &#123;
            if (i &lt;= rightmost) &#123;
                rightmost = max(rightmost, i + nums[i]);
                if (rightmost &gt;= n - 1) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;

</code></pre>
<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">56. 合并区间</span></h1><h2 id="题干-33"><a href="#题干-33" class="headerlink" title="题干"></a>题干</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><p>排序后依次合并，比较答案vector的最后一个pair.second是否大于等于当前pair的first，如果是则更新其second，否则emplaceback新的pair</p>
<h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        if (intervals.size() == 0) &#123;
            return &#123;&#125;;
        &#125;
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for (int i = 0; i &lt; intervals.size(); ++i) &#123;
            int L = intervals[i][0], R = intervals[i][1];
            if (!merged.size() || merged.back()[1] &lt; L) &#123;
                merged.push_back(&#123;L, R&#125;);
            &#125;
            else &#123;
                merged.back()[1] = max(merged.back()[1], R);
            &#125;
        &#125;
        return merged;
    &#125;
&#125;;

</code></pre>
<h1 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtaW50ZXJ2YWwv">57. 插入区间</span></h1><h2 id="题干-34"><a href="#题干-34" class="headerlink" title="题干"></a>题干</h2><p>给你一个 <strong>无重叠的</strong> <em>，</em>按照区间起始端点排序的区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 按照 <code>starti</code> 升序排列。同样给定一个区间 <code>newInterval = [start, end]</code> 表示另一个区间的开始和结束。</p>
<p>在 <code>intervals</code> 中插入区间 <code>newInterval</code>，使得 <code>intervals</code> 依然按照 <code>starti</code> 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p>
<p>返回插入之后的 <code>intervals</code>。</p>
<p><strong>注意</strong> 你不需要原地修改 <code>intervals</code>。你可以创建一个新数组然后返回它。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 105</code></li>
<li><code>intervals</code> 根据 <code>starti</code> 按 <strong>升序</strong> 排列</li>
<li><code>newInterval.length == 2</code></li>
<li><code>0 &lt;= start &lt;= end &lt;= 105</code></li>
</ul>
<h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><p>先遍历一遍找到新pair插入的位置，随后执行区间合并的代码<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">56. 合并区间</span></p>
<h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; merge(vector&lt;int&gt;&amp; a,vector&lt;int&gt;&amp; b)&#123;
        return &#123;min(a[0],b[0]),max(a[1],b[1])&#125;;
    &#125;


    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;
        vector&lt;vector&lt;int&gt;&gt; answer;
        int i = 0;
        for(i=0;i&lt;intervals.size();i++)&#123;
            if(newInterval[0]&lt;intervals[i][0])&#123;
                break;
            &#125;
        &#125;

        intervals.emplace(intervals.begin()+i,newInterval);

        for(int i=0;i&lt;intervals.size();)&#123;

            if(i==intervals.size()-1||(i&lt;intervals.size()-1&amp;&amp;intervals[i][1]&lt;intervals[i+1][0]))&#123;
                answer.emplace_back(intervals[i]);
                i++;
            &#125;else&#123;
                vector&lt;int&gt; temp = intervals[i];
                while(i&lt;intervals.size()-1&amp;&amp;temp[1]&gt;=intervals[i+1][0])&#123;
                    temp = merge(temp,intervals[i+1]);
                    i++;
                &#125;
                answer.emplace_back(temp);
                i++;
            &#125;
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4LWlpLw==">59. 螺旋矩阵 II</span></h1><h2 id="题干-35"><a href="#题干-35" class="headerlink" title="题干"></a>题干</h2><h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><p>模拟题，设置四个方向，每次撞墙&#x2F;遇到已经标记过的数就顺时针换方向</p>
<h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;
        int maxNum = n * n;
        int curNum = 1;
        vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n));
        int row = 0, column = 0;
        vector&lt;vector&lt;int&gt;&gt; directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;  // 右下左上
        int directionIndex = 0;
        while (curNum &lt;= maxNum) &#123;
            matrix[row][column] = curNum;
            curNum++;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow &lt; 0 || nextRow &gt;= n || nextColumn &lt; 0 || nextColumn &gt;= n || matrix[nextRow][nextColumn] != 0) &#123;
                directionIndex = (directionIndex + 1) % 4;  // 顺时针旋转至下一个方向
            &#125;
            row = row + directions[directionIndex][0];
            column = column + directions[directionIndex][1];
        &#125;
        return matrix;
    &#125;
&#125;;

</code></pre>
<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtbGlzdC8=">61. 旋转链表</span></h1><h2 id="题干-36"><a href="#题干-36" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img"></p>
<pre><code>输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img"></p>
<pre><code>输入：head = [0,1,2], k = 4
输出：[2,0,1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 2 * 109</code></li>
</ul>
<h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2><p>先求得链表长度，再找到分断点，维护新头指针为分断点-&gt;next，将后半段最后一个节点的指针指向原头结点，这里有个坑是旋转次数可能大于链表长度，因此需要事先取模</p>
<h2 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* rotateRight(ListNode* head, int k) &#123;
        if(!head)&#123;
            return head;
        &#125;
        int length = 0;
        ListNode* temp = head;
        while(temp)&#123;
            length++;
            temp=temp-&gt;next;
        &#125;

        temp = head;
        int newstart = length-k%length;
        if(newstart==length)&#123;
            return head;
        &#125;

        ListNode* newhead;

        for(int i=0;i&lt;newstart-1;i++)&#123;
            temp = temp-&gt;next;
        &#125;

        newhead = temp-&gt;next;
        temp-&gt;next = nullptr;

        temp = newhead;

        while(temp-&gt;next)&#123;
            temp = temp-&gt;next;
        &#125;

        temp-&gt;next = head;
        return newhead;


    &#125;
&#125;;
</code></pre>
<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">62. 不同路径</span></h1><h2 id="题干-37"><a href="#题干-37" class="headerlink" title="题干"></a>题干</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<pre><code>输入：m = 3, n = 7
输出：28
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向下
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：m = 7, n = 3
输出：28
</code></pre>
<p><strong>示例 4：</strong></p>
<pre><code>输入：m = 3, n = 3
输出：6
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<h2 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h2><p>二维动态规划，先把边界dp[0][?]和dp[?][0]求好,剩余的用dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]去转移</p>
<h2 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int uniquePaths(int m, int n) &#123;
        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n));
        for (int i = 0; i &lt; m; ++i) &#123;
            f[i][0] = 1;
        &#125;
        for (int j = 0; j &lt; n; ++j) &#123;
            f[0][j] = 1;
        &#125;
        for (int i = 1; i &lt; m; ++i) &#123;
            for (int j = 1; j &lt; n; ++j) &#123;
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            &#125;
        &#125;
        return f[m - 1][n - 1];
    &#125;
&#125;;
</code></pre>
<h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMtaWkv">63. 不同路径 II</span></h1><h2 id="题干-38"><a href="#题干-38" class="headerlink" title="题干"></a>题干</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
<pre><code>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p>
<pre><code>输入：obstacleGrid = [[0,1],[0,0]]
输出：1
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == obstacleGrid.length</code></li>
<li><code>n == obstacleGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<h2 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h2><p>二维动态规划，先把边界dp[0][?]和dp[?][0]求好,剩余的用dp[i][j] &#x3D; dp[i][j-1]+dp[i-1][j]去转移，注意障碍物可能在（0，0）位置需要特判，转移方程为dp[i][j] &#x3D; obstacleGrid[i][j]&#x3D;&#x3D;0?dp[i-1][j]+dp[i][j-1]:0;</p>
<h2 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(m&lt;=1&amp;&amp;n&lt;=1)&#123;
            if(obstacleGrid[0][0]==0)&#123;
                return 1;
            &#125;
            return 0;
        &#125;
        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));
        dp[0][0] = obstacleGrid[0][0]==0?1:0;

        for(int i=1;i&lt;n;i++)&#123;
            dp[0][i] = obstacleGrid[0][i]==0?dp[0][i-1]:0;
        &#125;
   
        for(int j=1;j&lt;m;j++)&#123;
            dp[j][0] = obstacleGrid[j][0]==0?dp[j-1][0]:0;
        &#125;

        for(int i=1;i&lt;m;i++)&#123;
            for(int j=1;j&lt;n;j++)&#123;
                dp[i][j] = obstacleGrid[i][j]==0?dp[i-1][j]+dp[i][j-1]:0;
            &#125;
        &#125;
        return dp[m-1][n-1];

    &#125;
&#125;;
</code></pre>
<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLw==">64. 最小路径和</span></h1><h2 id="题干-39"><a href="#题干-39" class="headerlink" title="题干"></a>题干</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p>
<pre><code>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：grid = [[1,2,3],[4,5,6]]
输出：12
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>
</ul>
<h2 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h2><p>二维动态规划，边界提前求好后，转移方程为dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</p>
<h2 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        if (grid.size() == 0 || grid[0].size() == 0) &#123;
            return 0;
        &#125;
        int rows = grid.size(), columns = grid[0].size();
        auto dp = vector &lt; vector &lt;int&gt; &gt; (rows, vector &lt;int&gt; (columns));
        dp[0][0] = grid[0][0];
        for (int i = 1; i &lt; rows; i++) &#123;
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        &#125;
        for (int j = 1; j &lt; columns; j++) &#123;
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        &#125;
        for (int i = 1; i &lt; rows; i++) &#123;
            for (int j = 1; j &lt; columns; j++) &#123;
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            &#125;
        &#125;
        return dp[rows - 1][columns - 1];
    &#125;
&#125;;

</code></pre>
<h1 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW1wbGlmeS1wYXRoLw==">71. 简化路径</span></h1><h2 id="题干-40"><a href="#题干-40" class="headerlink" title="题干"></a>题干</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW1wbGlmeS1wYXRoLw==">71. 简化路径</span></p>
<p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称。</p>
<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li>
<li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li>
<li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li>
</ul>
<p>返回简化后得到的 <strong>规范路径</strong> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：path = &quot;/home/&quot;
输出：&quot;/home&quot;
解释：注意，最后一个目录名后面没有斜杠。 
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：path = &quot;/../&quot;
输出：&quot;/&quot;
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：path = &quot;/home//foo/&quot;
输出：&quot;/home/foo&quot;
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
</code></pre>
<p><strong>示例 4：</strong></p>
<pre><code>输入：path = &quot;/a/./b/../../c/&quot;
输出：&quot;/c&quot;
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= path.length &lt;= 3000</code></li>
<li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li>
<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>
</ul>
<h2 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h2><p>用栈处理字符串，写一个split函数以’&#x2F;‘分割，对于空字符串和’.’则忽略，遇到’..’则尝试pop，否则push，最后将栈内的字符串组装即可</p>
<h2 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    string simplifyPath(string path) &#123;
        auto split = [](const string&amp; s, char delim) -&gt; vector&lt;string&gt; &#123;
            vector&lt;string&gt; ans;
            string cur;
            for (char ch: s) &#123;
                if (ch == delim) &#123;
                    ans.push_back(move(cur));
                    cur.clear();
                &#125;
                else &#123;
                    cur += ch;
                &#125;
            &#125;
            ans.push_back(move(cur));
            return ans;
        &#125;;

        vector&lt;string&gt; names = split(path, &#39;/&#39;);
        vector&lt;string&gt; stack;
        for (string&amp; name: names) &#123;
            if (name == &quot;..&quot;) &#123;
                if (!stack.empty()) &#123;
                    stack.pop_back();
                &#125;
            &#125;
            else if (!name.empty() &amp;&amp; name != &quot;.&quot;) &#123;
                stack.push_back(move(name));
            &#125;
        &#125;
        string ans;
        if (stack.empty()) &#123;
            ans = &quot;/&quot;;
        &#125;
        else &#123;
            for (string&amp; name: stack) &#123;
                ans += &quot;/&quot; + move(name);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lZGl0LWRpc3RhbmNlLw==">72. 编辑距离</span></h1><h2 id="题干-41"><a href="#题干-41" class="headerlink" title="题干"></a>题干</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出：5
解释：
intention -&gt; inention (删除 &#39;t&#39;)
inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)
enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)
exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)
exection -&gt; execution (插入 &#39;u&#39;)
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h2><p>动态规划，dp[i][j]表示word1[:i]与word2[:j]的编辑距离，第一行和第一列处理好后，其余转移公式如下                if(word1[i-1]&#x3D;&#x3D;word2[j-1]){dp[i][j] &#x3D; dp[i-1][j-1];}else{dp[i][j] &#x3D; min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;}，这里注意一下dp的下标和word的下标有长度为1的偏移</p>
<h2 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int minDistance(string word1, string word2) &#123;
        vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1,vector&lt;int&gt;(word2.size()+1));
        dp[0][0] = 0;
        for(int i=1;i&lt;=word1.size();i++)&#123;
            dp[i][0] = dp[i-1][0]+1;
        &#125;
        for(int j=1;j&lt;=word2.size();j++)&#123;
            dp[0][j] = dp[0][j-1]+1;
        &#125;

        for(int i=1;i&lt;=word1.size();i++)&#123;
            for(int j=1;j&lt;=word2.size();j++)&#123;
                if(word1[i-1]==word2[j-1])&#123;
                    dp[i][j] = dp[i-1][j-1];
                &#125;else&#123;
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
                &#125;
            &#125;
        &#125;

        return dp[word1.size()][word2.size()];


    &#125;
&#125;;
</code></pre>
<h1 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZXQtbWF0cml4LXplcm9lcy8=">73. 矩阵置零</span></h1><h2 id="题干-42"><a href="#题干-42" class="headerlink" title="题干"></a>题干</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9pdGVtLyVFNSU4RSU5RiVFNSU5QyVCMCVFNyVBRSU5NyVFNiVCMyU5NQ==">原地</span></strong> 算法<strong>。</strong></p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p>
<pre><code>输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<h2 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h2><p>用矩阵的第一行和第一列记录该列和行是否为0，再额外加两个变量记录第一行和第一列是否需要记为0</p>
<h2 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int m = matrix.size();
        int n = matrix[0].size();
        int flag_col0 = false, flag_row0 = false;
        for (int i = 0; i &lt; m; i++) &#123;
            if (!matrix[i][0]) &#123;
                flag_col0 = true;
            &#125;
        &#125;
        for (int j = 0; j &lt; n; j++) &#123;
            if (!matrix[0][j]) &#123;
                flag_row0 = true;
            &#125;
        &#125;
        for (int i = 1; i &lt; m; i++) &#123;
            for (int j = 1; j &lt; n; j++) &#123;
                if (!matrix[i][j]) &#123;
                    matrix[i][0] = matrix[0][j] = 0;
                &#125;
            &#125;
        &#125;
        for (int i = 1; i &lt; m; i++) &#123;
            for (int j = 1; j &lt; n; j++) &#123;
                if (!matrix[i][0] || !matrix[0][j]) &#123;
                    matrix[i][j] = 0;
                &#125;
            &#125;
        &#125;
        if (flag_col0) &#123;
            for (int i = 0; i &lt; m; i++) &#123;
                matrix[i][0] = 0;
            &#125;
        &#125;
        if (flag_row0) &#123;
            for (int j = 0; j &lt; n; j++) &#123;
                matrix[0][j] = 0;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtYS0yZC1tYXRyaXgv">74. 搜索二维矩阵</span></h1><h2 id="题干-43"><a href="#题干-43" class="headerlink" title="题干"></a>题干</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p>
<pre><code>输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li>
</ul>
<h2 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h2><p>两次二分，分别在纵轴二分找到第一个比目标大的行，取其前一行，再在该行中二分查找，注意复习满足条件的最右满足项和最左满足项的不同写法</p>
<h2 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int binary1(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)&#123;
        int left = 0;
        int right = matrix.size()-1;
        int answer = -1;
        while(left&lt;=right)&#123;
            int mid = left+(right-left)/2;
            if(matrix[mid][0]&gt;target)&#123;
                right = mid-1;
            &#125;else&#123;
                answer = max(answer,mid);
                left = mid+1;
            &#125;
        &#125;
        return answer;
    &#125;


    bool binary2(vector&lt;int&gt; &amp;row,int target)&#123;
        int left = 0;
        int right = row.size();
        bool answer = false;
        while(left&lt;right)&#123;
            int mid = left+(right-left)/2;
            if(row[mid]==target)&#123;
                answer = true;
                break;
            &#125;else if(row[mid]&lt;target)&#123;
                left = mid+1;
            &#125;else&#123;
                right = mid;
            &#125;
        &#125;
        return answer;
    &#125;


    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
        int r = binary1(matrix, target);
        if(r==-1)&#123;
            return false;
        &#125;
        return binary2(matrix[r],target);

    &#125;
&#125;;
</code></pre>
<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWNvbG9ycy8=">75. 颜色分类</span></h1><h2 id="题干-44"><a href="#题干-44" class="headerlink" title="题干"></a>题干</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU=">原地</span>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [2,0,1]
输出：[0,1,2]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<h2 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h2><p>对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。在第二次遍历中，我们将数组中所有的 1交换到头部的 0之后。此时，所有的 2 都出现在数组的尾部。</p>
<h2 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    void sortColors(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        int ptr = 0;
        for (int i = 0; i &lt; n; ++i) &#123;
            if (nums[i] == 0) &#123;
                swap(nums[i], nums[ptr]);
                ++ptr;
            &#125;
        &#125;
        for (int i = ptr; i &lt; n; ++i) &#123;
            if (nums[i] == 1) &#123;
                swap(nums[i], nums[ptr]);
                ++ptr;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbnMv">77. 组合</span></h1><h2 id="题干-45"><a href="#题干-45" class="headerlink" title="题干"></a>题干</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1, k = 1
输出：[[1]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h2 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h2><p>dfs回溯，每个位置有选和不选两种，注意如果当前位置后的数的个数已经不能满足需要取的数的个数时即可以剪枝</p>
<h2 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; temp;
    vector&lt;vector&lt;int&gt;&gt; ans;

    void dfs(int cur, int n, int k) &#123;
        // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        if (temp.size() + (n - cur + 1) &lt; k) &#123;
            return;
        &#125;
        // 记录合法的答案
        if (temp.size() == k) &#123;
            ans.push_back(temp);
            return;
        &#125;
        // 考虑选择当前位置
        temp.push_back(cur);
        dfs(cur + 1, n, k);
        temp.pop_back();
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        dfs(1, n, k);
        return ans;
    &#125;
&#125;;

</code></pre>
<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLw==">78. 子集</span></h1><h2 id="题干-46"><a href="#题干-46" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的</p>
<p>子集</p>
<p>（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0]
输出：[[],[0]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h2 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h2><p>dfs，每个位置有取和不取两种</p>
<h2 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; t;
    vector&lt;vector&lt;int&gt;&gt; ans;

    void dfs(int cur, vector&lt;int&gt; &amp;nums) &#123;
        if (cur == nums.size()) &#123;
            ans.push_back(t);
            return;
        &#125;
        t.push_back(nums[cur]);
        dfs(cur + 1, nums);
        t.pop_back();
        dfs(cur + 1, nums);
    &#125;

    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;nums) &#123;
        dfs(0, nums);
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy93b3JkLXNlYXJjaC8=">79. 单词搜索</span></h1><h2 id="题干-47"><a href="#题干-47" class="headerlink" title="题干"></a>题干</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p>
<pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p>
<pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;
输出：true
</code></pre>
<p><strong>示例 3：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p>
<pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;
输出：false
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n = board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 6</code></li>
<li><code>1 &lt;= word.length &lt;= 15</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>
<h2 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h2><p>深度优先搜索： 即暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到“这条路不可能和目标字符串匹配成功”的情况，例如当前矩阵元素和目标字符不匹配、或此元素已被访问，则应立即返回，从而避免不必要的搜索分支。</p>
<h2 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        rows = board.size();
        cols = board[0].size();
        for(int i = 0; i &lt; rows; i++) &#123;
            for(int j = 0; j &lt; cols; j++) &#123;
                if (dfs(board, word, i, j, 0)) return true;
            &#125;
        &#125;
        return false;
    &#125;
private:
    int rows, cols;
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k) &#123;
        if (i &gt;= rows || i &lt; 0 || j &gt;= cols || j &lt; 0 || board[i][j] != word[k]) return false;
        if (k == word.size() - 1) return true;
        board[i][j] = &#39;\0&#39;;
        bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    &#125;
&#125;;
</code></pre>
<h1 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS1paS8=">80. 删除有序数组中的重复项 II</span></h1><h2 id="题干-48"><a href="#题干-48" class="headerlink" title="题干"></a>题干</h2><p>给你一个有序数组 <code>nums</code> ，请你**<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9pdGVtLyVFNSU4RSU5RiVFNSU5QyVCMCVFNyVBRSU5NyVFNiVCMyU5NQ=="> 原地</span>** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU=">原地 </span>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明：</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) &#123;
    print(nums[i]);
&#125;
</code></pre>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按升序排列</li>
</ul>
<h2 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h2><p>用快慢指针去遍历，慢指针slow表示最后答案数组中当前需要确定的位置，快指针fast表示原数组中遍历到的位置</p>
<h2 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        if (n &lt;= 2) &#123;
            return n;
        &#125;
        int slow = 2, fast = 2;
        while (fast &lt; n) &#123;

            if(nums[slow-2]!=nums[fast])&#123;
                nums[slow] = nums[fast];
                slow++;
            &#125;
            fast++;
        &#125;
        return slow;
    &#125;
&#125;;

</code></pre>
<h1 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tcm90YXRlZC1zb3J0ZWQtYXJyYXktaWkv">81. 搜索旋转排序数组 II</span></h1><h2 id="题干-49"><a href="#题干-49" class="headerlink" title="题干"></a>题干</h2><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>你必须尽可能减少整个操作步骤。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<h2 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h2><p>对于数组中有重复元素的情况，二分查找时可能会无法判断区间 [l,mid] 和区间[mid+1,r] 哪个是有序的。</p>
<p>例如 nums&#x3D;[3,1,2,3,3,3,3]，target&#x3D;2，首次二分时无法判断区间 [0,3] 和区间 [4,6] 哪个是有序的。</p>
<p>对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<h2 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool search(vector&lt;int&gt; &amp;nums, int target) &#123;
        int n = nums.size();
        if (n == 0) &#123;
            return false;
        &#125;
        if (n == 1) &#123;
            return nums[0] == target;
        &#125;
        int l = 0, r = n - 1;
        while (l &lt;= r) &#123;
            int mid = (l + r) / 2;
            if (nums[mid] == target) &#123;
                return true;
            &#125;
            if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;
                ++l;
                --r;
            &#125; else if (nums[l] &lt;= nums[mid]) &#123;
                if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;
                    r = mid - 1;
                &#125; else &#123;
                    l = mid + 1;
                &#125;
            &#125; else &#123;
                if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) &#123;
                    l = mid + 1;
                &#125; else &#123;
                    r = mid - 1;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;

</code></pre>
<h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1saXN0LWlpLw==">82. 删除排序链表中的重复元素 II</span></h1><h2 id="题干-50"><a href="#题干-50" class="headerlink" title="题干"></a>题干</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img"></p>
<pre><code>输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="img"></p>
<pre><code>输入：head = [1,1,1,2,3]
输出：[2,3]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<h2 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h2><p>双指针，遇到有重复的就记录下值，然后跳过所有为这个值的节点</p>
<h2 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        ListNode* dummy = new ListNode();
        dummy-&gt;next = head;
        ListNode* temp = dummy;
        while(temp-&gt;next&amp;&amp;temp-&gt;next-&gt;next)&#123;
            if(temp-&gt;next-&gt;val==temp-&gt;next-&gt;next-&gt;val)&#123;
                int val = temp-&gt;next-&gt;val;
                while(temp-&gt;next&amp;&amp;temp-&gt;next-&gt;val==val)&#123;
                    temp-&gt;next = temp-&gt;next-&gt;next;
                &#125;
            &#125;
            else&#123;
                temp = temp-&gt;next;
            &#125;
            

        &#125;
        return dummy-&gt;next;

    &#125;
&#125;;
</code></pre>
<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXJ0aXRpb24tbGlzdC8=">86. 分隔链表</span></h1><h2 id="题干-51"><a href="#题干-51" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="img"></p>
<pre><code>输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = [2,1], x = 2
输出：[1,2]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
<h2 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h2><p>多用几个指针，dummy1率领比x小的一条链，dummy2率领&gt;&#x3D;x的一条链，最后合并</p>
<h2 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* partition(ListNode* head, int x) &#123;
        ListNode* dummy1 = new ListNode();
        ListNode* a = dummy1;
        ListNode* dummy2 = new ListNode();
        ListNode* b = dummy2;
        ListNode* temp = head;
        while(temp)&#123;
            if(temp-&gt;val&lt;x)&#123;
                a-&gt;next = temp;
                temp = temp-&gt;next;
                a = a-&gt;next;
                a-&gt;next = nullptr;
            &#125;else&#123;
                b-&gt;next = temp;
                temp = temp-&gt;next;
                b = b-&gt;next;
                b-&gt;next = nullptr;
            &#125;
        &#125;
        ListNode* dummy = new ListNode();
        ListNode* help = dummy;

        if(dummy1-&gt;next)&#123;
            help-&gt;next = dummy1-&gt;next;
        &#125;

        while(help-&gt;next)&#123;
            help = help-&gt;next;
        &#125;

        if(dummy2-&gt;next)&#123;
            help-&gt;next = dummy2-&gt;next;
        &#125;

        return dummy-&gt;next;
    &#125;
&#125;;
</code></pre>
<h1 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmF5LWNvZGUv">89. 格雷编码</span></h1><h2 id="题干-52"><a href="#题干-52" class="headerlink" title="题干"></a>题干</h2><p><strong>n 位格雷码序列</strong> 是一个由 <code>2n</code> 个整数组成的序列，其中：</p>
<ul>
<li>每个整数都在范围 <code>[0, 2n - 1]</code> 内（含 <code>0</code> 和 <code>2n - 1</code>）</li>
<li>第一个整数是 <code>0</code></li>
<li>一个整数在序列中出现 <strong>不超过一次</strong></li>
<li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li>
<li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li>
</ul>
<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1
输出：[0,1]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 16</code></li>
</ul>
<h2 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h2><p>数学题背公式， 对于i&#x3D;0到n-1，ret[i] &#x3D; (i &gt;&gt; 1) ^ i;</p>
<h2 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; grayCode(int n) &#123;
        vector&lt;int&gt; ret(1 &lt;&lt; n);
        for (int i = 0; i &lt; ret.size(); i++) &#123;
            ret[i] = (i &gt;&gt; 1) ^ i;
        &#125;
        return ret;
    &#125;
&#125;;

</code></pre>
<h1 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJzZXRzLWlpLw==">90. 子集 II</span></h1><h2 id="题干-53"><a href="#题干-53" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 </p>
<p>子集</p>
<p>（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0]
输出：[[],[0]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h2 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h2><p>求子集就是求所有长度为1,2…n的不同集合，先排序，对于求长度为k的集合来说可以dfs回溯，到达长度或者到达边界作为返回条件，每个dfs有取当前位置数据和不取当前位置数据两个选项，这里注意由于有重复数据，因此如果跳过时需要跳过和当前相同的所有数据</p>
<h2 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; answer;
        answer.emplace_back(vector&lt;int&gt;());


        function&lt;void(int,int,vector&lt;int&gt;&amp;)&gt; dfs = [&amp;](int i,int num,vector&lt;int&gt; &amp;temp)&#123;
            if(num==0)&#123;
                answer.emplace_back(temp);
                return;
            &#125;
            if(i&gt;=nums.size())&#123;
                return;
            &#125;

            //不选
            int j=i+1;
            while(j&lt;nums.size()&amp;&amp;nums[j]==nums[i])&#123;
                j++;
            &#125;
            dfs(j,num,temp);

            //选
            temp.emplace_back(nums[i]);
            dfs(i+1,num-1,temp);
            temp.pop_back();
        &#125;;


        for(int num = 1;num&lt;=nums.size();num++)&#123;
            vector&lt;int&gt; temp;
            dfs(0,num,temp);
        &#125;
        return answer;
    &#125;
&#125;;
</code></pre>
<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtd2F5cy8=">91. 解码方法</span></h1><h2 id="题干-54"><a href="#题干-54" class="headerlink" title="题干"></a>题干</h2><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<pre><code>&#39;A&#39; -&gt; &quot;1&quot;
&#39;B&#39; -&gt; &quot;2&quot;
...
&#39;Z&#39; -&gt; &quot;26&quot;
</code></pre>
<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;12&quot;
输出：2
解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;226&quot;
输出：3
解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;06&quot;
输出：0
解释：&quot;06&quot; 无法映射到 &quot;F&quot; ，因为存在前导零（&quot;6&quot; 和 &quot;06&quot; 并不等价）。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<h2 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h2><p>一维动态规划，dp[i]表示到达i位置时的种类数量，其与dp[i-1]和dp[i-2]都有关，根据题意判断是否有关</p>
<h2 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int numDecodings(string s) &#123;
        int n = s.size();
        s = &quot; &quot; + s;
        vector&lt;int&gt; f(n + 1,0);
        f[0] = 1;        
        for(int i = 1; i &lt; n + 1; i++) &#123;
            int a = s[i] - &#39;0&#39;, b = (s[i - 1] - &#39;0&#39;) * 10 + s[i] - &#39;0&#39;;
            if(1 &lt;= a &amp;&amp; a &lt;= 9) f[i] = f[i - 1];
            if(10 &lt;= b &amp;&amp; b &lt;= 26) f[i] += f[i - 2];
        &#125;
        return f[n];
    &#125;
&#125;;
</code></pre>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0LWlpLw==">92. 反转链表 II</span></h1><h2 id="题干-55"><a href="#题干-55" class="headerlink" title="题干"></a>题干</h2><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p>
<pre><code>输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = [5], left = 1, right = 1
输出：[5]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 <code>n</code></li>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>-500 &lt;= Node.val &lt;= 500</code></li>
<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>
</ul>
<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>
<h2 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h2><p>先会写翻转头结点到尾结点，再原题中找到需要断开的两个指针，中间部分翻转后执行拼接操作</p>
<h2 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
private:
    void reverseLinkedList(ListNode *head) &#123;
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) &#123;
            ListNode *next = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = next;
        &#125;
    &#125;

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) &#123;
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode-&gt;next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        // 建议写在 for 循环里，语义清晰
        for (int i = 0; i &lt; left - 1; i++) &#123;
            pre = pre-&gt;next;
        &#125;

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i &lt; right - left + 1; i++) &#123;
            rightNode = rightNode-&gt;next;
        &#125;

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre-&gt;next;
        ListNode *curr = rightNode-&gt;next;

        // 注意：切断链接
        pre-&gt;next = nullptr;
        rightNode-&gt;next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre-&gt;next = rightNode;
        leftNode-&gt;next = curr;
        return dummyNode-&gt;next;
    &#125;
&#125;;
</code></pre>
<h1 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXN0b3JlLWlwLWFkZHJlc3Nlcy8=">93. 复原 IP 地址</span></h1><h2 id="题干-56"><a href="#题干-56" class="headerlink" title="题干"></a>题干</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<h2 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h2><p>dfs回溯，找到了合理的四段数字并且到达s结尾就找到了答案，注意当前数字为0时只能立即dfs下一个数字因为不能有前导0</p>
<h2 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
private:
    static constexpr int SEG_COUNT = 4;

private:
    vector&lt;string&gt; ans;
    vector&lt;int&gt; segments;

public:
    void dfs(const string&amp; s, int segId, int segStart) &#123;
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) &#123;
            if (segStart == s.size()) &#123;
                string ipAddr;
                for (int i = 0; i &lt; SEG_COUNT; ++i) &#123;
                    ipAddr += to_string(segments[i]);
                    if (i != SEG_COUNT - 1) &#123;
                        ipAddr += &quot;.&quot;;
                    &#125;
                &#125;
                ans.push_back(move(ipAddr));
            &#125;
            return;
        &#125;

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.size()) &#123;
            return;
        &#125;

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s[segStart] == &#39;0&#39;) &#123;
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
            return;
        &#125;

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd &lt; s.size(); ++segEnd) &#123;
            addr = addr * 10 + (s[segEnd] - &#39;0&#39;);
            if (addr &gt; 0 &amp;&amp; addr &lt;= 0xFF) &#123;
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            &#125; else &#123;
                break;
            &#125;
        &#125;
    &#125;

    vector&lt;string&gt; restoreIpAddresses(string s) &#123;
        segments.resize(SEG_COUNT);
        dfs(s, 0, 0);
        return ans;
    &#125;
&#125;;
</code></pre>
<h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy1paS8=">95. 不同的二叉搜索树 II</span></h1><h2 id="题干-57"><a href="#题干-57" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p>
<pre><code>输入：n = 3
输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1
输出：[[1]]
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<h2 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树的特性是中序遍历有序，root的左边都小于root，右边都大于 root，因此确认root后就可以递归生成左子树和右子树的dfs</p>
<h2 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123;
        if (start &gt; end) &#123;
            return &#123; nullptr &#125;;
        &#125;
        vector&lt;TreeNode*&gt; allTrees;
        // 枚举可行根节点
        for (int i = start; i &lt;= end; i++) &#123;
            // 获得所有可行的左子树集合
            vector&lt;TreeNode*&gt; leftTrees = generateTrees(start, i - 1);

            // 获得所有可行的右子树集合
            vector&lt;TreeNode*&gt; rightTrees = generateTrees(i + 1, end);

            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
            for (auto&amp; left : leftTrees) &#123;
                for (auto&amp; right : rightTrees) &#123;
                    TreeNode* currTree = new TreeNode(i);
                    currTree-&gt;left = left;
                    currTree-&gt;right = right;
                    allTrees.emplace_back(currTree);
                &#125;
            &#125;
        &#125;
        return allTrees;
    &#125;

    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;
        if (!n) &#123;
            return &#123;&#125;;
        &#125;
        return generateTrees(1, n);
    &#125;
&#125;;
</code></pre>
<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy8=">96. 不同的二叉搜索树</span></h1><h2 id="题干-58"><a href="#题干-58" class="headerlink" title="题干"></a>题干</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p>
<pre><code>输入：n = 3
输出：5
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：n = 1
输出：1
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<h2 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h2><p>本题乍一看和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtYmluYXJ5LXNlYXJjaC10cmVlcy1paS8=">95. 不同的二叉搜索树 II</span>一样做dfs，但是本题dfs会超时即使加了辅助cache，凡是dfs超时的题就要想到动态规划，G(n)为长度为 n的序列能构成的不同二叉搜索树的个数，对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，G(n)的值和左右子树长度有关和内容无关，因此对于一个G(n)来说枚举位置k&#x3D;1,2,…n去累计G(k-1)*G(n-k)即可，由此得到转移方程</p>
<h2 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    int numTrees(int n) &#123;
        vector&lt;int&gt; G(n + 1, 0);
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i &lt;= n; ++i) &#123;
            for (int j = 1; j &lt;= i; ++j) &#123;
                G[i] += G[j - 1] * G[i - j];
            &#125;
        &#125;
        return G[n];
    &#125;
&#125;;
</code></pre>
<h1 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcmxlYXZpbmctc3RyaW5nLw==">97. 交错字符串</span></h1><h2 id="题干-59"><a href="#题干-59" class="headerlink" title="题干"></a>题干</h2><p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> <strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> </p>
<p>子字符串</p>
<p>：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" alt="img"></p>
<pre><code>输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
输出：false
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;
输出：true
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>
<li><code>0 &lt;= s3.length &lt;= 200</code></li>
<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>
</ul>
<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>
<h2 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h2><p>定义 f(i,j)表示 s1的前 i 个元素和 s2的前 j个元素是否能交错组成 s3的前 i+j个元素，当i+j-1号元素和i-1相同时其值等于f(i−1,j)的结果，同理和j-1相同时其值等于f(i,j−1)</p>
<p>f(i,j)&#x3D;[f(i−1,j) and s1(i−1)&#x3D;s3(i+j-1)] or [f(i,j−1) and s2(j−1)&#x3D;s3(i+j-1)]</p>
<h2 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool isInterleave(string s1, string s2, string s3) &#123;
        auto f = vector &lt; vector &lt;int&gt; &gt; (s1.size() + 1, vector &lt;int&gt; (s2.size() + 1, false));

        int n = s1.size(), m = s2.size(), t = s3.size();

        if (n + m != t) &#123;
            return false;
        &#125;

        f[0][0] = true;
        for (int i = 0; i &lt;= n; ++i) &#123;
            for (int j = 0; j &lt;= m; ++j) &#123;
                int p = i + j - 1;
                if (i &gt; 0) &#123;
                    f[i][j] |= (f[i - 1][j] &amp;&amp; s1[i - 1] == s3[p]);
                &#125;
                if (j &gt; 0) &#123;
                    f[i][j] |= (f[i][j - 1] &amp;&amp; s2[j - 1] == s3[p]);
                &#125;
            &#125;
        &#125;

        return f[n][m];
    &#125;
&#125;;

</code></pre>
<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1iaW5hcnktc2VhcmNoLXRyZWUv">98. 验证二叉搜索树</span></h1><h2 id="题干-60"><a href="#题干-60" class="headerlink" title="题干"></a>题干</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li><p>节点的左</p>
<p>子树</p>
<p>只包含</p>
<p> 小于 </p>
<p>当前节点的数。</p>
</li>
<li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li><p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p>
<pre><code>输入：root = [2,1,3]
输出：true
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p>
<pre><code>输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h2 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h2><p>中序遍历是否有序即可</p>
<h2 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        stack&lt;TreeNode*&gt; stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) &#123;
            while (root != nullptr) &#123;
                stack.push(root);
                root = root -&gt; left;
            &#125;
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -&gt; val &lt;= inorder) &#123;
                return false;
            &#125;
            inorder = root -&gt; val;
            root = root -&gt; right;
        &#125;
        return true;
    &#125;
&#125;;
</code></pre>
<h1 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWNvdmVyLWJpbmFyeS1zZWFyY2gtdHJlZS8=">99. 恢复二叉搜索树</span></h1><h2 id="题干-61"><a href="#题干-61" class="headerlink" title="题干"></a>题干</h2><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p>
<pre><code>输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img data-src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img"></p>
<pre><code>输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong>使用 <code>O(n)</code> 空间复杂度的解法很容易实现。你能想出一个只使用 <code>O(1)</code> 空间的解决方案吗？</p>
<h2 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h2><p>中序遍历得到结果，由于只交换了一次，可以获得需要交换的两个数，例如[1,2,3,4,5,6,7]若变成[1,6,3,4,5,2,7]，找到第一个nums[k]&gt;nums[k+1]的k，再找到第二个nums[k]&gt;nums[k+1]的k+1即为两个要交换的数，再在前序遍历的过程中访问到这两个数时换成另外一个</p>
<h2 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h2><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums) &#123;
        if (root == nullptr) &#123;
            return;
        &#125;
        inorder(root-&gt;left, nums);
        nums.push_back(root-&gt;val);
        inorder(root-&gt;right, nums);
    &#125;

    pair&lt;int,int&gt; findTwoSwapped(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        int index1 = -1, index2 = -1;
        for (int i = 0; i &lt; n - 1; ++i) &#123;
            if (nums[i + 1] &lt; nums[i]) &#123;
                index2 = i + 1;
                if (index1 == -1) &#123;
                    index1 = i;
                &#125; else &#123;
                    break;
                &#125;
            &#125;
        &#125;
        int x = nums[index1], y = nums[index2];
        return &#123;x, y&#125;;
    &#125;
    
    void recover(TreeNode* r, int count, int x, int y) &#123;
        if (r != nullptr) &#123;
            if (r-&gt;val == x || r-&gt;val == y) &#123;
                r-&gt;val = r-&gt;val == x ? y : x;
                if (--count == 0) &#123;
                    return;
                &#125;
            &#125;
            recover(r-&gt;left, count, x, y);
            recover(r-&gt;right, count, x, y);
        &#125;
    &#125;

    void recoverTree(TreeNode* root) &#123;
        vector&lt;int&gt; nums;
        inorder(root, nums);
        pair&lt;int,int&gt; swapped= findTwoSwapped(nums);
        recover(root, 2, swapped.first, swapped.second);
    &#125;
&#125;;
</code></pre>

      <div class="tags">
          <a href="/tags/c/" rel="tag"><i class="ic i-tag"></i> c++</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2024-04-22 00:52:14" itemprop="dateModified" datetime="2024-04-22T00:52:14+08:00">2024-04-22</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>Kun Qian <i class="ic i-at"><em>@</em></i>Qkgoalkeeper's blog
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" title="Leetcode中等题思路（1-100）">https://qkgoalkeeper.github.io/computer-science/leetcode/algorithm/Leetcode中等题思路（1-100）/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/computer-science/interview/method/%E5%9B%BE%E8%B7%AF%E5%BE%84%E4%B8%93%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;qkgoalkeeper&#x2F;blogImage@main&#x2F;img&#x2F;leetcode.png" title="图路径专题">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 计算机科学</span>
  <h3>图路径专题</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;qkgoalkeeper&#x2F;blogImage@main&#x2F;img&#x2F;leetcode.png" title="Leetcode中等题思路（101-100）">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 算法题思路</span>
  <h3>Leetcode中等题思路（101-100）</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.</span> <span class="toc-text">2. 两数相加</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2"><span class="toc-number">1.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-1"><span class="toc-number">2.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">5. 最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-2"><span class="toc-number">3.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">6. Z 字形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-3"><span class="toc-number">4.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">4.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-number">5.</span> <span class="toc-text">7. 整数反转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-4"><span class="toc-number">5.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">5.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">5.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="toc-number">6.</span> <span class="toc-text">8. 字符串转换整数 (atoi)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-5"><span class="toc-number">6.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">6.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">6.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">11. 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-6"><span class="toc-number">7.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">7.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">7.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="toc-number">8.</span> <span class="toc-text">12. 整数转罗马数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-7"><span class="toc-number">8.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">8.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">8.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">15. 三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-8"><span class="toc-number">9.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">9.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">9.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">10.</span> <span class="toc-text">16. 最接近的三数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-9"><span class="toc-number">10.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">10.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">10.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-10"><span class="toc-number">11.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">11.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-number">11.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">12.</span> <span class="toc-text">18. 四数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-11"><span class="toc-number">12.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-number">12.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-number">12.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-12"><span class="toc-number">13.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-number">13.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-number">13.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">14.</span> <span class="toc-text">22. 括号生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-13"><span class="toc-number">14.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-number">14.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-number">14.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">15.</span> <span class="toc-text">24. 两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-14"><span class="toc-number">15.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-number">15.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-number">15.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">16.</span> <span class="toc-text">29. 两数相除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-15"><span class="toc-number">16.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-number">16.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-number">16.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">17.</span> <span class="toc-text">31. 下一个排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-16"><span class="toc-number">17.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-number">17.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-number">17.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">18.</span> <span class="toc-text">33. 搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-17"><span class="toc-number">18.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-number">18.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-number">18.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">19.</span> <span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-18"><span class="toc-number">19.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-number">19.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-number">19.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC"><span class="toc-number">20.</span> <span class="toc-text">36. 有效的数独</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-19"><span class="toc-number">20.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-number">20.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-number">20.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97"><span class="toc-number">21.</span> <span class="toc-text">38. 外观数列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-20"><span class="toc-number">21.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-number">21.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-number">21.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">22.</span> <span class="toc-text">39. 组合总和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-21"><span class="toc-number">22.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-number">22.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-number">22.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">23.</span> <span class="toc-text">40. 组合总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-22"><span class="toc-number">23.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-number">23.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-number">23.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="toc-number">24.</span> <span class="toc-text">43. 字符串相乘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-23"><span class="toc-number">24.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-number">24.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-number">24.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="toc-number">25.</span> <span class="toc-text">45. 跳跃游戏 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-24"><span class="toc-number">25.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-number">25.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-number">25.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">26.</span> <span class="toc-text">46. 全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-25"><span class="toc-number">26.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-number">26.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-number">26.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number">27.</span> <span class="toc-text">47. 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-26"><span class="toc-number">27.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-number">27.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-number">27.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">28.</span> <span class="toc-text">48. 旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-27"><span class="toc-number">28.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-number">28.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-number">28.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">29.</span> <span class="toc-text">49. 字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-28"><span class="toc-number">29.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-number">29.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-number">29.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-Pow-x-n"><span class="toc-number">30.</span> <span class="toc-text">50. Pow(x, n)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-29"><span class="toc-number">30.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-number">30.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-number">30.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">31.</span> <span class="toc-text">53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-30"><span class="toc-number">31.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-number">31.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-number">31.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">32.</span> <span class="toc-text">54. 螺旋矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-31"><span class="toc-number">32.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-number">32.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-number">32.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">33.</span> <span class="toc-text">55. 跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-32"><span class="toc-number">33.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-number">33.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-number">33.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">34.</span> <span class="toc-text">56. 合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-33"><span class="toc-number">34.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-number">34.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-number">34.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="toc-number">35.</span> <span class="toc-text">57. 插入区间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-34"><span class="toc-number">35.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-number">35.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-number">35.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II"><span class="toc-number">36.</span> <span class="toc-text">59. 螺旋矩阵 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-35"><span class="toc-number">36.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-number">36.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-number">36.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">37.</span> <span class="toc-text">61. 旋转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-36"><span class="toc-number">37.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-number">37.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-number">37.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">38.</span> <span class="toc-text">62. 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-37"><span class="toc-number">38.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-number">38.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-number">38.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">39.</span> <span class="toc-text">63. 不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-38"><span class="toc-number">39.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-number">39.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-number">39.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">40.</span> <span class="toc-text">64. 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-39"><span class="toc-number">40.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-number">40.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-number">40.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84"><span class="toc-number">41.</span> <span class="toc-text">71. 简化路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-40"><span class="toc-number">41.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-number">41.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-number">41.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">42.</span> <span class="toc-text">72. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-41"><span class="toc-number">42.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-number">42.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-number">42.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-number">43.</span> <span class="toc-text">73. 矩阵置零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-42"><span class="toc-number">43.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-number">43.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-number">43.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">44.</span> <span class="toc-text">74. 搜索二维矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-43"><span class="toc-number">44.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-number">44.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-number">44.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">45.</span> <span class="toc-text">75. 颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-44"><span class="toc-number">45.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-number">45.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-number">45.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">46.</span> <span class="toc-text">77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-45"><span class="toc-number">46.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-number">46.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-number">46.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">47.</span> <span class="toc-text">78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-46"><span class="toc-number">47.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-number">47.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-number">47.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">48.</span> <span class="toc-text">79. 单词搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-47"><span class="toc-number">48.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-number">48.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-number">48.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="toc-number">49.</span> <span class="toc-text">80. 删除有序数组中的重复项 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-48"><span class="toc-number">49.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-number">49.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-number">49.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II"><span class="toc-number">50.</span> <span class="toc-text">81. 搜索旋转排序数组 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-49"><span class="toc-number">50.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-number">50.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-number">50.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="toc-number">51.</span> <span class="toc-text">82. 删除排序链表中的重复元素 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-50"><span class="toc-number">51.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-number">51.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-number">51.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="toc-number">52.</span> <span class="toc-text">86. 分隔链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-51"><span class="toc-number">52.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-number">52.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-number">52.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81"><span class="toc-number">53.</span> <span class="toc-text">89. 格雷编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-52"><span class="toc-number">53.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-number">53.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-number">53.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="toc-number">54.</span> <span class="toc-text">90. 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-53"><span class="toc-number">54.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-number">54.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-number">54.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">55.</span> <span class="toc-text">91. 解码方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-54"><span class="toc-number">55.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-number">55.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-number">55.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-number">56.</span> <span class="toc-text">92. 反转链表 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-55"><span class="toc-number">56.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-number">56.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-number">56.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">57.</span> <span class="toc-text">93. 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-56"><span class="toc-number">57.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-number">57.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-number">57.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="toc-number">58.</span> <span class="toc-text">95. 不同的二叉搜索树 II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-57"><span class="toc-number">58.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-number">58.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-number">58.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">59.</span> <span class="toc-text">96. 不同的二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-58"><span class="toc-number">59.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-number">59.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-number">59.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">60.</span> <span class="toc-text">97. 交错字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-59"><span class="toc-number">60.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-number">60.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-number">60.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">61.</span> <span class="toc-text">98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-60"><span class="toc-number">61.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-60"><span class="toc-number">61.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-number">61.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">62.</span> <span class="toc-text">99. 恢复二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%B9%B2-61"><span class="toc-number">62.1.</span> <span class="toc-text">题干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-61"><span class="toc-number">62.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-61"><span class="toc-number">62.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" rel="bookmark" title="Leetcode中等题思路（1-100）">Leetcode中等题思路（1-100）</a></li><li><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" rel="bookmark" title="Leetcode中等题思路（101-100）">Leetcode中等题思路（101-100）</a></li><li><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(201-300)/" rel="bookmark" title="Leetcode中等题思路（201-300）">Leetcode中等题思路（201-300）</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Kun Qian"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Kun Qian</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">41</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">9</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">18</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3FrZ29hbGtlZXBlcg==" title="https:&#x2F;&#x2F;github.com&#x2F;qkgoalkeeper"><i class="ic i-github"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9oYW8tbGFpLXd1LXNob3UtbWVuLXl1YW4=" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hao-lai-wu-shou-men-yuan"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM5MjU2NzE4Nw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;392567187"><i class="ic i-cloud-music"></i></span>
      <a href="/about/" title="&#x2F;about&#x2F;" class="item about"><i class="ic i-address-card"></i></a>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/computer-science/interview/method/%E5%9B%BE%E8%B7%AF%E5%BE%84%E4%B8%93%E9%A2%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF(101-200)/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/%E7%AC%94%E8%AF%95%E6%8A%80%E5%B7%A7/" title="分类于 笔试技巧">笔试技巧</a>
</div>

    <span><a href="/computer-science/interview/method/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/" title="并查集专题">并查集专题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20006.%20%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/" title="剑指 Offer II 006. 排序数组中两个数字之和">剑指 Offer II 006. 排序数组中两个数字之和</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%9D%E8%B7%AF/" title="分类于 算法题思路">算法题思路</a>
</div>

    <span><a href="/computer-science/leetcode/algorithm/Leetcode%E4%B8%AD%E7%AD%89%E9%A2%98%E6%80%9D%E8%B7%AF%EF%BC%881-100%EF%BC%89/" title="Leetcode中等题思路（1-100）">Leetcode中等题思路（1-100）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20002.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/" title="剑指 Offer II 002. 二进制加法">剑指 Offer II 002. 二进制加法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9D%82%E8%B0%88/" title="分类于 杂谈">杂谈</a>
</div>

    <span><a href="/new%20blog%E8%BF%81%E7%A7%BB%E8%AF%B4%E6%98%8E/" title="新blog迁移记录">新blog迁移记录</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/%E7%AC%94%E8%AF%95%E6%8A%80%E5%B7%A7/" title="分类于 笔试技巧">笔试技巧</a>
</div>

    <span><a href="/computer-science/interview/method/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/" title="排序专题">排序专题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20011.%200%20%E5%92%8C%201%20%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="剑指 Offer II 011. 0 和 1 个数相同的子数组">剑指 Offer II 011. 0 和 1 个数相同的子数组</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/%E7%AC%94%E8%AF%95%E6%8A%80%E5%B7%A7/" title="分类于 笔试技巧">笔试技巧</a>
</div>

    <span><a href="/computer-science/interview/method/c++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97/" title="c++字符串分割、类型转换、进制转换、位运算">c++字符串分割、类型转换、进制转换、位运算</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/" title="分类于 Leetcode">Leetcode</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/leetcode/offer2/" title="分类于 剑指offer">剑指offer</a>
</div>

    <span><a href="/computer-science/leetcode/offer2/LeetCode%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%89%91%E6%8C%87%20Offer%20II%20007.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%200%20%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0/" title="剑指 Offer II 007. 数组中和为 0 的三个数">剑指 Offer II 007. 数组中和为 0 的三个数</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/%E7%AC%94%E8%AF%95%E6%8A%80%E5%B7%A7/" title="分类于 笔试技巧">笔试技巧</a>
</div>

    <span><a href="/computer-science/interview/method/%E6%89%8B%E6%92%95%E7%B3%BB%E5%88%97/" title="手撕常用算法和结构">手撕常用算法和结构</a></span>
  </li>

  </ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2020 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Kun Qian @ Kun Qian</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'computer-science/leetcode/algorithm/Leetcode中等题思路（1-100）/',
    favicon: {
      show: "qkgoalkeeper's blog",
      hide: "qkgoalkeeper's blog"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
