<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>fast21-zhong论文解读 - qkgoalkeeper&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  
  <meta name="description" content="REMIX：LSM树的高效范围查询 0.摘要 基于LSM树的键值（KV）以多级结构存储数据，用于高速写入。传统LSM树上的范围查询必须动态地从多">
  
  <meta itemprop="name" content="fast21-zhong论文解读 - qkgoalkeeper&#39;s blog">
  <meta itemprop="description" content="REMIX：LSM树的高效范围查询 0.摘要 基于LSM树的键值（KV）以多级结构存储数据，用于高速写入。传统LSM树上的范围查询必须动态地从多">
  <meta itemprop="image" content="https://qkgoalkeeper.github.io/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://qkgoalkeeper.github.io/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/highlight/styles/github.css">
  <script src="https://qkgoalkeeper.github.io/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/css/style.css">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-175507250-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-175507250-1');
</script>
  

</head>

<body>
  <header>
    <div>
  <div id="imglogo">
    <a href="https://qkgoalkeeper.github.io/"><img src='https://qkgoalkeeper.github.io/img/logo.svg' alt="qkgoalkeeper&#39;s blog" title="qkgoalkeeper&#39;s blog"/></a>
  </div>
  <div id="textlogo">
    <h1 class="site-name"><a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a></h1>
    <h2 class="blog-motto">ECNU数据学院在读</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/about">关于</a></li>
      
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder='Search'>
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://qkgoalkeeper.github.io/post/fast21-zhong%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" title="fast21-zhong论文解读" itemprop="url">fast21-zhong论文解读</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://qkgoalkeeper.github.io/" title="qk">qk</a>
    
  </p>
  <p class="article-time">
    <time datetime="2022-05-01 11:55:19 &#43;0800 CST" itemprop="datePublished">2022年05月01日</time>
  </p>
</header>

	<div class="article-content">
    
		<div class="toc-article">
			<strong class="toc-title">文章目录</strong>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#0摘要">0.摘要</a></li>
    <li><a href="#1简介">1.简介</a></li>
    <li><a href="#2背景">2.背景</a></li>
    <li><a href="#3remix">3.remix</a>
      <ul>
        <li><a href="#31-the-remix-数据结构">3.1 The REMIX 数据结构</a></li>
        <li><a href="#32-片段中的高效搜索">3.2 片段中的高效搜索</a></li>
        <li><a href="#33-搜索效率">3.3 搜索效率</a></li>
        <li><a href="#34-remix-存储成本">3.4 REMIX 存储成本</a></li>
      </ul>
    </li>
    <li><a href="#4-remixdb">4 RemixDB</a>
      <ul>
        <li><a href="#41-remixdb文件结构">4.1 RemixDB文件结构</a></li>
        <li><a href="#42-合并compaction">4.2 合并compaction</a></li>
        <li><a href="#43-remixes重建">4.3 REMIXes重建</a></li>
      </ul>
    </li>
    <li><a href="#5-评估">5 评估</a>
      <ul>
        <li><a href="#51-remix索引表的性能">5.1 remix索引表的性能</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>
    
    <h1 id="remixlsm树的高效范围查询-httpswwwusenixorgconferencefast21presentationzhong"><a href="https://www.usenix.org/conference/fast21/presentation/zhong">REMIX：LSM树的高效范围查询 </a></h1>
<h2 id="0摘要">0.摘要</h2>
<p>基于LSM树的键值（KV）以多级结构存储数据，用于高速写入。传统LSM树上的范围查询必须动态地从多个表文件中查找和排序合并数据，这非常昂贵，而且通常会导致平庸的读取性能。为了提高LSM树上的范围查询效率，我们引入了一种空间高效的KV索引数据结构，名为REMIX，它记录了跨越多个表文件的KV数据的全局排序视图。对多个remix索引数据文件的范围查询可以使用二进制搜索快速定位目标密钥，并按排序顺序检索后续key，而无需进行key比较。我们构建了RemixDB，这是一个基于LSM树的KV存储，它采用了一种高效写压缩策略，并使用Remix进行快速的点和范围查询。实验结果表明，在基于写优化LSM树的KV-store中，remix可以显著提高范围查询性能。</p>
<h2 id="1简介">1.简介</h2>
<p>Key  value stores（KV  stores）是许多云和数据中心服务的主干，包括社交媒体、实时分析、电子商务和加密货币。日志结构的合并树（LSMtree）是许多KV存储的核心数据结构。与需要在磁盘上进行就地更新的传统存储结构（如B+树）不同，LSMTree遵循一种异地更新方案，该方案支持高速顺序写入I/O。它在内存中缓冲区更新，并定期将其刷新到持久存储中，以生成不可变文件。然而，这会对搜索效率造成影响，因为一个范围内的键可能位于不同的表中，由于计算和I/O成本较高，可能会降低查询速度。基于LSM树的设计代表了更新成本和搜索成本之间的权衡，与B+树相比，保持了较低的更新成本，但搜索成本要高得多。为了提高查询性能，已经做了很多工作。为了加快点查询的速度，每个表通常都与内存驻留Bloom过滤器相关联，以便查询可以跳过不包含目标键的表。但是，Bloom过滤器无法处理范围查询。提出了SuRF和Rosetta等范围过滤器，通过过滤掉不包含请求范围内任何键的表来加速范围查询。然而，当请求范围内的键位于大多数候选表中时，过滤方法很难提高查询性能，尤其是在大范围查询中。此外，当可以通过缓存回答查询时，访问过滤器的计算成本可能会导致性能平平，这在现实世界的工作负载中通常是如此。为了限制搜索请求必须访问的表的数量，LSM树保留了一个后台压缩线程来不断地合并表进行排序。表格选择由压缩策略决定。许多KV存储都采用了compaction策略，包括LevelDB[26]和RocksDB[20]。分级压缩排序将较小的排序运行合并为较大的运行，以将重叠表的数量保持在阈值以下。实际上，分级压缩提供了最佳的读取效率，但由于其积极的排序合并策略，具有较高的写入放大率（WA）。或者，分层压缩策略等待多个大小相似的排序运行，并将它们合并到一个更大的运行中。分层压缩提供了更低的WA和更高的更新吞吐量。它已被许多KVStore采用，如Cassandra和Scyllab。由于分层压缩不能有效地限制重叠表的数量，因此与分层压缩相比，它会导致更高的搜索成本。其他压缩策略可以更好地平衡读写效率，但它们都不能同时达到最佳读写效率。问题在于，为了限制已排序的运行次数，存储必须对现有数据进行排序、合并和重写。今天的存储技术已经显示出随机存取效率的显著提高。例如，商品闪存SSD上的随机读取可能超过顺序读取吞吐量的50%。3D XPoint等新技术（如英特尔的Optane  SSD）为随机和顺序I/O提供了几乎相同的性能。因此，无需对KV对进行物理排序，即可快速接入。相反，KV存储可以保持数据的逻辑排序，以实现高效的点和范围查询，同时避免过度重写。 为此，我们设计了REMIX，即范围查询效率高的多表索引。与现有的解决方案不同，现有的解决方案可以改善范围查询，这些查询需要在物理重写数据和动态执行昂贵的排序合并之间苦苦挣扎，remix使用节省空间的数据结构来记录跨多个表文件的KV数据的全局排序视图。通过remix，基于LSM树的KV存储可以利用高效写压缩策略，而不牺牲搜索性能。我们构建了RemixDB，一个基于混合索引LSM树的KV存储。RemixDB集成了高效写分层压缩策略和分区LSM树布局，同时实现了低WA和快速搜索。实验结果表明，当在多个重叠表上搜索时，remix可以有效地提高范围查询的性能。性能评估表明，RemixDB在读写操作上同时优于最先进的基于LSM树的KV存储。</p>
<h2 id="2背景">2.背景</h2>
<p>LSM树是为持久存储设备上的高写入效率而设计的。它通过在内存结构（称为MemTable）中缓冲所有更新来实现高速写入。当MemTable填满时，缓冲的key将被排序，并通过一个名为“minor 压缩”的进程以排序的run的方式刷新到持久存储中。minor压缩是高效的，因为更新是按顺序成批写入的，而不会与存储中的现有数据合并。由于排序的run可能有重叠的关键点范围，点查询必须检查所有可能的运行，从而导致较高的搜索成本。为了限制重叠run的数量，LSMtree使用主要的压缩过程将多个重叠管路排序合并为较少的管路。压缩策略决定了如何选择表进行主要压缩。最常用的两种策略是leveling压实和tiering压实。使用分级压缩的存储具有多级结构，其中每一级维护由一个或多个表组成的排序运行。一个级别（Ln）的容量是前一个级别（Ln）的倍数（通常为10）−1）  ，这样就可以在几个级别（通常为5到7级）内组织一个大型KV存储。分级压缩使读取相对高效，但会导致较低的写入效率。分级压缩从相邻级别（Ln和Ln+1）中选择重叠表进行排序合并，并在更大级别（Ln+1）中生成新表。由于容量呈指数级增长，一个表的键范围通常会在下一级与多个表重叠。因此，大多数写操作都是为了重写Ln+1中的现有数据，导致实际情况下WA比率高达40。图1显示了一个分层压缩的示例，其中每个表包含两个或三个键。如果选择L1中的第一个表（包含键（4,21,38））与L2中的前两个表（（6,26）和（31,40,46））进行排序合并，L2中的五个键将被重写。通过分层压缩，可以在一个级别中缓冲多个重叠的排序运行，如图2所示。一个级别中的运行次数以T表示的阈值为界，其中T&gt;1。当一个级别（Ln）中的已排序run数达到阈值时，Ln中的所有已排序运行将被排序合并为下一个级别（Ln+1）中的新已排序运行，而不重写Ln+1中的任何现有数据。因此，使用分层压缩，LSM树的WA比率为O（L），其中L是层数。对于相对较大的T，分层压缩提供的WA比使用类似L的分层压缩低得多。但是，由于在每个级别中可能有多个重叠的排序run，点查询将需要检查多达T×L表，从而导致搜索速度慢得多。LevelDB/RocksDB中的范围查询是通过使用迭代器结构在多个表之间导航来实现的，就像所有键都在一个排序的run中一样。范围查询首先使用带有搜索键（目标键范围的下边界）的搜索操作初始化迭代器。seek操作定位迭代器，使其指向存储中等于或大于seek键（按字符串键的词法顺序）的最小键，seek键被表示为范围查询的目标键。下一个操作推进迭代器，使其指向排序顺序中的下一个键。接下来的一系列操作可用于检索目标范围内的后续key，直到满足特定条件（例如，key数或范围结束）。由于排序的run是按时间顺序生成的，所以目标键可以驻留在任何run中。因此，迭代器必须跟踪所有排序的运行。图1显示了使用分层压缩在LSM树上搜索的示例。为了寻找密钥67，在每次运行时使用二进制搜索来识别满足密钥要求的最小密钥≥  寻找key。每个已识别的键都由光标标记。然后使用最小堆结构对这些键进行排序合并，从而选择L2中的键67。随后，接下来的每个操作都会比较光标下的键，返回最小的键，并前进相应的光标。这个过程显示了键的全局排序视图，如图1右上角所示。在本例中，排序合并必须访问所有三个级别。图2显示了分层压缩的类似示例。由于有六个重叠的排序run，搜索操作比前一个示例更昂贵。实际上，分层压缩中的阈值T通常设置为一个较小的值，例如Scyllab中的T=4，以避免存储中有太多重叠的排序run。</p>
<h2 id="3remix">3.remix</h2>
<p>对多个排序run的范围查询操作动态构造基础表的排序视图，以便可以按排序顺序检索键。实际上，排序视图继承了表文件的不变性，并在删除或替换任何表之前保持有效。然而，现有的基于LSM树的KV存储无法利用这种继承的不变性。相反，排序视图会在搜索时重复重建，然后立即丢弃，这会由于计算和I/O过多而导致搜索性能不佳。REMIX的动机是通过保留基础表的排序视图并在未来搜索中重用它们来利用表文件的不变性。为了提高I/O效率，基于LSM树的KV存储采用了节省内存的元数据格式，包括稀疏索引和Bloom过滤器。如果我们记录每个键及其位置以在存储中保留已排序的视图，存储的元数据可能会大大膨胀，从而导致读写性能下降。为了避免这个问题，remix数据结构必须节省空间。</p>
<h3 id="31-the-remix-数据结构">3.1 The REMIX 数据结构</h3>
<p>图3的顶部显示了一个排序视图的示例，其中包含三个排序的run：R0、R1和R2。箭头显示了三个run的排序视图，形成了一个由15个键组成的序列。为了构建remix，我们首先将已排序视图的key划分为多个segment，每个segment包含固定数量的key。每段都附有一个定位键anchor key、一组指针offsets和一组run selector。锚定关键点表示段中最小的关键点。所有锚定键共同构成排序视图上的稀疏索引。每个指针offset对应一个梯段，并记录梯段中最小key的位置，该位置等于或大于定位key的key。段中的每个键都有一个对应的run选择器，该选择器指示键所在的运行。run选择器对排序视图上键的顺序访问路径进行编码，从段的锚键开始。</p>
<p>remix迭代器不使用最小堆。相反，迭代器包含一组游标和一个当前指针。每个光标对应一个梯段，并指向梯段中某个关键点的位置。当前指针指向一个运行选择器，该选择器选择一个run，运行的光标确定当前到达的键。在混音中使用迭代器查找密钥需要三个步骤。首先，对锚键执行二分搜索，以找到范围覆盖搜索键的目标段，满足锚键≤  寻找key。其次，迭代器被初始化为指向锚键。具体而言，使用段的光标偏移量定位光标，并将当前指针设置为指向段的第一个运行选择器。最后，通过在排序视图上线性扫描可以找到目标键。要使迭代器前进，当前键的光标将前进以跳过该键。同时，当前指针也会前进，指向下一个run选择器。搜索操作完成后，可以通过以相同的方式推进迭代器来检索排序视图（目标段内外）上的后续键。下面是搜索操作的一个示例。如图3所示，底部的四个框表示对排序视图进行编码的remix元数据。请注意，括号中的键不是元数据的一部分。要搜索键17，通过二分搜索选择第二段，该段包含键（11,17,23,29）。然后根据段的光标偏移量（（1,2,1））将光标分别放置在R0、R1和R2中的键11、17和31上。同时，当前指针被设置为指向段的第一个run选择器（0，图中的第五个选择器），指示当前键（11）位于光标R0下方。由于11&lt;17，需要使用迭代器查找满足k的最小密钥k≥  17.为了推进迭代器，首先推进R0上的光标，使其跳过键11，现在位于键23上。迭代器的光标偏移现在变为2、2和1。然后，当前指针前进到段的第二个运行选择器（1，图中的第六个选择器）。高级迭代器选择R1，R1光标下的当前键17是目标键。搜索操作到此结束。随后的键（23、29、31等）在排序视图上，可以通过反复推进迭代器来检索。</p>
<h3 id="32-片段中的高效搜索">3.2 片段中的高效搜索</h3>
<p>seek操作通过对锚键进行二分搜索来初始化迭代器，以找到目标段，并在排序视图上向前扫描以查找目标键。增加段大小可以减少定位键的数量并加快二进制搜索。然而，它可以减慢寻道操作，因为在大目标段中扫描平均需要访问更多密钥。为了解决潜在的性能问题，我们还使用目标段内的二分搜索来最小化搜索成本。</p>
<p>二分搜索 要在段中执行二分搜索，我们必须能够随机访问段中的每个键。段中的关键点属于梯段，如相应的梯段选择器所示。要访问键，我们需要将梯段的光标放置在正确的位置。这可以通过计算同一run选择器在键之前的段中出现的次数，并将相应的光标向前移动相同的次数来实现。使用现代CPU上的SIMD指令，可以实时快速计算出现次数。搜索范围可以通过在段中进行几次随机访问快速缩小，直到识别出目标密钥。为了结束搜索操作，我们使用目标键之前每个run选择器的出现来初始化所有游标。图4显示了具有16个运行选择器的段的示例。每个运行选择器下面显示的数字表示同一运行选择器在其位置之前出现的次数。例如，41是该段中R3中的第三个键，因此相应的出现次数为2（在第三个“3”下）。要访问键41，我们初始化R3的光标，并将其向前移动两次，以跳过5和23。要在图4中的段中查找键41，在二进制搜索期间将依次访问键43、17、31和41，如箭头和带圆圈的数字所示。键43是段中的第八个键，R3是段中的第四个键。要访问键43，我们初始化R3的光标，并将其向前移动三次，以跳过键5、23和41。然后，可以通过读取该段R2上的第一个键来访问键17。类似地，31和41分别是R1和R3上的第二个和第三个键。最后，迭代器的所有游标都被初始化为指向正确的键。在本例中，光标最终位于键61、53、89和41，其中41是当前键。 I/O优化在段中执行二进制搜索可以最小化密钥比较的数量。但是，搜索路径上的键可能位于不同的运行中，如果未缓存相应的数据块，则必须通过单独的I/O请求来检索。例如，图4中的搜索只需要四个关键比较，但必须访问三次运行。实际上，R3的键41、43和其他几个键很可能属于同一个数据块。因此，在密钥比较之后，搜索可以利用同一数据块中的剩余密钥，在必须访问不同的run之前，进一步缩小搜索范围。这样，R3中的六个键中的每一个都可以在不访问任何其他run的情况下找到。例如，在搜索键79时，访问R3可以将搜索范围缩小到键43和键83之间，在与键71进行键比较后，可以在R0中找到键79。</p>
<h3 id="33-搜索效率">3.3 搜索效率</h3>
<p>remix从三个方面改进了范围查询。remix使用一个二分搜索找到目标密钥。remix提供了多个排序run的排序视图。只需在remix上进行一次二分搜索，即可在多次运行中将光标定位到目标键上。而在传统的基于LSM树的KV存储中，搜索操作需要在每次运行时进行大量二分搜索。例如，假设一个商店有四个大小相等的运行，每个运行中有N个键。没有remix的seek操作需要4×log2n密钥比较，而它只需要与remix进行log24n或2+log2n密钥比较。remix移动迭代器而不进行键比较。remix中的迭代器通过使用预先录制的run选择器来更新光标和当前指针，直接切换到下一个（或上一个）KV对。这个过程不需要任何关键的比较。如果迭代器跳过密钥，也可以避免读取KV对。相比之下，传统的基于LSM树的KV-store中的迭代器会维护一个最小堆，以对多个重叠排序run中的键进行排序合并。在这种情况下，下一个操作需要从多次运行中读取密钥以进行比较。run跳过不在搜索路径上的步骤。使用remix的搜索操作需要在目标段中进行二分搜索。在搜索时，仅访问包含搜索路径上的键的已排序run。在最好的情况下，如果一系列目标键驻留在一次run中，如图3中的段（31,43,52,67），则只会访问一次运行（示例中的R2）。但是，合并迭代器必须访问seek操作中的每次运行。此外，大幅降低的寻道成本允许在由run索引的多个排序运行上进行高效的点查询（例如GET），而无需使用Bloom过滤器。我们在§5.1中广泛评估了点查询效率。</p>
<h3 id="34-remix-存储成本">3.4 REMIX 存储成本</h3>
<p>remix元数据由三部分组成：定位键、光标偏移和run选择器。我们将D定义为一段中的最大键数。run为每D个键存储一个锚键，平均需要1/D的总键大小。假设光标偏移量的大小为S字节，则remix需要S×H字节来存储每个D键的光标偏移量，其中H表示由混音索引的运行次数。运行选择器需要dlog2（H）e位。将这三个部分加在一起，混音预计将存储（&lsquo;L+SH）/D+dlog2（H）e/8）字节key，其中&rsquo;L是平均锚键大小。我们使用Facebook生产KV工作负载中公开报告的平均KV大小来估算remix的存储成本[2,8]。实际上，S是实现定义的，H取决于被索引的表的数量。在估算中，我们使用了4字节（S=4）的游标偏移量，以便游标偏移量可以为每个排序的运行寻址4  GB的空间。我们将排序的运行数设置为8（H=8）。通过这些实际配置，remix可以存储（（&lsquo;L+32）/D+3/8）字节/key。表1显示了具有不同D（D=16、32和64）的每个工作负载的混音存储成本。为了进行比较，它还显示了LevelDB和RocksDB中SSTable格式的块索引（BI）和Bloom过滤器（BF）的存储成本。请注意，由remix索引的表文件不使用块索引或Bloom过滤器。SSTable为每个4KB的数据块存储一个键和一个块句柄。通过将平均KV大小和近似块句柄大小（4b）之和除以4kb块中KV对的估计数量来估计块索引存储成本。Bloom过滤器估计为10位/键。对于不同的D和“L”值，remix存储成本从1.0字节/密钥到5.4字节/密钥不等。对于每种密钥大小，增加D可以显著降低混音存储成本。最后一个专栏remix数据显示混音与其索引数据的大小比。在最坏的情况下（USR存储），remix的大小仍然小于KV数据大小的10%。</p>
<h2 id="4-remixdb">4 RemixDB</h2>
<p>为了评估remix性能，我们实现了一个名为RemixDB的基于LSMtree的KV存储。RemixDB采用tiered压缩策略来实现最佳写入效率。现实世界的工作负载通常表现出高度的空间局部性。最近的研究表明，分区存储布局可以有效地降低现实工作负载下的压缩成本。RemixDB采用这种方法，将key空间划分为非重叠key范围的分区。每个分区中的表文件都由remix索引，提供分区的排序视图。通过这种方式，RemixDB本质上是一个使用tiered压缩的单级LSM树。RemixDB不仅继承了tiered压缩的写入效率，而且在Remix的帮助下实现了高效读取。RemixDB的点查询操作（GET）执行查找操作，如果与目标键匹配，则返回迭代器下的键。RemixDB不使用Bloom过滤器。图5显示了RemixDB的系统组件。与LevelDB和RocksDB类似，RemixDB缓冲区在MemTable中更新。同时，这些更新还被附加到一个预写日志（WAL）中以实现持久性。当缓冲更新的大小达到阈值时，MemTable将转换为不可变MemTable进行压缩，并创建一个新MemTable来接收更新。分区中的压缩将创建分区的新版本，其中包括新旧表文件和新的remix文件。旧版本在压缩后被垃圾收集。在多级LSM树设计中，MemTable的大小通常只有几十MB，接近默认的SSTable大小。在分区存储布局中，较大的MemTables可以在触发压缩之前积累更多更新[3,24]，这有助于减少WA。MemTables和WAL的空间成本接近恒定，考虑到当今数据中心的大内存和存储容量，这是适度的。在RemixDB中，最大MemTable大小设置为4GB。在下文中，我们将介绍文件结构（§4.1）、压缩过程（§4.2）以及使用remix的成本和权衡（§4.3）。</p>
<h3 id="41-remixdb文件结构">4.1 RemixDB文件结构</h3>
<p>表文件 图6显示了RemixDB中的表文件格式。默认情况下，数据块为4KB。不适合4KB块的大KV对独占占用4KB的倍数的巨型块。每个数据块在块的开头包含一个小数组，其中包含其KV对的块偏移量，用于随机访问单个KV对。元数据块是一个8位值的数组，每个值记录4KB块中的键数。因此，一个块最多可以包含255个kv对。在巨型块中，除了前4KB之外，其余的块都将其相应的数字设置为0，这样非零的数字总是对应于块的头部。使用偏移数组和元数据块，搜索可以快速到达任何相邻块，跳过任意数量的键，而无需访问数据块。由于KV对由remix索引，所以表文件不包含索引或过滤器。</p>
<p>REMIX文件 图7显示了RemixDB中的REMIX文件格式。remix中的anchor键被组织在一个不可变的B+树状索引中（类似于LevelDB/RocksDB的块索引），这有助于对anchor键进行二分搜索。每个定位键都与一个段ID相关联，该ID标识一个段的光标偏移和run选择器。游标偏移量由16位块索引和8位键索引组成，如图7中的blk  id和key id所示。块索引最多可寻址65536个4-KB块（256  MB）。每个块可以包含多达256个kv的8位密钥索引对。一个分区的不同表文件中可能存在一个键的多个版本。范围查询操作必须跳过旧版本并返回每个键的最新版本。为此，在remix中，一个密钥的多个版本在排序视图中从最新到最旧排序，每个运行选择器的最高位被保留以区分新旧版本。前向扫描操作总是首先遇到密钥的最新版本，然后可以通过检查每个运行选择器的保留位而跳过旧版本，而无需比较任何密钥。 如果一个密钥有多个版本，这些版本可以跨越两个段。搜索可能必须检查两个段才能检索最新版本的密钥。为了简化这种情况下的搜索，我们在构建remix时，通过在第一段中插入特殊的run选择器作为占位符，将所有版本的密钥向前移动到第二段。我们还确保一段中的最大键数等于或大于remix索引的run次数（D≥  H）  因此，每个段都足够大，可以容纳所有版本的密钥。为了适应上面提到的特殊值，RemixDB中的每个run选择器占用一个字节。运行选择器的第八位和第七位（0x80和0x40）分别表示旧版本和已删除密钥（墓碑）。特殊值63（0x3f）表示占位符。通过这种方式，RemixDB可以在每个分区中管理多达63次排序的运行（0到62次），这在实践中已经足够了。</p>
<h3 id="42-合并compaction">4.2 合并compaction</h3>
<p>在每个分区中，压缩过程根据进入分区的新数据的大小和现有表的布局来估计压缩成本。根据估计，执行以下步骤之一：•中止：取消分区压缩，并将新数据保留在MemTables和WAL中。•次要压缩：将新数据写入一个或多个新表，而不重写现有表。•主要压缩：将新数据与部分或全部现有表合并 •拆分压缩：将新数据与所有现有数据合并，并将分区拆分为几个新分区。中止压缩后，看到任何新表文件的分区将重建其remix。当在分区中创建一个小的表文件时，经过一次小的压缩后，重建remix会导致很高的I/O成本。例如，表1中的USR工作负载的remix与kv数据的大小比率最高（9.38%）。将100  MB的新数据写入包含1 GB旧表文件的分区将创建一个大约100  MB的混音。为了最小化I/O成本，如果估计的I/O成本高于阈值，RemixDB可以中止分区的压缩。在这种情况下，新的KV数据应保留在MemTables和WAL中，直到下一次压实。然而，在极端情况下，例如具有统一访问模式的工作负载，当大多数分区的压缩被中止时，压缩过程无法有效地将数据移动到分区中。为了避免这个问题，我们进一步限制可以留在MemTables和W中的新数据的大小，使其不超过最大MemTable大小的15%。压缩过程可以中止I/O成本最高的压缩，直到达到大小限制。</p>
<p>次要压缩·	次要压缩将不可变MemTable中的新数据写入分区，而不重写现有的表文件，并重建分区的混合。根据新数据的大小，较小的压缩会创建一个或几个新表文件。当压缩后的表文件的预期数量（现有表文件的数量加上新表文件的估计数量）低于阈值T（在我们的实现中为10）时，使用较小的压缩。图8显示了一个创建一个新表文件的小型压缩示例。</p>
<p>主要压缩	当分区中预期的表文件数超过阈值T时，需要进行主要（或分割）压缩。主要压缩排序将现有表文件合并为较少的表文件。通过减少表文件的数量，将来可以执行较小的压缩。主要压缩的效率可以通过输入表文件数与输出表文件数的比率来估计。图9显示了一个主要的压缩示例。在本例中，新数据与三个小表格文件合并，压缩后只创建一个新表格文件（比率=3/1）。如果对整个分区进行排序合并，则压缩需要重写更多数据，但由于表文件的大小限制，仍然会生成三个表（比率=5/3）。因此，主压缩选择可以产生最高比率的输入文件的数量。</p>
<p>分割压缩	主要压缩可能无法有效地减少填充了大型表的分区中的表数，这可以通过较低的估计输入/输出比（如10/9）来预测。在这种情况下，分区应该被分割成多个分区，这样每个分区中的表的数量就可以大大减少。拆分压缩排序将新数据与分区中的所有现有表文件合并，并生成新表文件以形成几个新分区。图10显示了一个拆分压缩示例。为了避免在分割压缩中创建许多小分区，压缩过程在切换到下一个分区之前在一个分区中创建M个（默认情况下为M=2）新表文件。这样，拆分压缩将创建dE/Me新分区，其中E是新表文件的数量。</p>
<h3 id="43-remixes重建">4.3 REMIXes重建</h3>
<p>分区存储布局可以在高空间局部性的真实工作负载下有效地最小化压缩成本。具体来说，RemixDB可以在几个分区中吸收大部分更新，并且可以避免在接收较少更新的分区中进行压缩（参见§4.2）。然而，如果工作负载缺乏空间局部性，那么不可避免的是，许多分区必须通过少量更新来执行压缩。tiered压缩可以最大限度地减少这些分区中的写入，但在分区中重建remix仍需要读取现有表。在我们的实现中，RemixDB利用分区中现有的REMIX，并采用高效的合并算法来最小化重建过程的I/O成本。在分区中重建remix时，现有的表已经被remix索引，这些表可以被视为一个排序的run。因此，重建过程相当于排序合并两个已排序的run，一个来自现有数据，另一个来自新数据。当现有的排序run明显大于新的排序run时，Hwang等人提出的广义二分合并算法比使用最小堆的排序合并需要更少的密钥比较。该算法根据两个排序的run之间的大小比估计每个下一个合并点的位置，并在相邻范围内搜索。在RemixDB中，我们通过使用定位键来定位包含合并点的目标段，并最终在该段中应用二分搜索来近似该算法。在这个过程中，访问锚键不会产生任何I/O，因为它们存储在remix中。目标段中的二分搜索最多读取log2d键以找到合并点。现有表格的所有运行选择器和光标偏移都可以从现有的remix中导出，而无需任何I/O。要为新段创建定位键，我们需要在新的排序视图中，每个段最多访问一个键。重建remix的读I/O受分区中所有表的大小限制。重建过程会导致对现有表的读I/O，以换取最小化的WA和提高未来的读性能。重建remix是否具有成本效益取决于人们希望节省多少写I/O，以及人们希望在未来提高多少读性能。实际上，SSD中的写操作通常比读操作慢，可能会对设备造成永久性损坏。因此，读操作比写操作更经济，尤其是对于具有备用I/O带宽的系统。在需要密集写入且空间局部性较弱的系统中，采用多级tiered压缩策略或延迟在单个分区中remix混音可以降低重建成本，但代价是拥有更多级别的排序视图。将remix与不同的存储布局相结合超出了本文的范围。在§5.2中，我们对不同工作负载下的RemixDB重建成本进行了实证评估。</p>
<h2 id="5-评估">5 评估</h2>
<p>在本节中，我们首先评估remix性能特征（§5.1），然后使用一组微基准测试和Yahoo的YCSB基准测试工具（模拟真实世界的工作负载）对remix XDB进行基准测试（§5.2）。评估系统在两个Intel Xeon Silver 4210  CPU和64 GB DRAM上运行64位Linux（v5.8.7）。实验在960 GB Intel 905P Optane PCIe  SSD上的Ext4文件系统上运行。</p>
<h3 id="51-remix索引表的性能">5.1 remix索引表的性能</h3>
<p>我们首先评估remix的性能。我们实现了一个微基准测试框架，用于比较remix索引后表和原sstable的性能。SSTables使用Bloom过滤器加速点查询，并使用合并迭代器执行范围查询。实验设置在每个实验中，我们首先创建一组H表格文件（1 ≤  H≤ 16） ，类似于RemixDB中的分区或使用tiered压缩的LSM树中的级别。每个表文件包含64MB的KV对，其中键和值的大小分别为16B和100B。当H≥ 2，KV-对可以使用两种不同的模式分配给表：•弱局部性：每个key被分配给随机选择的表，该表提供弱访问局部性，因为逻辑上连续的密钥通常位于不同的表中 •强局部性：每64个逻辑上连续的key被分配给一个随机选择的表，这提供了强访问局部性，因为范围查询可以从几个表中检索多个连续键。每个SSTable包含10位/键的Bloom过滤器。64 MB的用户空间块cache2用于访问文件。我们使用上述配置创建的不同表集来测量三个范围和点查询操作（即Seek、Seek+Next50和Get）的单线程吞吐量。Seek+Next50操作执行Seek并检索下一个50键值对。在这些实验中，搜索键是按照均匀分布随机选择的。对于REMIX，我们将段大小设置为32（D=32），并在打开和关闭段内二分搜索时测量吞吐量，分别用完整和部分二分搜索表示。</p>
<p>对于点查询（Get），我们在打开和关闭Bloom过滤器的情况下测量SSTables的吞吐量。我们运行每个实验，直到吞吐量读数稳定。图11和图12分别显示了具有弱访问区域性和强访问区域性的表的吞吐量结果。</p>
<p>弱局部性表上的Seek图11a显示了使用remix和合并迭代器的Seek操作的吞吐量。我们观察到，当只有一个表文件时，使用合并迭代器的吞吐量大约比使用全二分搜索的混音高20%。在这种情况下，两种机制在二分搜索期间执行相同数量的密钥比较。然而，当在片段中搜索时，remix需要实时计算出现的次数，并将迭代器从片段的开头移动到一个键以进行比较，这比常规迭代器更昂贵。随着表文件数量的增加，合并迭代器的吞吐量会迅速下降。具体来说，两个表的吞吐量比一个表的吞吐量低50%；在八个表上搜索比在一个表上搜索慢11倍以上。合并迭代器的搜索时间大致与表文件的数量成正比。这是因为合并迭代器需要对每个表文件进行完整的二分搜索。remix的吞吐量也会随着表格文件的增多而降低。增长放缓的主要原因是数据集不断增长，在搜索过程中需要更多的键比较和内存访问。然而，与合并迭代器相比，具有完全二分搜索的remix实现了越来越高的加速。具体来说，加速比分别为5.1倍和9.3倍，有8个和16个表文件。关闭段内二分搜索（使用部分二分搜索）时，remix吞吐量将降低20%至33%。在这种情况下，搜索必须线性扫描目标段以找到目标密钥。当D=32时，目标段中的键比较平均数为5（log2  D），采用完全二分搜索，16（D/2）采用部分二分搜索。然而，搜索成本仍然大大低于合并迭代器的搜索成本。使用部分二分搜索的remix比合并迭代器的性能高出3.5倍和6.1倍，分别有8个和16个表文件。Seek+Next50图11b显示了范围查询的吞吐量，这些查询寻找并将50键值对复制到用户提供的缓冲区。总体吞吐量结果远低于Seek实验中的结果，因为数据复制成本很高。然而，当有两个或多个表时，remix仍然优于合并迭代器。对于2个、8个和16个表文件，加速比分别为1.4倍、2.3倍和3.1倍。合并迭代器的次优扫描性能是由于昂贵的下一个操作，需要进行多个键比较才能在排序视图中找到下一个键。对于复制到缓冲区的每个KV对，必须读取多个KV对并进行比较，以找到全局最小值。相比之下，remix不需要在下一次操作中进行任何键比较。</p>
<p>与图11a中的两条混音曲线之间的巨大性能差距相比，图11b中的两条曲线彼此非常接近。这种现象是两种影响的结果：（1）下一个操作控制执行时间；（2）段中搜索操作的线性扫描使块缓存升温，从而使未来的下一个操作更快。点查询图11c显示了点查询实验的结果。remix的曲线略低于图11a中的对应曲线，因为get操作需要在使用remix进行寻道后复制KV对。当不到14个表时，使用Bloom过滤器在SSTables上搜索的性能优于在remix索引表文件上搜索的性能。造成这种差异的原因有两方面。首先，一个搜索可以有效地缩小到一个表文件，而只需检查Bloom过滤器。其次，在SSTable中搜索比在管理更多key的remix上搜索更快。在最坏的情况下，remix的吞吐量比Bloom过滤器（有3张表）低20%。毫不奇怪，如果没有Bloom过滤器，使用两个以上SSTable的搜索速度会慢得多。强局部性表的性能图12显示了强访问局部性表的范围和点查询性能。图12a和12b中的结果与图11中的结果类似。通常，改进的局部性允许更快的二分搜索，因为在这种情况下，最后几次key比较通常可以使用同一数据块中的key。然而，合并迭代器的吞吐量仍然很低，因为密集的键比较控制了搜索时间。与完全二分搜索相比，部分二分搜索的混音效果更好。这是因为改进的局部性减少了对目标段中扫描的惩罚，在目标段中，每个寻道操作中发生的缓存未命中更少。由于强大的局部性加快了底层seek操作，混合点查询性能也得到了提高，如图12c所示。同时，Bloom过滤器的结果保持不变，因为搜索成本主要由误报率和单个表上的搜索成本决定。因此，当有9张以上的表格时，remix效果会优于Bloom过滤器。段大小（D）我们使用不同的段大小（D）进一步评估remix范围查询性能∈  八个表文件上的{16,32,64}）。其他配置参数与之前的实验相同。图13显示了性能结果。当插入二分搜索关闭时，仅搜索操作的吞吐量在不同的Ds中表现出最大的变化。这是因为一段中的线性扫描增加了一个大D的显著成本。另一方面，完全二分搜索的差异变得更小。同时，由于段内的随机访问速度较慢，较大的段大小仍然会导致更高的开销。在Seek+Next50实验中，数据复制控制了执行时间，使用不同的D时没有显著差异。</p>

    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://qkgoalkeeper.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">论文解读</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://qkgoalkeeper.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">论文解读</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://qkgoalkeeper.github.io/post/fast21-zhong%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" data-title="fast21-zhong论文解读" data-tsina="5852167252" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  



</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%981-100" title="leetcode简单题1-100">leetcode简单题1-100<sup>21</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98101-200" title="leetcode简单题101-200">leetcode简单题101-200<sup>25</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98201-300" title="leetcode简单题201-300">leetcode简单题201-300<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be%e7%9b%b8%e5%85%b3" title="区块链相关">区块链相关<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%be%e7%a8%8b" title="大三上数据库课程">大三上数据库课程<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8bweb%e7%bc%96%e7%a8%8b%e8%af%be%e7%a8%8b" title="大三下web编程课程">大三下web编程课程<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e5%9b%9bleetcode%e7%ae%97%e6%b3%95%e5%88%b7%e9%a2%98" title="大四leetcode算法刷题">大四leetcode算法刷题<sup>290</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://qkgoalkeeper.github.io/tags/bfs" title="bfs">bfs<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" title="c&#43;&#43;">c&#43;&#43;<sup>282</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/dfs" title="dfs">dfs<sup>24</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang" title="golang">golang<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/javascript" title="javascript">javascript<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/leetcode" title="leetcode">leetcode<sup>360</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/solidity" title="solidity">solidity<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" title="二分法">二分法<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" title="优先队列">优先队列<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" title="位运算">位运算<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" title="分治法">分治法<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" title="前缀和">前缀和<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" title="动态规划">动态规划<sup>31</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" title="单调队列">单调队列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" title="双指针">双指针<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" title="哈希表">哈希表<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" title="堆">堆<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" title="字典树">字典树<sup>6</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" title="字符串">字符串<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" title="并查集">并查集<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" title="序列化">序列化<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" title="排列">排列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" title="排序">排序<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" title="数学">数学<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" title="栈">栈<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" title="树">树<sup>25</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" title="滑动窗口">滑动窗口<sup>9</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" title="缓存">缓存<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" title="贪心">贪心<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" title="贪心法">贪心法<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" title="链表">链表<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" title="队列">队列<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" title="随机数">随机数<sup>1</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-05">2022年05月</a><span class="archive-list-count">3</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-04">2022年04月</a><span class="archive-list-count">25</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-03">2022年03月</a><span class="archive-list-count">32</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-02">2022年02月</a><span class="archive-list-count">61</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-01">2022年01月</a><span class="archive-list-count">77</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-12">2021年12月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-11">2021年11月</a><span class="archive-list-count">30</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-10">2021年10月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-09">2021年09月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-06">2021年06月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-04">2021年04月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-11">2020年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-08">2020年08月</a><span class="archive-list-count">70</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://qkgoalkeeper.github.io/tags/bfs" style="font-size: 12px;">bfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" style="font-size: 12px;">c&#43;&#43;</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/dfs" style="font-size: 12px;">dfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang" style="font-size: 12px;">golang</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/javascript" style="font-size: 12px;">javascript</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/leetcode" style="font-size: 12px;">leetcode</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/solidity" style="font-size: 12px;">solidity</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" style="font-size: 12px;">二分法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" style="font-size: 12px;">优先队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" style="font-size: 12px;">位运算</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" style="font-size: 12px;">分治法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" style="font-size: 12px;">前缀和</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" style="font-size: 12px;">动态规划</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" style="font-size: 12px;">区块链</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" style="font-size: 12px;">单调队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" style="font-size: 12px;">双指针</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" style="font-size: 12px;">哈希表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" style="font-size: 12px;">堆</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" style="font-size: 12px;">字典树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" style="font-size: 12px;">字符串</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" style="font-size: 12px;">并查集</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" style="font-size: 12px;">序列化</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" style="font-size: 12px;">排列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" style="font-size: 12px;">排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" style="font-size: 12px;">数学</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" style="font-size: 12px;">数据库</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" style="font-size: 12px;">栈</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" style="font-size: 12px;">树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" style="font-size: 12px;">滑动窗口</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" style="font-size: 12px;">王道机试指南</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" style="font-size: 12px;">缓存</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" style="font-size: 12px;">论文解读</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" style="font-size: 12px;">贪心</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" style="font-size: 12px;">贪心法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" style="font-size: 12px;">链表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" style="font-size: 12px;">队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" style="font-size: 12px;">随机数</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  <div class="line">
    <span></span>
    
    <div style='background:no-repeat url("https://qkgoalkeeper.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <section class="info">
    <p>ECNU数据学院在读 <br/> 知乎主页 :https://www.zhihu.com/people/hao-lai-wu-shou-men-yuan <br/>QQ :1421812601</p>
  </section>
  <div class="social-font clearfix">
    <a href='http://weibo.com/qkgoalkeeper' target="_blank" title="weibo"></a>
    <a href='https://twitter.com/coderzh' target="_blank" title="twitter"></a>
    <a href='https://github.com/qkgoalkeeper' target="_blank" title="github"></a>
    <a href='https://www.facebook.com/coderzh' target="_blank" title="facebook"></a>
    <a href='https://www.linkedin.com/coderzh' target="_blank" title="linkedin"></a>
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2022
    
    <a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a>
    
  </p>
</div>
</footer>
  <script src="https://qkgoalkeeper.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/qkgoalkeeper.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://b.bshare.cn/barCode?site=weixin&url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
