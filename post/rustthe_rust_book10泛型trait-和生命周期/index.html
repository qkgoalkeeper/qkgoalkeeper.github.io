<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>rust：the_rust_book（10）泛型、Trait 和生命周期 - qkgoalkeeper&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  
  <meta name="description" content="一.本章任务 每一个编程语言都有高效处理重复概念的工具。在 Rust 中其工具之一就是 泛型（generics）。泛型是具体类型或其他属性的抽象替代。我们">
  
  <meta itemprop="name" content="rust：the_rust_book（10）泛型、Trait 和生命周期 - qkgoalkeeper&#39;s blog">
  <meta itemprop="description" content="一.本章任务 每一个编程语言都有高效处理重复概念的工具。在 Rust 中其工具之一就是 泛型（generics）。泛型是具体类型或其他属性的抽象替代。我们">
  <meta itemprop="image" content="https://qkgoalkeeper.github.io/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://qkgoalkeeper.github.io/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/highlight/styles/github.css">
  <script src="https://qkgoalkeeper.github.io/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/css/style.css">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-175507250-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-175507250-1');
</script>
  

</head>

<body>
  <header>
    <div>
  <div id="imglogo">
    <a href="https://qkgoalkeeper.github.io/"><img src='https://qkgoalkeeper.github.io/img/logo.svg' alt="qkgoalkeeper&#39;s blog" title="qkgoalkeeper&#39;s blog"/></a>
  </div>
  <div id="textlogo">
    <h1 class="site-name"><a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a></h1>
    <h2 class="blog-motto">ECNU数据学院在读</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/about">关于</a></li>
      
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder='Search'>
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://qkgoalkeeper.github.io/post/rustthe_rust_book10%E6%B3%9B%E5%9E%8Btrait-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="rust：the_rust_book（10）泛型、Trait 和生命周期" itemprop="url">rust：the_rust_book（10）泛型、Trait 和生命周期</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://qkgoalkeeper.github.io/" title="qk">qk</a>
    
  </p>
  <p class="article-time">
    <time datetime="2022-07-30 07:55:19 &#43;0800 CST" itemprop="datePublished">2022年07月30日</time>
  </p>
</header>

	<div class="article-content">
    
		<div class="toc-article">
			<strong class="toc-title">文章目录</strong>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#提取函数来减少重复httpskaiserygithubiotrpl-zh-cnch10-00-genericshtml提取函数来减少重复"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html#%E6%8F%90%E5%8F%96%E5%87%BD%E6%95%B0%E6%9D%A5%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D">提取函数来减少重复</a></a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#在函数定义中使用泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml在函数定义中使用泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">在函数定义中使用泛型</a></a></li>
        <li><a href="#结构体定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml结构体定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">结构体定义中的泛型</a></a></li>
        <li><a href="#枚举定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml枚举定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">枚举定义中的泛型</a></a></li>
        <li><a href="#方法定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml方法定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">方法定义中的泛型</a></a></li>
        <li><a href="#泛型代码的性能httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml泛型代码的性能"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%A7%E8%83%BD">泛型代码的性能</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#定义-traithttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml定义-trait"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E5%AE%9A%E4%B9%89-trait">定义 trait</a></a></li>
        <li><a href="#为类型实现-traithttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml为类型实现-trait"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait">为类型实现 trait</a></a></li>
        <li><a href="#默认实现httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml默认实现"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a></a></li>
        <li><a href="#trait-作为参数httpskaiserygithubiotrpl-zh-cnch10-02-traitshtmltrait-作为参数"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">trait 作为参数</a></a></li>
        <li><a href="#返回实现了-trait-的类型httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml返回实现了-trait-的类型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E8%BF%94%E5%9B%9E%E5%AE%9E%E7%8E%B0%E4%BA%86-trait-%E7%9A%84%E7%B1%BB%E5%9E%8B">返回实现了 trait 的类型</a></a></li>
        <li><a href="#使用-trait-bounds-来修复-largest-函数httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml使用-trait-bounds-来修复-largest-函数"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%BD%BF%E7%94%A8-trait-bounds-%E6%9D%A5%E4%BF%AE%E5%A4%8D-largest-%E5%87%BD%E6%95%B0">使用 trait bounds 来修复 <code>largest</code> 函数</a></a></li>
        <li><a href="#使用-trait-bound-有条件地实现方法httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml使用-trait-bound-有条件地实现方法"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%BD%BF%E7%94%A8-trait-bound-%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">使用 trait bound 有条件地实现方法</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#生命周期避免了悬垂引用httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期避免了悬垂引用"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%81%BF%E5%85%8D%E4%BA%86%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8">生命周期避免了悬垂引用</a></a></li>
        <li><a href="#函数中的泛型生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml函数中的泛型生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">函数中的泛型生命周期</a></a></li>
        <li><a href="#生命周期注解语法httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期注解语法"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3%E8%AF%AD%E6%B3%95">生命周期注解语法</a></a></li>
        <li><a href="#函数签名中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml函数签名中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">函数签名中的生命周期注解</a></a></li>
        <li><a href="#深入理解生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml深入理解生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">深入理解生命周期</a></a></li>
        <li><a href="#结构体定义中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml结构体定义中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">结构体定义中的生命周期注解</a></a></li>
        <li><a href="#生命周期省略lifetime-elisionhttpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期省略lifetime-elision"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">生命周期省略（Lifetime Elision）</a></a></li>
        <li><a href="#方法定义中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml方法定义中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">方法定义中的生命周期注解</a></a></li>
        <li><a href="#静态生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml静态生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">静态生命周期</a></a></li>
        <li><a href="#结合泛型类型参数trait-bounds-和生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml结合泛型类型参数trait-bounds-和生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0trait-bounds-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">结合泛型类型参数、trait bounds 和生命周期</a></a></li>
      </ul>
    </li>
    <li><a href="#总结httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml总结"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%80%BB%E7%BB%93">总结</a></a></li>
  </ul>
</nav>
		</div>
    
    <h1 id="一本章任务">一.本章任务</h1>
<p>每一个编程语言都有高效处理重复概念的工具。在 Rust 中其工具之一就是 <strong>泛型</strong>（<em>generics</em>）。泛型是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关联，而不需要在编写和编译代码时知道他们在这里实际上代表什么。</p>
<p>同理为了编写一份可以用于多种具体值的代码，函数并不知道其参数为何值，这时就可以让函数获取泛型而不是像 <code>i32</code> 或 <code>String</code> 这样的具体类型。我们已经使用过第六章的 <code>Option&lt;T&gt;</code>，第八章的 <code>Vec&lt;T&gt;</code> 和 <code>HashMap&lt;K, V&gt;</code>，以及第九章的 <code>Result&lt;T, E&gt;</code> 这些泛型了。本章会探索如何使用泛型定义我们自己的类型、函数和方法！</p>
<p>首先，我们将回顾一下提取函数以减少代码重复的机制。接下来，我们将使用相同的技术，从两个仅参数类型不同的函数中创建一个泛型函数。我们也会讲到结构体和枚举定义中的泛型。</p>
<p>之后，我们讨论 <strong>trait</strong>，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</p>
<p>最后介绍 <strong>生命周期</strong>（<em>lifetimes</em>），它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。</p>
<h2 id="提取函数来减少重复httpskaiserygithubiotrpl-zh-cnch10-00-genericshtml提取函数来减少重复"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-00-generics.html#%E6%8F%90%E5%8F%96%E5%87%BD%E6%95%B0%E6%9D%A5%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D">提取函数来减少重复</a></h2>
<p>在介绍泛型语法之前，首先来回顾一个不使用泛型的处理重复的技术：提取一个函数。当熟悉了这个技术以后，我们将使用相同的机制来提取一个泛型函数！如同你识别出可以提取到函数中重复代码那样，你也会开始识别出能够使用泛型的重复代码。</p>
<p>考虑一下这个寻找列表中最大值的小程序，如示例 10-1 所示：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">largest</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-1：在一个数字列表中寻找最大值的函数</p>
<p>这段代码获取一个整型列表，存放在变量 <code>number_list</code> 中。它将列表的第一项放入了变量 <code>largest</code> 中。接着遍历了列表中的所有数字，如果当前值大于 <code>largest</code> 中储存的值，将 <code>largest</code> 替换为这个值。如果当前值小于或者等于目前为止的最大值，<code>largest</code> 保持不变。当列表中所有值都被考虑到之后，<code>largest</code> 将会是最大值，在这里也就是 100。</p>
<p>如果需要在两个不同的列表中寻找最大值，我们可以重复示例 10-1 中的代码，这样程序中就会存在两段相同逻辑的代码，如示例 10-2 所示：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">largest</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">102</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">6000</span><span class="p">,</span><span class="w"> </span><span class="mi">89</span><span class="p">,</span><span class="w"> </span><span class="mi">54</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">43</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number_list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">largest</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-2：寻找 <strong>两个</strong> 数字列表最大值的代码</p>
<p>虽然代码能够执行，但是重复的代码是冗余且容易出错的，并且意味着当更新逻辑时需要修改多处地方的代码。</p>
<p>为了消除重复，我们可以创建一层抽象，在这个例子中将表现为一个获取任意整型列表作为参数并对其进行处理的函数。这将增加代码的简洁性并让我们将表达和推导寻找列表中最大值的这个概念与使用这个概念的特定位置相互独立。</p>
<p>在示例 10-3 的程序中将寻找最大值的代码提取到了一个叫做 <code>largest</code> 的函数中。这不同于示例 10-1 中的代码只能在一个特定的列表中找到最大的数字，这个程序可以在两个不同的列表中找到最大的数字。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">largest</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">102</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">6000</span><span class="p">,</span><span class="w"> </span><span class="mi">89</span><span class="p">,</span><span class="w"> </span><span class="mi">54</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">43</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-3：抽象后的寻找两个数字列表最大值的代码</p>
<p><code>largest</code> 函数有一个参数 <code>list</code>，它代表会传递给函数的任何具体的 <code>i32</code>值的 slice。函数定义中的 <code>list</code> 代表任何 <code>&amp;[i32]</code>。当调用 <code>largest</code> 函数时，其代码实际上运行于我们传递的特定值上。目前不需要担心 <code>for</code> 循环的语法。这里不是引用了一个 <code>i32</code> 的引用，这里只是模式匹配并表明循环的值应该是 <code>&amp;i32</code>。<a href="https://kaisery.github.io/trpl-zh-cn/ch18-00-patterns.html">第十八章</a> 会详细介绍模式匹配。</p>
<p>总的来说，从示例 10-2 到示例 10-3 中涉及的机制经历了如下几步：</p>
<ol>
<li>找出重复代码。</li>
<li>将重复代码提取到了一个函数中，并在函数签名中指定了代码中的输入和返回值。</li>
<li>将重复代码的两个实例，改为调用函数。</li>
</ol>
<p>在不同的场景使用不同的方式，我们也可以利用相同的步骤和泛型来减少重复代码。与函数体可以在抽象<code>list</code>而不是特定值上操作的方式相同，泛型允许代码对抽象类型进行操作。</p>
<p>如果我们有两个函数，一个寻找一个 <code>i32</code> 值的 slice 中的最大项而另一个寻找 <code>char</code> 值的 slice 中的最大项该怎么办？该如何消除重复呢？让我们拭目以待！</p>
<h1 id="二泛型数据类型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml泛型数据类型">二.<a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">泛型数据类型</a></h1>
<p>我们可以使用泛型为像函数签名或结构体这样的项创建定义，这样它们就可以用于多种不同的具体数据类型。让我们看看如何使用泛型定义函数、结构体、枚举和方法，然后我们将讨论泛型如何影响代码性能。</p>
<h3 id="在函数定义中使用泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml在函数定义中使用泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E5%9C%A8%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B">在函数定义中使用泛型</a></h3>
<p>当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p>
<p>回到 <code>largest</code> 函数，示例 10-4 中展示了两个函数，它们的功能都是寻找 slice 中最大值。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest_i32</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">largest</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">largest_char</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">char</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">char</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">largest</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest_i32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">char_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="sc">&#39;y&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;m&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;q&#39;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest char is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-4：两个函数，不同点只是名称和签名类型</p>
<p><code>largest_i32</code> 函数是从示例 10-3 中摘出来的，它用来寻找 slice 中最大的 <code>i32</code>。<code>largest_char</code> 函数寻找 slice 中最大的 <code>char</code>。因为两者函数体的代码是一样的，我们可以定义一个函数，再引进泛型参数来消除这种重复。</p>
<p>为了参数化新函数中的这些类型，我们也需要为类型参数取个名字，道理和给函数的形参起名一样。任何标识符都可以作为类型参数的名字。这里选用 <code>T</code>，因为传统上来说，Rust 的参数名字都比较短，通常就只有一个字母，同时，Rust 类型名的命名规范是骆驼命名法（CamelCase）。<code>T</code> 作为 “type” 的缩写是大部分 Rust 程序员的首选。</p>
<p>如果要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。为了定义泛型版本的 <code>largest</code> 函数，类型参数声明位于函数名称与参数列表中间的尖括号 <code>&lt;&gt;</code> 中，像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p>可以这样理解这个定义：函数 <code>largest</code> 有泛型类型 <code>T</code>。它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的 slice。<code>largest</code> 函数的返回值类型也是 <code>T</code>。</p>
<p>示例 10-5 中的 <code>largest</code> 函数在它的签名中使用了泛型，统一了两个实现。该示例也展示了如何调用 <code>largest</code> 函数，把 <code>i32</code> 值的 slice 或 <code>char</code> 值的 slice 传给它。请注意这些代码还不能编译，不过稍后在本章会解决这个问题。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">largest</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">char_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="sc">&#39;y&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;m&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;q&#39;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest char is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-5：一个使用泛型参数的 <code>largest</code> 函数定义，尚不能编译</p>
<p>如果现在就编译这个代码，会出现如下错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
</span><span class="go"> --&gt; src/main.rs:5:17
</span><span class="go">  |
</span><span class="go">5 |         if item &gt; largest {
</span><span class="go">  |            ---- ^ ------- T
</span><span class="go">  |            |
</span><span class="go">  |            T
</span><span class="go">  |
</span><span class="go">help: consider restricting type parameter `T`
</span><span class="go">  |
</span><span class="go">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</span><span class="go">  |             ++++++++++++++++++++++
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0369`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>注释中提到了 <code>std::cmp::PartialOrd</code>，这是一个 <em>trait</em>。下一部分会讲到 trait。不过简单来说，这个错误表明 <code>largest</code> 的函数体不能适用于 <code>T</code> 的所有可能的类型。因为在函数体需要比较 <code>T</code> 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 <code>std::cmp::PartialOrd</code> trait 可以实现类型的比较功能（查看附录 C 获取该 trait 的更多信息）。</p>
<p>标准库中定义的 <code>std::cmp::PartialOrd</code> trait 可以实现类型的比较功能。在 <a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">“trait 作为参数”</a> 部分会讲解如何指定泛型实现特定的 trait，不过让我们先探索其他使用泛型参数的方法。</p>
<h3 id="结构体定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml结构体定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">结构体定义中的泛型</a></h3>
<p>同样也可以用 <code>&lt;&gt;</code> 语法来定义结构体，它包含一个或多个泛型参数类型字段。示例 10-6 展示了如何定义和使用一个可以存放任何类型的 <code>x</code> 和 <code>y</code> 坐标值的结构体 <code>Point</code>：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-6：<code>Point</code> 结构体存放了两个 <code>T</code> 类型的值 <code>x</code> 和 <code>y</code></p>
<p>其语法类似于函数定义中使用泛型。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。</p>
<p>注意 <code>Point&lt;T&gt;</code> 的定义中只使用了一个泛型类型，这个定义表明结构体 <code>Point&lt;T&gt;</code> 对于一些类型 <code>T</code> 是泛型的，而且字段 <code>x</code> 和 <code>y</code> <strong>都是</strong> 相同类型的，无论它具体是何类型。如果尝试创建一个有不同类型值的 <code>Point&lt;T&gt;</code> 的实例，像示例 10-7 中的代码就不能编译：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wont_work</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-7：字段 <code>x</code> 和 <code>y</code> 的类型必须相同，因为他们都有相同的泛型类型 <code>T</code></p>
<p>在这个例子中，当把整型值 5 赋值给 <code>x</code> 时，就告诉了编译器这个 <code>Point&lt;T&gt;</code> 实例中的泛型 <code>T</code> 是整型的。接着指定 <code>y</code> 为 4.0，它被定义为与 <code>x</code> 相同类型，就会得到一个像这样的类型不匹配错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0308]: mismatched types
</span><span class="go"> --&gt; src/main.rs:7:38
</span><span class="go">  |
</span><span class="go">7 |     let wont_work = Point { x: 5, y: 4.0 };
</span><span class="go">  |                                      ^^^ expected integer, found floating-point number
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0308`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>如果想要定义一个 <code>x</code> 和 <code>y</code> 可以有不同类型且仍然是泛型的 <code>Point</code> 结构体，我们可以使用多个泛型类型参数。在示例 10-8 中，我们修改 <code>Point</code> 的定义为拥有两个泛型类型 <code>T</code> 和 <code>U</code>。其中字段 <code>x</code> 是 <code>T</code> 类型的，而字段 <code>y</code> 是 <code>U</code> 类型的：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">U</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">both_integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">both_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">integer_and_float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">4.0</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-8：使用两个泛型的 <code>Point</code>，这样 <code>x</code> 和 <code>y</code> 可能是不同类型</p>
<p>现在所有这些 <code>Point</code> 实例都合法了！你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重构，分解成更小的结构。</p>
<h3 id="枚举定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml枚举定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">枚举定义中的泛型</a></h3>
<p>和结构体类似，枚举也可以在成员中存放泛型数据类型。第六章我们曾用过标准库提供的 <code>Option&lt;T&gt;</code> 枚举，这里再回顾一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在这个定义应该更容易理解了。如你所见 <code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举，它有两个成员：<code>Some</code>，它存放了一个类型 <code>T</code> 的值，和不存在任何值的<code>None</code>。通过 <code>Option&lt;T&gt;</code> 枚举可以表达有一个可能的值的抽象概念，同时因为 <code>Option&lt;T&gt;</code> 是泛型的，无论这个可能的值是什么类型都可以使用这个抽象。</p>
<p>枚举也可以拥有多个泛型类型。第九章使用过的 <code>Result</code> 枚举定义就是一个这样的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Result</code> 枚举有两个泛型类型，<code>T</code> 和 <code>E</code>。<code>Result</code> 有两个成员：<code>Ok</code>，它存放一个类型 <code>T</code> 的值，而 <code>Err</code> 则存放一个类型 <code>E</code> 的值。这个定义使得 <code>Result</code> 枚举能很方便的表达任何可能成功（返回 <code>T</code> 类型的值）也可能失败（返回 <code>E</code> 类型的值）的操作。实际上，这就是我们在示例 9-3 用来打开文件的方式：当成功打开文件的时候，<code>T</code> 对应的是 <code>std::fs::File</code> 类型；而当打开文件出现问题时，<code>E</code> 的值则是 <code>std::io::Error</code> 类型。</p>
<p>当你意识到代码中定义了多个结构体或枚举，它们不一样的地方只是其中的值的类型的时候，不妨通过泛型类型来避免重复。</p>
<h3 id="方法定义中的泛型httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml方法定义中的泛型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B">方法定义中的泛型</a></h3>
<p>在为结构体和枚举实现方法时（像第五章那样），一样也可以用泛型。示例 10-9 中展示了示例 10-6 中定义的结构体 <code>Point&lt;T&gt;</code>，和在其上实现的名为 <code>x</code> 的方法。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">x</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">10</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;p.x = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-9：在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用</p>
<p>这里在 <code>Point&lt;T&gt;</code> 上定义了一个叫做 <code>x</code> 的方法来返回字段 <code>x</code> 中数据的引用：</p>
<p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。因为再次声明了泛型，我们可以为泛型参数选择一个与结构体定义中声明的泛型参数所不同的名称，不过依照惯例使用了相同的名称。<code>impl</code> 中编写的方法声明了泛型类型可以定位为任何类型的实例，不管最终替换泛型类型的是何具体类型。</p>
<p>另一个选择是定义方法适用于某些有限制（constraint）的泛型类型。例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。示例 10-10 展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="kt">f32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">distance_from_origin</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">powi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">powi</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="n">sqrt</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-10：构建一个只用于拥有泛型参数 <code>T</code> 的结构体的具体类型的 <code>impl</code> 块</p>
<p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则没有定义此方法。这个方法计算点实例与坐标 (0.0, 0.0) 之间的距离，并使用了只能用于浮点型的数学运算符。</p>
<p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。示例 10-11 中为 <code>Point</code> 结构体使用了泛型类型 <code>X1</code> 和 <code>Y1</code>，为 <code>mixup</code> 方法签名使用了 <code>X2</code> 和 <code>Y2</code> 来使得示例更加清楚。这个方法用 <code>self</code> 的 <code>Point</code> 类型的 <code>x</code> 值（类型 <code>X1</code>）和参数的 <code>Point</code> 类型的 <code>y</code> 值（类型 <code>Y2</code>）来创建一个新 <code>Point</code> 类型的实例：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="o">&lt;</span><span class="n">X1</span><span class="p">,</span><span class="w"> </span><span class="n">Y1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">X1</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">Y1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">X1</span><span class="p">,</span><span class="w"> </span><span class="n">Y1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="o">&lt;</span><span class="n">X1</span><span class="p">,</span><span class="w"> </span><span class="n">Y1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">mixup</span><span class="o">&lt;</span><span class="n">X2</span><span class="p">,</span><span class="w"> </span><span class="n">Y2</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Point</span><span class="o">&lt;</span><span class="n">X2</span><span class="p">,</span><span class="w"> </span><span class="n">Y2</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="o">&lt;</span><span class="n">X1</span><span class="p">,</span><span class="w"> </span><span class="n">Y2</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">other</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mf">10.4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="s">&#34;Hello&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="o">&#39;</span><span class="na">c</span><span class="o">&#39;</span> <span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">mixup</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;p3.x = {}, p3.y = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-11：方法使用了与结构体定义中不同类型的泛型</p>
<p>在 <code>main</code> 函数中，定义了一个有 <code>i32</code> 类型的 <code>x</code>（其值为 <code>5</code>）和 <code>f64</code> 的 <code>y</code>（其值为 <code>10.4</code>）的 <code>Point</code>。<code>p2</code> 则是一个有着字符串 slice 类型的 <code>x</code>（其值为 <code>&quot;Hello&quot;</code>）和 <code>char</code> 类型的 <code>y</code>（其值为<code>c</code>）的 <code>Point</code>。在 <code>p1</code> 上以 <code>p2</code> 作为参数调用 <code>mixup</code> 会返回一个 <code>p3</code>，它会有一个 <code>i32</code> 类型的 <code>x</code>，因为 <code>x</code> 来自 <code>p1</code>，并拥有一个 <code>char</code> 类型的 <code>y</code>，因为 <code>y</code> 来自 <code>p2</code>。<code>println!</code> 会打印出 <code>p3.x = 5, p3.y = c</code>。</p>
<p>这个例子的目的是展示一些泛型通过 <code>impl</code> 声明而另一些通过方法定义声明的情况。这里泛型参数 <code>X1</code> 和 <code>Y1</code> 声明于 <code>impl</code> 之后，因为他们与结构体定义相对应。而泛型参数 <code>X2</code> 和 <code>Y2</code> 声明于 <code>fn mixup</code> 之后，因为他们只是相对于方法本身的。</p>
<h3 id="泛型代码的性能httpskaiserygithubiotrpl-zh-cnch10-01-syntaxhtml泛型代码的性能"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-01-syntax.html#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%80%A7%E8%83%BD">泛型代码的性能</a></h3>
<p>在阅读本部分内容的同时，你可能会好奇使用泛型类型参数是否会有运行时消耗。好消息是：Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</p>
<p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p>
<p>编译器所做的工作正好与示例 10-5 中我们创建泛型函数的步骤相反。编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。</p>
<p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一个对应 <code>i32</code> 另一个对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p>
<p>编译器生成的单态化版本的代码看起来像这样，并包含将泛型 <code>Option&lt;T&gt;</code> 替换为编译器创建的具体定义后的用例代码：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Option_i32</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Option_f64</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="kt">f64</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Option_i32</span>::<span class="nb">Some</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">float</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Option_f64</span>::<span class="nb">Some</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p>
<h1 id="三trait定义共同行为httpskaiserygithubiotrpl-zh-cnch10-02-traitshtmltrait定义共同行为">三.<a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait%E5%AE%9A%E4%B9%89%E5%85%B1%E5%90%8C%E8%A1%8C%E4%B8%BA">Trait：定义共同行为</a></h1>
<p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 <em>trait bounds</em> 指定泛型是任何拥有特定行为的类型。</p>
<blockquote>
<p>注意：<em>trait</em> 类似于其他语言中的常被称为 <strong>接口</strong>（<em>interfaces</em>）的功能，虽然有一些不同。</p>
</blockquote>
<h3 id="定义-traithttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml定义-trait"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E5%AE%9A%E4%B9%89-trait">定义 trait</a></h3>
<p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p>
<p>例如，这里有多个存放了不同类型和属性文本的结构体：结构体 <code>NewsArticle</code> 用于存放发生于世界各地的新闻故事，而结构体 <code>Tweet</code> 最多只能存放 280 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。</p>
<p>我们想要创建一个名为 <code>aggregator</code> 的多媒体聚合库用来显示可能储存在 <code>NewsArticle</code> 或 <code>Tweet</code> 实例中的数据的总结。每一个结构体都需要的行为是他们是能够被总结的，这样的话就可以调用实例的 <code>summarize</code> 方法来请求总结。示例 10-12 中展示了一个表现这个概念的公有 <code>Summary</code> trait 的定义：</p>
<p>文件名: src/lib.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-12：<code>Summary</code> trait 定义，它包含由 <code>summarize</code> 方法提供的行为</p>
<p>这里使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summary</code>。我们也声明 <code>trait</code> 为 <code>pub</code> 以便依赖这个 crate 的 crate 也可以使用这个 trait，正如我们见过的一些示例一样。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summary</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p>
<p>trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。</p>
<h3 id="为类型实现-traithttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml为类型实现-trait"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0-trait">为类型实现 trait</a></h3>
<p>现在我们定义了 <code>Summary</code> trait 的签名，接着就可以在多媒体聚合库中实现这个类型了。示例 10-13 中展示了 <code>NewsArticle</code> 结构体上 <code>Summary</code> trait 的一个实现，它使用标题、作者和创建的位置作为 <code>summarize</code> 的返回值。对于 <code>Tweet</code> 结构体，我们选择将 <code>summarize</code> 定义为用户名后跟推文的全部文本作为返回值，并假设推文内容已经被限制为 280 字符以内。</p>
<p>文件名: src/lib.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">headline</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">location</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">author</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">content</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{}, by {} ({})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">headline</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">author</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">location</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">username</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">content</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">reply</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">retweet</span>: <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">username</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">content</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-13：在 <code>NewsArticle</code> 和 <code>Tweet</code> 类型上实现 <code>Summary</code> trait</p>
<p>在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p>
<p>现在库在 <code>NewsArticle</code> 和 <code>Tweet</code> 上实现了<code>Summary</code> trait，crate 的用户可以像调用常规方法一样调用 <code>NewsArticle</code> 和 <code>Tweet</code> 实例的 trait 方法了。唯一的区别是 trait 必须和类型一起引入作用域以便使用额外的 trait 方法。这是一个二进制 crate 如何利用 <code>aggregator</code> 库 crate 的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">aggregator</span>::<span class="p">{</span><span class="n">Summary</span><span class="p">,</span><span class="w"> </span><span class="n">Tweet</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tweet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;horse_ebooks&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;of course, as you probably already know, people&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">reply</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">retweet</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;1 new tweet: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">tweet</span><span class="p">.</span><span class="n">summarize</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这会打印出 <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>。</p>
<p>其他依赖 <code>aggregator</code> crate 的 crate 也可以将 <code>Summary</code> 引入作用域以便为其自己的类型实现该 trait。实现 trait 时需要注意的一个限制是，只有当至少一个 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。例如，可以为 <code>aggregator</code> crate 的自定义类型 <code>Tweet</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>Tweet</code> 类型位于 <code>aggregator</code> crate 本地的作用域中。类似地，也可以在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于 <code>aggregator</code> crate 本地作用域中。</p>
<p>但是不能为外部类型实现外部 trait。例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中。这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p>
<h3 id="默认实现httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml默认实现"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0">默认实现</a></h3>
<p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p>
<p>示例 10-14 中展示了如何为 <code>Summary</code> trait 的 <code>summarize</code> 方法指定一个默认的字符串值，而不是像示例 10-12 中那样只是定义方法签名：</p>
<p>文件名: src/lib.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;(Read more...)&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-14：<code>Summary</code> trait 的定义，带有一个 <code>summarize</code> 方法的默认实现</p>
<p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle {}</code> 指定一个空的 <code>impl</code> 块。</p>
<p>虽然我们不再直接为 <code>NewsArticle</code> 定义 <code>summarize</code> 方法了，但是我们提供了一个默认实现并且指定 <code>NewsArticle</code> 实现 <code>Summary</code> trait。因此，我们仍然可以对 <code>NewsArticle</code> 实例调用 <code>summarize</code> 方法，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">article</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">headline</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Penguins win the Stanley Cup Championship!&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">location</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Pittsburgh, PA, USA&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">author</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Iceburgh&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="err">&#34;</span><span class="n">The</span><span class="w"> </span><span class="n">Pittsburgh</span><span class="w"> </span><span class="n">Penguins</span><span class="w"> </span><span class="n">once</span><span class="w"> </span><span class="n">again</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">             </span><span class="n">hockey</span><span class="w"> </span><span class="n">team</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">NHL</span><span class="p">.</span><span class="s">&#34;,
</span><span class="s">        ),
</span><span class="s">    };
</span><span class="s">
</span><span class="s">    println!(&#34;</span><span class="n">New</span><span class="w"> </span><span class="n">article</span><span class="w"> </span><span class="n">available</span><span class="o">!</span><span class="w"> </span><span class="p">{}</span><span class="err">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">article</span><span class="p">.</span><span class="n">summarize</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>这段代码会打印 <code>New article available! (Read more...)</code>。</p>
<p>为 <code>summarize</code> 创建默认实现并不要求对示例 10-13 中 <code>Tweet</code> 上的 <code>Summary</code> 实现做任何改变。其原因是重载一个默认实现的语法与实现没有默认实现的 trait 方法的语法一样。</p>
<p>默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容。例如，我们可以定义 <code>Summary</code> trait，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize_author</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;(Read more from {}...)&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">summarize_author</span><span class="p">())</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了使用这个版本的 <code>Summary</code>，只需在实现 trait 时定义 <code>summarize_author</code> 即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">summarize_author</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">format!</span><span class="p">(</span><span class="s">&#34;@{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">username</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一旦定义了 <code>summarize_author</code>，我们就可以对 <code>Tweet</code> 结构体的实例调用 <code>summarize</code> 了，而 <code>summarize</code> 的默认实现会调用我们提供的 <code>summarize_author</code> 定义。因为实现了 <code>summarize_author</code>，<code>Summary</code> trait 就提供了 <code>summarize</code> 方法的功能，且无需编写更多的代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tweet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;horse_ebooks&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;of course, as you probably already know, people&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">reply</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">retweet</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;1 new tweet: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">tweet</span><span class="p">.</span><span class="n">summarize</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>这会打印出 <code>1 new tweet: (Read more from @horse_ebooks...)</code>。</p>
<p>注意无法从相同方法的重载实现中调用默认方法。</p>
<h3 id="trait-作为参数httpskaiserygithubiotrpl-zh-cnch10-02-traitshtmltrait-作为参数"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">trait 作为参数</a></h3>
<p>知道了如何定义 trait 和在类型上实现这些 trait 之后，我们可以探索一下如何使用 trait 来接受多种不同类型的参数。</p>
<p>例如在示例 10-13 中为 <code>NewsArticle</code> 和 <code>Tweet</code> 类型实现了 <code>Summary</code> trait。我们可以定义一个函数 <code>notify</code> 来调用其参数 <code>item</code> 上的 <code>summarize</code> 方法，该参数是实现了 <code>Summary</code> trait 的某种类型。为此可以使用 <code>impl Trait</code> 语法，像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Breaking news! {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">summarize</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对于 <code>item</code> 参数，我们指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。我们可以传递任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的实例来调用 <code>notify</code>。任何用其它如 <code>String</code> 或 <code>i32</code> 的类型调用该函数的代码都不能编译，因为它们没有实现 <code>Summary</code>。</p>
<h4 id="trait-bound-语法httpskaiserygithubiotrpl-zh-cnch10-02-traitshtmltrait-bound-语法"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#trait-bound-%E8%AF%AD%E6%B3%95">Trait Bound 语法</a></h4>
<p><code>impl Trait</code> 语法适用于直观的例子，它实际上是一种较长形式语法的语法糖。我们称为 <em>trait bound</em>，它看起来像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Breaking news! {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">summarize</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这与之前的例子相同，不过稍微冗长了一些。trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。</p>
<p><code>impl Trait</code> 很方便，适用于短小的例子。trait bound 则适用于更复杂的场景。例如，可以获取两个实现了 <code>Summary</code> 的参数。使用 <code>impl Trait</code> 的语法看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item1</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">,</span><span class="w"> </span><span class="n">item2</span>: <span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item1</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">item2</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p>泛型 <code>T</code> 被指定为 <code>item1</code> 和 <code>item2</code> 的参数限制，如此传递给参数 <code>item1</code> 和 <code>item2</code> 值的具体类型必须一致。</p>
<h4 id="通过--指定多个-trait-boundhttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml通过--指定多个-trait-bound"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E9%80%9A%E8%BF%87--%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA-trait-bound">通过 <code>+</code> 指定多个 trait bound</a></h4>
<p>如果 <code>notify</code> 需要显示 <code>item</code> 的格式化形式，同时也要使用 <code>summarize</code> 方法，那么 <code>item</code> 就需要同时实现两个不同的 trait：<code>Display</code> 和 <code>Summary</code>。这可以通过 <code>+</code> 语法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="k">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p><code>+</code> 语法也适用于泛型的 trait bound：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">notify</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Summary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p>通过指定这两个 trait bound，<code>notify</code> 的函数体可以调用 <code>summarize</code> 并使用 <code>{}</code> 来格式化 <code>item</code>。</p>
<h4 id="通过-where-简化-trait-boundhttpskaiserygithubiotrpl-zh-cnch10-02-traitshtml通过-where-简化-trait-bound"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E9%80%9A%E8%BF%87-where-%E7%AE%80%E5%8C%96-trait-bound">通过 <code>where</code> 简化 trait bound</a></h4>
<p>然而，使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>还可以像这样使用 <code>where</code> 从句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">u</span>: <span class="kp">&amp;</span><span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span>
    <span class="nc">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">,</span><span class="w">
</span><span class="w">          </span><span class="n">U</span>: <span class="nb">Clone</span> <span class="o">+</span><span class="w"> </span><span class="n">Debug</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span></code></pre></div><p>这个函数签名就显得不那么杂乱，函数名、参数列表和返回值类型都离得很近，看起来跟没有那么多 trait bounds 的函数很像。</p>
<h3 id="返回实现了-trait-的类型httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml返回实现了-trait-的类型"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E8%BF%94%E5%9B%9E%E5%AE%9E%E7%8E%B0%E4%BA%86-trait-%E7%9A%84%E7%B1%BB%E5%9E%8B">返回实现了 trait 的类型</a></h3>
<p>也可以在返回值中使用 <code>impl Trait</code> 语法，来返回实现了某个 trait 的类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Tweet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;horse_ebooks&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="s">&#34;of course, as you probably already know, people&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">reply</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">retweet</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型。在这个例子中 <code>returns_summarizable</code> 返回了一个 <code>Tweet</code>，不过调用方并不知情。</p>
<p>返回一个只是指定了需要实现的 trait 的类型的能力在闭包和迭代器场景十分的有用，第十三章会介绍它们。闭包和迭代器创建只有编译器知道的类型，或者是非常非常长的类型。<code>impl Trait</code> 允许你简单的指定函数返回一个 <code>Iterator</code> 而无需写出实际的冗长的类型。</p>
<p>不过这只适用于返回单一类型的情况。例如，这段代码的返回值类型指定为返回 <code>impl Summary</code>，但是返回了 <code>NewsArticle</code> 或 <code>Tweet</code> 就行不通：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">(</span><span class="n">switch</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Summary</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">switch</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">NewsArticle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">headline</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="s">&#34;Penguins win the Stanley Cup Championship!&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">location</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Pittsburgh, PA, USA&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">author</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Iceburgh&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">content</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="err">&#34;</span><span class="n">The</span><span class="w"> </span><span class="n">Pittsburgh</span><span class="w"> </span><span class="n">Penguins</span><span class="w"> </span><span class="n">once</span><span class="w"> </span><span class="n">again</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">                 </span><span class="n">hockey</span><span class="w"> </span><span class="n">team</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">NHL</span><span class="p">.</span><span class="s">&#34;,
</span><span class="s">            ),
</span><span class="s">        }
</span><span class="s">    } else {
</span><span class="s">        Tweet {
</span><span class="s">            username: String::from(&#34;</span><span class="n">horse_ebooks</span><span class="s">&#34;),
</span><span class="s">            content: String::from(
</span><span class="s">                &#34;</span><span class="n">of</span><span class="w"> </span><span class="n">course</span><span class="p">,</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">probably</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">know</span><span class="p">,</span><span class="w"> </span><span class="n">people</span><span class="err">&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">reply</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">retweet</span>: <span class="nc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里尝试返回 <code>NewsArticle</code> 或 <code>Tweet</code>。这不能编译，因为 <code>impl Trait</code> 工作方式的限制。第十七章的 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#%E4%B8%BA%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%80%8C%E8%AE%BE%E8%AE%A1%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1">“为使用不同类型的值而设计的 trait 对象”</a> 部分会介绍如何编写这样一个函数。</p>
<h3 id="使用-trait-bounds-来修复-largest-函数httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml使用-trait-bounds-来修复-largest-函数"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%BD%BF%E7%94%A8-trait-bounds-%E6%9D%A5%E4%BF%AE%E5%A4%8D-largest-%E5%87%BD%E6%95%B0">使用 trait bounds 来修复 <code>largest</code> 函数</a></h3>
<p>现在你知道了如何使用泛型参数 trait bound 来指定所需的行为。让我们回到实例 10-5 修复使用泛型类型参数的 <code>largest</code> 函数定义！回顾一下，最后尝试编译代码时出现的错误是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
</span><span class="go"> --&gt; src/main.rs:5:17
</span><span class="go">  |
</span><span class="go">5 |         if item &gt; largest {
</span><span class="go">  |            ---- ^ ------- T
</span><span class="go">  |            |
</span><span class="go">  |            T
</span><span class="go">  |
</span><span class="go">help: consider restricting type parameter `T`
</span><span class="go">  |
</span><span class="go">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</span><span class="go">  |             ++++++++++++++++++++++
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0369`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>在 <code>largest</code> 函数体中我们想要使用大于运算符（<code>&gt;</code>）比较两个 <code>T</code> 类型的值。这个运算符被定义为标准库中 trait <code>std::cmp::PartialOrd</code> 的一个默认方法。所以需要在 <code>T</code> 的 trait bound 中指定 <code>PartialOrd</code>，这样 <code>largest</code> 函数可以用于任何可以比较大小的类型的 slice。因为 <code>PartialOrd</code> 位于 prelude 中所以并不需要手动将其引入作用域。将 <code>largest</code> 的签名修改为如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></code></pre></div><p>但是如果编译代码的话，会出现一些不同的错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0508]: cannot move out of type `[T]`, a non-copy slice
</span><span class="go"> --&gt; src/main.rs:2:23
</span><span class="go">  |
</span><span class="go">2 |     let mut largest = list[0];
</span><span class="go">  |                       ^^^^^^^
</span><span class="go">  |                       |
</span><span class="go">  |                       cannot move out of here
</span><span class="go">  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
</span><span class="go">  |                       help: consider borrowing here: `&amp;list[0]`
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">error[E0507]: cannot move out of a shared reference
</span><span class="go"> --&gt; src/main.rs:4:18
</span><span class="go">  |
</span><span class="go">4 |     for &amp;item in list {
</span><span class="go">  |         -----    ^^^^
</span><span class="go">  |         ||
</span><span class="go">  |         |data moved here
</span><span class="go">  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
</span><span class="go">  |         help: consider removing the `&amp;`: `item`
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">Some errors have detailed explanations: E0507, E0508.
</span><span class="go">For more information about an error, try `rustc --explain E0507`.
</span><span class="go">error: could not compile `chapter10` due to 2 previous errors
</span></code></pre></div><p>错误的核心是 <code>cannot move out of type [T], a non-copy slice</code>，对于非泛型版本的 <code>largest</code> 函数，我们只尝试了寻找最大的 <code>i32</code> 和 <code>char</code>。正如第四章 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html#%E5%8F%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D">“只在栈上的数据：拷贝”</a> 部分讨论过的，像 <code>i32</code> 和 <code>char</code> 这样的类型是已知大小的并可以储存在栈上，所以他们实现了 <code>Copy</code> trait。当我们将 <code>largest</code> 函数改成使用泛型后，现在 <code>list</code> 参数的类型就有可能是没有实现 <code>Copy</code> trait 的。这意味着我们可能不能将 <code>list[0]</code> 的值移动到 <code>largest</code> 变量中，这导致了上面的错误。</p>
<p>为了只对实现了 <code>Copy</code> 的类型调用这些代码，可以在 <code>T</code> 的 trait bounds 中增加 <code>Copy</code>！示例 10-15 中展示了一个可以编译的泛型版本的 <code>largest</code> 函数的完整代码，只要传递给 <code>largest</code> 的 slice 值的类型实现了 <code>PartialOrd</code> <strong>和</strong> <code>Copy</code> 这两个 trait，例如 <code>i32</code> 和 <code>char</code>：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">largest</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span> <span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">item</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">largest</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">number_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">65</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">number_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest number is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">char_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="sc">&#39;y&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;m&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;q&#39;</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">largest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">char_list</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest char is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-15：一个可以用于任何实现了 <code>PartialOrd</code> 和 <code>Copy</code> trait 的泛型的 <code>largest</code> 函数</p>
<p>如果并不希望限制 <code>largest</code> 函数只能用于实现了 <code>Copy</code> trait 的类型，我们可以在 <code>T</code> 的 trait bounds 中指定 <code>Clone</code> 而不是 <code>Copy</code>。并克隆 slice 的每一个值使得 <code>largest</code> 函数拥有其所有权。使用 <code>clone</code> 函数意味着对于类似 <code>String</code> 这样拥有堆上数据的类型，会潜在的分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p>
<p>另一种 <code>largest</code> 的实现方式是返回在 slice 中 <code>T</code> 值的引用。如果我们将函数返回值从 <code>T</code> 改为 <code>&amp;T</code> 并改变函数体使其能够返回一个引用，我们将不需要任何 <code>Clone</code> 或 <code>Copy</code> 的 trait bounds 而且也不会有任何的堆分配。尝试自己实现这种替代解决方式吧！如果你无法摆脱与生命周期有关的错误，请继续阅读：接下来的 “生命周期与引用有效性” 部分会详细的说明，不过生命周期对于解决这些挑战来说并不是必须的。</p>
<h3 id="使用-trait-bound-有条件地实现方法httpskaiserygithubiotrpl-zh-cnch10-02-traitshtml使用-trait-bound-有条件地实现方法"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-02-traits.html#%E4%BD%BF%E7%94%A8-trait-bound-%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">使用 trait bound 有条件地实现方法</a></h3>
<p>通过使用带有 trait bound 的泛型参数的 <code>impl</code> 块，可以有条件地只为那些实现了特定 trait 的类型实现方法。例如，示例 10-16 中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法并返回一个 <code>Pair&lt;T&gt;</code> 的实例（回忆一下第五章的 <a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95">&ldquo;定义方法&rdquo;</a> 部分，<code>Self</code> 是一个 <code>impl</code> 块类型的类型别名（type alias），在这里是 <code>Pair&lt;T&gt;</code>）。不过在下一个 <code>impl</code> 块中，只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait （来允许比较） <strong>和</strong> <code>Display</code> trait （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Display</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_display</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest member is x = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The largest member is y = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-16：根据 trait bound 在泛型上有条件的实现方法</p>
<p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 <code>Display</code> trait 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span></code></pre></div><p>blanket implementation 会出现在 trait 文档的 “Implementers” 部分。</p>
<p>trait 和 trait bound 让我们使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为。因为我们向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们尝试调用一个类型并没有实现的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能。</p>
<p>这里还有一种泛型，我们一直在使用它甚至都没有察觉它的存在，这就是 <strong>生命周期</strong>（<em>lifetimes</em>）。不同于其他泛型帮助我们确保类型拥有期望的行为，生命周期则有助于确保引用在我们需要他们的时候一直有效。让我们学习生命周期是如何做到这些的。</p>
<h1 id="四生命周期确保引用有效httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期确保引用有效">四.<a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A1%AE%E4%BF%9D%E5%BC%95%E7%94%A8%E6%9C%89%E6%95%88">生命周期确保引用有效</a></h1>
<p>当在第四章讨论 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8">“引用和借用”</a> 部分时，我们遗漏了一个重要的细节：Rust 中的每一个引用都有其 <strong>生命周期</strong>（<em>lifetime</em>），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p>
<p>生命周期注解甚至不是一个大部分语言都有的概念，所以这可能感觉起来有些陌生。虽然本章不可能涉及到它全部的内容，我们会讲到一些通常你可能会遇到的生命周期语法以便你熟悉这个概念。</p>
<h3 id="生命周期避免了悬垂引用httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期避免了悬垂引用"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%81%BF%E5%85%8D%E4%BA%86%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8">生命周期避免了悬垂引用</a></h3>
<p>生命周期的主要目标是避免悬垂引用，后者会导致程序引用了非预期引用的数据。考虑一下示例 10-17 中的程序，它有一个外部作用域和一个内部作用域.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;r: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-17：尝试使用离开作用域的值的引用</p>
<blockquote>
<p>注意：示例 10-17、10-18 和 10-24 中声明了没有初始值的变量，所以这些变量存在于外部作用域。这乍看之下好像和 Rust 不允许存在空值相冲突。然而如果尝试在给它一个值之前使用这个变量，会出现一个编译时错误，这就说明了 Rust 确实不允许空值。</p>
</blockquote>
<p>外部作用域声明了一个没有初值的变量 <code>r</code>，而内部作用域声明了一个初值为 5 的变量<code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 的值设置为一个 <code>x</code> 的引用。接着在内部作用域结束后，尝试打印出 <code>r</code> 的值。这段代码不能编译因为 <code>r</code> 引用的值在尝试使用之前就离开了作用域。如下是错误信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0597]: `x` does not live long enough
</span><span class="go">  --&gt; src/main.rs:7:17
</span><span class="go">   |
</span><span class="go">7  |             r = &amp;x;
</span><span class="go">   |                 ^^ borrowed value does not live long enough
</span><span class="go">8  |         }
</span><span class="go">   |         - `x` dropped here while still borrowed
</span><span class="go">9  | 
</span><span class="go">10 |         println!(&#34;r: {}&#34;, r);
</span><span class="go">   |                           - borrow later used here
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0597`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>变量 <code>x</code> 并没有 “存在的足够久”。其原因是 <code>x</code> 在到达第 7 行内部作用域结束时就离开了作用域。不过 <code>r</code> 在外部作用域仍是有效的；作用域越大我们就说它 “存在的越久”。如果 Rust 允许这段代码工作，<code>r</code> 将会引用在 <code>x</code> 离开作用域时被释放的内存，这时尝试对 <code>r</code> 做任何操作都不能正常工作。那么 Rust 是如何决定这段代码是不被允许的呢？这得益于借用检查器。</p>
<h4 id="借用检查器httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml借用检查器"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5%E5%99%A8">借用检查器</a></h4>
<p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。示例 10-18 展示了与示例 10-17 相同的例子不过带有变量生命周期的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">                </span><span class="c1">// ---------+-- &#39;a
</span><span class="c1"></span><span class="w">                              </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">        </span><span class="p">{</span><span class="w">                     </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">        </span><span class="c1">// -+-- &#39;b  |
</span><span class="c1"></span><span class="w">            </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">           </span><span class="c1">//  |       |
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">                     </span><span class="c1">// -+       |
</span><span class="c1"></span><span class="w">                              </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;r: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"> </span><span class="c1">//          |
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">                         </span><span class="c1">// ---------+
</span></code></pre></div><p>示例 10-18：<code>r</code> 和 <code>x</code> 的生命周期注解，分别叫做 <code>'a</code> 和 <code>'b</code></p>
<p>这里将 <code>r</code> 的生命周期标记为 <code>'a</code> 并将 <code>x</code> 的生命周期标记为 <code>'b</code>。如你所见，内部的 <code>'b</code> 块要比外部的生命周期 <code>'a</code> 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 <code>r</code> 拥有生命周期 <code>'a</code>，不过它引用了一个拥有生命周期 <code>'b</code> 的对象。程序被拒绝编译，因为生命周期 <code>'b</code> 比生命周期 <code>'a</code> 要小：被引用的对象比它的引用者存在的时间更短。</p>
<p>让我们看看示例 10-19 中这个并没有产生悬垂引用且可以正确编译的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">            </span><span class="c1">// ----------+-- &#39;b
</span><span class="c1"></span><span class="w">                              </span><span class="c1">//           |
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">           </span><span class="c1">// --+-- &#39;a  |
</span><span class="c1"></span><span class="w">                              </span><span class="c1">//   |       |
</span><span class="c1"></span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;r: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"> </span><span class="c1">//   |       |
</span><span class="c1"></span><span class="w">                              </span><span class="c1">// --+       |
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">                         </span><span class="c1">// ----------+
</span></code></pre></div><p>示例 10-19：一个有效的引用，因为数据比引用有着更长的生命周期</p>
<p>这里 <code>x</code> 拥有生命周期 <code>'b</code>，比 <code>'a</code> 要大。这就意味着 <code>r</code> 可以引用 <code>x</code>：Rust 知道 <code>r</code> 中的引用在 <code>x</code> 有效的时候也总是有效的。</p>
<p>现在我们已经在一个具体的例子中展示了引用的生命周期位于何处，并讨论了 Rust 如何分析生命周期来保证引用总是有效的，接下来让我们聊聊在函数的上下文中参数和返回值的泛型生命周期。</p>
<h3 id="函数中的泛型生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml函数中的泛型生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">函数中的泛型生命周期</a></h3>
<p>让我们来编写一个返回两个字符串 slice 中较长者的函数。这个函数获取两个字符串 slice 并返回一个字符串 slice。一旦我们实现了 <code>longest</code> 函数，示例 10-20 中的代码应该会打印出 <code>The longest string is abcd</code>：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;abcd&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;xyz&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">string1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">string2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The longest string is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-20：<code>main</code> 函数调用 <code>longest</code> 函数来寻找两个字符串 slice 中较长的一个</p>
<p>注意这个函数获取作为引用的字符串 slice，因为我们不希望 <code>longest</code> 函数获取参数的所有权。参考之前第四章中的 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-03-slices.html#%E5%AD%97%E7%AC%A6%E4%B8%B2-slice-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">“字符串 slice 作为参数”</a> 部分中更多关于为什么示例 10-20 的参数正符合我们期望的讨论。</p>
<p>如果尝试像示例 10-21 中那样实现 <code>longest</code> 函数，它并不能编译：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-21：一个 <code>longest</code> 函数的实现，它返回两个字符串 slice 中较长者，现在还不能编译</p>
<p>相应地会出现如下有关生命周期的错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0106]: missing lifetime specifier
</span><span class="go"> --&gt; src/main.rs:9:33
</span><span class="go">  |
</span><span class="go">9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</span><span class="go">  |               ----     ----     ^ expected named lifetime parameter
</span><span class="go">  |
</span><span class="go">  = help: this function&#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</span><span class="go">help: consider introducing a named lifetime parameter
</span><span class="go">  |
</span><span class="go">9 | fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {
</span><span class="go">  |           ++++     ++          ++          ++
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0106`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>提示文本揭示了返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 <code>x</code> 或 <code>y</code>。事实上我们也不知道，因为函数体中 <code>if</code> 块返回一个 <code>x</code> 的引用而 <code>else</code> 块返回一个 <code>y</code> 的引用！</p>
<p>当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 <code>if</code> 还是 <code>else</code> 会被执行。我们也不知道传入的引用的具体生命周期，所以也就不能像示例 10-18 和 10-19 那样通过观察作用域来确定返回的引用是否总是有效。借用检查器自身同样也无法确定，因为它不知道 <code>x</code> 和 <code>y</code> 的生命周期是如何与返回值的生命周期相关联的。为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。</p>
<h3 id="生命周期注解语法httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期注解语法"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3%E8%AF%AD%E6%B3%95">生命周期注解语法</a></h3>
<p>生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。</p>
<p>生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（<code>'</code>）开头，其名称通常全是小写，类似于泛型其名称非常短。<code>'a</code> 是大多数人默认使用的名称。生命周期参数注解位于引用的 <code>&amp;</code> 之后，并有一个空格来将引用类型与生命周期注解分隔开。</p>
<p>这里有一些例子：我们有一个没有生命周期参数的 <code>i32</code> 的引用，一个有叫做 <code>'a</code> 的生命周期参数的 <code>i32</code> 的引用，和一个生命周期也是 <code>'a</code> 的 <code>i32</code> 的可变引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="o">&amp;</span><span class="kt">i32</span><span class="w">        </span><span class="c1">// 引用
</span><span class="c1"></span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">i32</span><span class="w">     </span><span class="c1">// 带有显式生命周期的引用
</span><span class="c1"></span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="c1">// 带有显式生命周期的可变引用
</span></code></pre></div><p>单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。例如如果函数有一个生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>first</code>。还有另一个同样是生命周期 <code>'a</code> 的 <code>i32</code> 的引用的参数 <code>second</code>。这两个生命周期注解意味着引用 <code>first</code> 和 <code>second</code> 必须与这泛型生命周期存在得一样久。</p>
<h3 id="函数签名中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml函数签名中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">函数签名中的生命周期注解</a></h3>
<p>现在来看看 <code>longest</code> 函数的上下文中的生命周期。就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中。 在这个签名中我们想要表达的限制是所有（两个）参数和返回的引用的生命周期是相关的，也就是这两个参数和返回的引用存活的一样久。就像示例 10-22 中在每个引用中都加上了 <code>'a</code> 那样：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-22：<code>longest</code> 函数定义指定了签名中所有的引用必须有相同的生命周期 <code>'a</code></p>
<p>这段代码能够编译并会产生我们希望得到的示例 10-20 中的 <code>main</code> 函数的结果。</p>
<p>现在函数签名表明对于某些生命周期 <code>'a</code>，函数会获取两个参数，他们都是与生命周期 <code>'a</code> 存在的一样长的字符串 slice。函数会返回一个同样也与生命周期 <code>'a</code> 存在的一样长的字符串 slice。它的实际含义是 <code>longest</code> 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。这些关系就是我们希望 Rust 分析代码时所使用的。</p>
<p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 <code>longest</code> 函数并不需要知道 <code>x</code> 和 <code>y</code> 具体会存在多久，而只需要知道有某个可以被 <code>'a</code> 替代的作用域将会满足这个签名。</p>
<p>当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。生命周期注解成为了函数约定的一部分，非常像签名中的类型。让函数签名包含生命周期约定意味着 Rust 编译器的工作变得更简单了。如果函数注解有误或者调用方法不对，编译器错误可以更准确地指出代码和限制的部分。如果不这么做的话，Rust 编译会对我们期望的生命周期关系做更多的推断，这样编译器可能只能指出离出问题地方很多步之外的代码。</p>
<p>当具体的引用被传递给 <code>longest</code> 时，被 <code>'a</code> 所替代的具体生命周期是 <code>x</code> 的作用域与 <code>y</code> 的作用域相重叠的那一部分。换一种说法就是泛型生命周期 <code>'a</code> 的具体生命周期等同于 <code>x</code> 和 <code>y</code> 的生命周期中较小的那一个。因为我们用相同的生命周期参数 <code>'a</code> 标注了返回的引用值，所以返回的引用值就能保证在 <code>x</code> 和 <code>y</code> 中较短的那个生命周期结束之前保持有效。</p>
<p>让我们看看如何通过传递拥有不同具体生命周期的引用来限制 <code>longest</code> 函数的使用。示例 10-23 是一个很直观的例子。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;long string is long&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;xyz&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">string1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">string2</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The longest string is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-23：通过拥有不同的具体生命周期的 <code>String</code> 值调用 <code>longest</code> 函数</p>
<p>在这个例子中，<code>string1</code> 直到外部作用域结束都是有效的，<code>string2</code> 则在内部作用域中是有效的，而 <code>result</code> 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 <code>The longest string is long string is long</code>。</p>
<p>接下来，让我们尝试另外一个例子，该例子揭示了 <code>result</code> 的引用的生命周期必须是两个参数中较短的那个。以下代码将 <code>result</code> 变量的声明移动出内部作用域，但是将 <code>result</code> 和 <code>string2</code> 变量的赋值语句一同留在内部作用域中。接着，使用了变量 <code>result</code> 的 <code>println!</code> 也被移动到内部作用域之外。注意示例 10-24 中的代码不能通过编译：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;long string is long&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">string2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;xyz&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">longest</span><span class="p">(</span><span class="n">string1</span><span class="p">.</span><span class="n">as_str</span><span class="p">(),</span><span class="w"> </span><span class="n">string2</span><span class="p">.</span><span class="n">as_str</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The longest string is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-24：尝试在 <code>string2</code> 离开作用域之后使用 <code>result</code></p>
<p>如果尝试编译会出现如下错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0597]: `string2` does not live long enough
</span><span class="go"> --&gt; src/main.rs:6:44
</span><span class="go">  |
</span><span class="go">6 |         result = longest(string1.as_str(), string2.as_str());
</span><span class="go">  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough
</span><span class="go">7 |     }
</span><span class="go">  |     - `string2` dropped here while still borrowed
</span><span class="go">8 |     println!(&#34;The longest string is {}&#34;, result);
</span><span class="go">  |                                          ------ borrow later used here
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0597`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>错误表明为了保证 <code>println!</code> 中的 <code>result</code> 是有效的，<code>string2</code> 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（<code>longest</code>）函数的参数和返回值都使用了相同的生命周期参数 <code>'a</code>。</p>
<p>如果从人的角度读上述代码，我们可能会觉得这个代码是正确的。 <code>string1</code> 更长，因此 <code>result</code> 会包含指向 <code>string1</code> 的引用。因为 <code>string1</code> 尚未离开作用域，对于 <code>println!</code> 来说 <code>string1</code> 的引用仍然是有效的。然而，我们通过生命周期参数告诉 Rust 的是： <code>longest</code> 函数返回的引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例 10-24 中的代码，因为它可能会存在无效的引用。</p>
<p>请尝试更多采用不同的值和不同生命周期的引用作为 <code>longest</code> 函数的参数和返回值的实验。并在开始编译前猜想你的实验能否通过借用检查器，接着编译一下看看你的理解是否正确！</p>
<h3 id="深入理解生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml深入理解生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">深入理解生命周期</a></h3>
<p>指定生命周期参数的正确方式依赖函数实现的具体功能。例如，如果将 <code>longest</code> 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 <code>y</code> 指定一个生命周期。如下代码将能够编译：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在这个例子中，我们为参数 <code>x</code> 和返回值指定了生命周期参数 <code>'a</code>，不过没有为参数 <code>y</code> 指定，因为 <code>y</code> 的生命周期与参数 <code>x</code> 和返回值的生命周期没有任何关系。</p>
<p>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。尝试考虑这个并不能编译的 <code>longest</code> 函数实现：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;really long string&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">result</span><span class="p">.</span><span class="n">as_str</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>即便我们为返回值指定了生命周期参数 <code>'a</code>，这个实现却编译失败了，因为返回值的生命周期与参数完全没有关联。这里是会出现的错误信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
</span><span class="go">error[E0515]: cannot return reference to local variable `result`
</span><span class="go">  --&gt; src/main.rs:11:5
</span><span class="go">   |
</span><span class="go">11 |     result.as_str()
</span><span class="go">   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0515`.
</span><span class="go">error: could not compile `chapter10` due to previous error
</span></code></pre></div><p>出现的问题是 <code>result</code> 在 <code>longest</code> 函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个 <code>result</code> 的引用。无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。在这种情况，最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。</p>
<p>综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p>
<h3 id="结构体定义中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml结构体定义中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">结构体定义中的生命周期注解</a></h3>
<p>目前为止，我们只定义过有所有权类型的结构体。接下来，我们将定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期注解。示例 10-25 中有一个存放了一个字符串 slice 的结构体 <code>ImportantExcerpt</code>：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">ImportantExcerpt</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">part</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">novel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Call me Ishmael. Some years ago...&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first_sentence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">novel</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">).</span><span class="n">next</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Could not find a &#39;.&#39;&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">part</span>: <span class="nc">first_sentence</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-25：一个存放引用的结构体，所以其定义需要生命周期注解</p>
<p>这个结构体有一个字段，<code>part</code>，它存放了一个字符串 slice，这是一个引用。类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。这个注解意味着 <code>ImportantExcerpt</code> 的实例不能比其 <code>part</code> 字段中的引用存在的更久。</p>
<p>这里的 <code>main</code> 函数创建了一个 <code>ImportantExcerpt</code> 的实例，它存放了变量 <code>novel</code> 所拥有的 <code>String</code> 的第一个句子的引用。<code>novel</code> 的数据在 <code>ImportantExcerpt</code> 实例创建之前就存在。另外，直到 <code>ImportantExcerpt</code> 离开作用域之后 <code>novel</code> 都不会离开作用域，所以 <code>ImportantExcerpt</code> 实例中的引用是有效的。</p>
<h3 id="生命周期省略lifetime-elisionhttpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml生命周期省略lifetime-elision"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">生命周期省略（Lifetime Elision）</a></h3>
<p>现在我们已经知道了每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。然而，第四章的示例 4-9 中有一个函数，如示例 10-26 所示，它没有生命周期注解却能编译成功：</p>
<p>文件名: src/lib.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">b&#39; &#39;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">];</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 10-26：示例 4-9 定义了一个没有使用生命周期注解的函数，即便其参数和返回值都是引用</p>
<p>这个函数没有生命周期注解却能编译是由于一些历史原因：在早期版本（pre-1.0）的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 程序员们总是重复地编写一模一样的生命周期注解。这些场景是可预测的并且遵循几个明确的模式。接着 Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。</p>
<p>这里我们提到一些 Rust 的历史是因为更多的明确的模式被合并和添加到编译器中是完全可能的。未来只会需要更少的生命周期注解。</p>
<p>被编码进 Rust 引用分析的模式被称为 <strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p>
<p>省略规则并不提供完整的推断：如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。在这种情况，编译器会给出一个错误，这可以通过增加对应引用之间相联系的生命周期注解来解决。</p>
<p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p>
<p>编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 <code>fn</code> 定义，以及 <code>impl</code> 块。</p>
<p>第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>，有两个引用参数的函数有两个不同的生命周期参数，<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>，依此类推。</p>
<p>第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<p>第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，说明是个对象的方法(method)(译者注： 这里涉及rust的面向对象参见17章), 那么所有输出生命周期参数被赋予 <code>self</code> 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。</p>
<p>假设我们自己就是编译器。并应用这些规则来计算示例 10-26 中 <code>first_word</code> 函数签名中的引用的生命周期。开始时签名中的引用并没有关联任何生命周期：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>接着编译器应用第一条规则，也就是每个引用参数都有其自己的生命周期。我们像往常一样称之为 <code>'a</code>，所以现在签名看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">first_word</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p>
<p>让我们再看看另一个例子，这次我们从示例 10-21 中没有生命周期参数的 <code>longest</code> 函数开始：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>再次假设我们自己就是编译器并应用第一条规则：每个引用参数都有其自己的生命周期。这次有两个参数，所以就有两个（不同的）生命周期：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">longest</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="o">&#39;</span><span class="na">b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">b</span> <span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></code></pre></div><p>再来应用第二条规则，因为函数存在多个输入生命周期，它并不适用于这种情况。再来看第三条规则，它同样也不适用，这是因为没有 <code>self</code> 参数。应用了三个规则之后编译器还没有计算出返回值类型的生命周期。这就是为什么在编译示例 10-21 的代码时会出现错误的原因：编译器使用所有已知的生命周期省略规则，仍不能计算出签名中所有引用的生命周期。</p>
<p>因为第三条规则真正能够适用的就只有方法签名，现在就让我们看看那种情况中的生命周期，并看看为什么这条规则意味着我们经常不需要在方法签名中标注生命周期。</p>
<h3 id="方法定义中的生命周期注解httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml方法定义中的生命周期注解"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">方法定义中的生命周期注解</a></h3>
<p>当为带有生命周期的结构体实现方法时，其语法依然类似示例 10-11 中展示的泛型类型参数的语法。声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数和返回值相关。</p>
<p>（实现方法时）结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。让我们看看一些使用示例 10-25 中定义的结构体 <code>ImportantExcerpt</code> 的例子。</p>
<p>首先，这里有一个方法 <code>level</code>。其唯一的参数是 <code>self</code> 的引用，而且返回值只是一个 <code>i32</code>，并不引用任何值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">level</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">3</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>impl</code> 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 <code>self</code> 引用的生命周期。</p>
<p>这里是一个适用于第三条生命周期省略规则的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ImportantExcerpt</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">announce_and_return_part</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">announcement</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Attention please: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">announcement</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">part</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 <code>&amp;self</code> 和 <code>announcement</code> 他们各自的生命周期。接着，因为其中一个参数是 <code>&amp;self</code>，返回值类型被赋予了 <code>&amp;self</code> 的生命周期，这样所有的生命周期都被计算出来了。</p>
<h3 id="静态生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml静态生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">静态生命周期</a></h3>
<p>这里有一种特殊的生命周期值得讨论：<code>'static</code>，其生命周期<strong>能够</strong>存活于整个程序期间。所有的字符串字面值都拥有 <code>'static</code> 生命周期，我们也可以选择像下面这样标注出来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span> <span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;I have a static lifetime.&#34;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>'static</code> 的。</p>
<p>你可能在错误信息的帮助文本中见过使用 <code>'static</code> 生命周期的建议，不过将引用指定为 <code>'static</code> 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效。你也许要考虑是否希望它存在得这么久，即使这是可能的。大部分情况，代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，请解决这些问题而不是指定一个 <code>'static</code> 的生命周期。</p>
<h3 id="结合泛型类型参数trait-bounds-和生命周期httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml结合泛型类型参数trait-bounds-和生命周期"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E7%BB%93%E5%90%88%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0trait-bounds-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">结合泛型类型参数、trait bounds 和生命周期</a></h3>
<p>让我们简要的看一下在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Display</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">longest_with_an_announcement</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ann</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span>
<span class="nc">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Display</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Announcement! {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">ann</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个是示例 10-22 中那个返回两个字符串 slice 中较长者的 <code>longest</code> 函数，不过带有一个额外的参数 <code>ann</code>。<code>ann</code> 的类型是泛型 <code>T</code>，它可以被放入任何实现了 <code>where</code> 从句中指定的 <code>Display</code> trait 的类型。这个额外的参数会使用 <code>{}</code> 打印，这也就是为什么 <code>Display</code> trait bound 是必须的。因为生命周期也是泛型，所以生命周期参数 <code>'a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中。</p>
<h2 id="总结httpskaiserygithubiotrpl-zh-cnch10-03-lifetime-syntaxhtml总结"><a href="https://kaisery.github.io/trpl-zh-cn/ch10-03-lifetime-syntax.html#%E6%80%BB%E7%BB%93">总结</a></h2>
<p>这一章介绍了很多的内容！现在你知道了泛型类型参数、trait 和 trait bounds 以及泛型生命周期类型，你已经准备好编写既不重复又能适用于多种场景的代码了。泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds 保证了即使类型是泛型的，这些类型也会拥有所需要的行为。由生命周期注解所指定的引用生命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用。而所有的这一切发生在编译时所以不会影响运行时效率！</p>
<p>你可能不会相信，这个话题还有更多需要学习的内容：第十七章会讨论 trait 对象，这是另一种使用 trait 的方式。还有更多更复杂的涉及生命周期注解的场景，只有在非常高级的情况下才会需要它们；对于这些内容，请阅读 <a href="https://doc.rust-lang.org/reference/index.html">Rust Reference</a>。不过接下来，让我们聊聊如何在 Rust 中编写测试，来确保代码的所有功能能像我们希望的那样工作！</p>

    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://qkgoalkeeper.github.io/tags/rust%E6%95%99%E7%A8%8B">rust教程</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://qkgoalkeeper.github.io/categories/rust">rust</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://qkgoalkeeper.github.io/post/rustthe_rust_book10%E6%B3%9B%E5%9E%8Btrait-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" data-title="rust：the_rust_book（10）泛型、Trait 和生命周期" data-tsina="5852167252" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  



</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/golang" title="golang">golang<sup>6</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e5%91%a8%e8%b5%9b" title="leetcode周赛">leetcode周赛<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98" title="leetcode每日一题">leetcode每日一题<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%981-100" title="leetcode简单题1-100">leetcode简单题1-100<sup>21</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98101-200" title="leetcode简单题101-200">leetcode简单题101-200<sup>25</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98201-300" title="leetcode简单题201-300">leetcode简单题201-300<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/python" title="python">python<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/rust" title="rust">rust<sup>11</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e4%bb%a5%e5%a4%aa%e5%9d%8a" title="以太坊">以太坊<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%85%b6%e4%bb%96" title="其他">其他<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>4</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be%e7%9b%b8%e5%85%b3" title="区块链相关">区块链相关<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%be%e7%a8%8b" title="大三上数据库课程">大三上数据库课程<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8bweb%e7%bc%96%e7%a8%8b%e8%af%be%e7%a8%8b" title="大三下web编程课程">大三下web编程课程<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e5%9b%9bleetcode%e7%ae%97%e6%b3%95%e5%88%b7%e9%a2%98" title="大四leetcode算法刷题">大四leetcode算法刷题<sup>300</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://qkgoalkeeper.github.io/tags/bfs" title="bfs">bfs<sup>13</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" title="c&#43;&#43;">c&#43;&#43;<sup>289</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/dfs" title="dfs">dfs<sup>27</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang" title="golang">golang<sup>40</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" title="golang语法">golang语法<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/javascript" title="javascript">javascript<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/leetcode" title="leetcode">leetcode<sup>396</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/rust%e6%95%99%e7%a8%8b" title="rust教程">rust教程<sup>11</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/solidity" title="solidity">solidity<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" title="二分法">二分法<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" title="代码">代码<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" title="优先队列">优先队列<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" title="位运算">位运算<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" title="分治法">分治法<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" title="前缀和">前缀和<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" title="动态规划">动态规划<sup>32</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" title="单调队列">单调队列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" title="双指针">双指针<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" title="哈希表">哈希表<sup>7</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" title="堆">堆<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" title="字典树">字典树<sup>6</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" title="字符串">字符串<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" title="并查集">并查集<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" title="序列化">序列化<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" title="拓扑排序">拓扑排序<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" title="排列">排列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" title="排序">排序<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" title="数学">数学<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" title="数组">数组<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" title="栈">栈<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" title="树">树<sup>25</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" title="源码编译">源码编译<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" title="滑动窗口">滑动窗口<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" title="线段树">线段树<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" title="缓存">缓存<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" title="贪心">贪心<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" title="贪心法">贪心法<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" title="链表">链表<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" title="队列">队列<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" title="随机数">随机数<sup>3</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-07">2022年07月</a><span class="archive-list-count">22</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-06">2022年06月</a><span class="archive-list-count">26</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-05">2022年05月</a><span class="archive-list-count">14</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-04">2022年04月</a><span class="archive-list-count">24</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-03">2022年03月</a><span class="archive-list-count">32</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-02">2022年02月</a><span class="archive-list-count">61</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-01">2022年01月</a><span class="archive-list-count">77</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-12">2021年12月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-11">2021年11月</a><span class="archive-list-count">30</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-10">2021年10月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-09">2021年09月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-06">2021年06月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-04">2021年04月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-11">2020年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-08">2020年08月</a><span class="archive-list-count">70</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://qkgoalkeeper.github.io/tags/bfs" style="font-size: 12px;">bfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" style="font-size: 12px;">c&#43;&#43;</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/dfs" style="font-size: 12px;">dfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang" style="font-size: 12px;">golang</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" style="font-size: 12px;">golang语法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/javascript" style="font-size: 12px;">javascript</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/leetcode" style="font-size: 12px;">leetcode</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/rust%e6%95%99%e7%a8%8b" style="font-size: 12px;">rust教程</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/solidity" style="font-size: 12px;">solidity</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" style="font-size: 12px;">二分法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" style="font-size: 12px;">代码</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" style="font-size: 12px;">优先队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" style="font-size: 12px;">位运算</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" style="font-size: 12px;">分治法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" style="font-size: 12px;">前缀和</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" style="font-size: 12px;">动态规划</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" style="font-size: 12px;">区块链</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" style="font-size: 12px;">单调队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" style="font-size: 12px;">双指针</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" style="font-size: 12px;">哈希表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" style="font-size: 12px;">堆</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" style="font-size: 12px;">字典树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" style="font-size: 12px;">字符串</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" style="font-size: 12px;">并查集</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" style="font-size: 12px;">序列化</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" style="font-size: 12px;">拓扑排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" style="font-size: 12px;">排列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" style="font-size: 12px;">排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" style="font-size: 12px;">数学</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" style="font-size: 12px;">数据库</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" style="font-size: 12px;">数组</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" style="font-size: 12px;">栈</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" style="font-size: 12px;">树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" style="font-size: 12px;">源码编译</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" style="font-size: 12px;">滑动窗口</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" style="font-size: 12px;">王道机试指南</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" style="font-size: 12px;">线段树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" style="font-size: 12px;">缓存</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" style="font-size: 12px;">论文解读</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" style="font-size: 12px;">贪心</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" style="font-size: 12px;">贪心法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" style="font-size: 12px;">链表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" style="font-size: 12px;">队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" style="font-size: 12px;">随机数</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  <div class="line">
    <span></span>
    
    <div style='background:no-repeat url("https://qkgoalkeeper.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <section class="info">
    <p>ECNU数据学院在读 <br/> 知乎主页 :https://www.zhihu.com/people/hao-lai-wu-shou-men-yuan <br/>QQ :1421812601</p>
  </section>
  <div class="social-font clearfix">
    <a href='http://weibo.com/qkgoalkeeper' target="_blank" title="weibo"></a>
    <a href='https://twitter.com/coderzh' target="_blank" title="twitter"></a>
    <a href='https://github.com/qkgoalkeeper' target="_blank" title="github"></a>
    <a href='https://www.facebook.com/coderzh' target="_blank" title="facebook"></a>
    <a href='https://www.linkedin.com/coderzh' target="_blank" title="linkedin"></a>
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2022
    
    <a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a>
    
  </p>
</div>
</footer>
  <script src="https://qkgoalkeeper.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/qkgoalkeeper.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://b.bshare.cn/barCode?site=weixin&url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
