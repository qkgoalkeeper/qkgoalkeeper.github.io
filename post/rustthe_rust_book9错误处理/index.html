<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>rust：the_rust_book（9）错误处理 - qkgoalkeeper&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  
  <meta name="description" content="一.本章任务 错误是软件中不可否认的事实，所以 Rust 有一些处理出错情况的特性。在许多情况下，Rust 要求你承认错误的可能性，并在你的代码编译前采取">
  
  <meta itemprop="name" content="rust：the_rust_book（9）错误处理 - qkgoalkeeper&#39;s blog">
  <meta itemprop="description" content="一.本章任务 错误是软件中不可否认的事实，所以 Rust 有一些处理出错情况的特性。在许多情况下，Rust 要求你承认错误的可能性，并在你的代码编译前采取">
  <meta itemprop="image" content="https://qkgoalkeeper.github.io/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://qkgoalkeeper.github.io/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/highlight/styles/github.css">
  <script src="https://qkgoalkeeper.github.io/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/css/style.css">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-175507250-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-175507250-1');
</script>
  

</head>

<body>
  <header>
    <div>
  <div id="imglogo">
    <a href="https://qkgoalkeeper.github.io/"><img src='https://qkgoalkeeper.github.io/img/logo.svg' alt="qkgoalkeeper&#39;s blog" title="qkgoalkeeper&#39;s blog"/></a>
  </div>
  <div id="textlogo">
    <h1 class="site-name"><a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a></h1>
    <h2 class="blog-motto">ECNU数据学院在读</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/about">关于</a></li>
      
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder='Search'>
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://qkgoalkeeper.github.io/post/rustthe_rust_book9%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" title="rust：the_rust_book（9）错误处理" itemprop="url">rust：the_rust_book（9）错误处理</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://qkgoalkeeper.github.io/" title="qk">qk</a>
    
  </p>
  <p class="article-time">
    <time datetime="2022-07-28 07:55:19 &#43;0800 CST" itemprop="datePublished">2022年07月28日</time>
  </p>
</header>

	<div class="article-content">
    
		<div class="toc-article">
			<strong class="toc-title">文章目录</strong>
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#对应-panic-时的栈展开或终止httpskaiserygithubiotrpl-zh-cnch09-01-unrecoverable-errors-with-panichtml对应-panic-时的栈展开或终止"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E5%AF%B9%E5%BA%94-panic-%E6%97%B6%E7%9A%84%E6%A0%88%E5%B1%95%E5%BC%80%E6%88%96%E7%BB%88%E6%AD%A2">对应 panic 时的栈展开或终止</a></a></li>
        <li><a href="#使用-panic-的-backtracehttpskaiserygithubiotrpl-zh-cnch09-01-unrecoverable-errors-with-panichtml使用-panic-的-backtrace"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E4%BD%BF%E7%94%A8-panic-%E7%9A%84-backtrace">使用 <code>panic!</code> 的 backtrace</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#匹配不同的错误httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml匹配不同的错误"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%99%E8%AF%AF">匹配不同的错误</a></a></li>
        <li><a href="#失败时-panic-的简写unwrap-和-expecthttpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml失败时-panic-的简写unwrap-和-expect"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%A4%B1%E8%B4%A5%E6%97%B6-panic-%E7%9A%84%E7%AE%80%E5%86%99unwrap-%E5%92%8C-expect">失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></a></a></li>
        <li><a href="#传播错误httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml传播错误"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF">传播错误</a></a></li>
        <li><a href="#传播错误的简写-运算符httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml传播错误的简写-运算符"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF%E7%9A%84%E7%AE%80%E5%86%99-%E8%BF%90%E7%AE%97%E7%AC%A6">传播错误的简写：<code>?</code> 运算符</a></a></li>
        <li><a href="#哪里可以使用--运算符httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml哪里可以使用--运算符"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6">哪里可以使用 <code>?</code> 运算符</a></a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#示例代码原型和测试都非常适合-panichttpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml示例代码原型和测试都非常适合-panic"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E9%83%BD%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88-panic">示例、代码原型和测试都非常适合 panic</a></a></li>
        <li><a href="#当我们比编译器知道更多的情况httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml当我们比编译器知道更多的情况"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E5%BD%93%E6%88%91%E4%BB%AC%E6%AF%94%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E9%81%93%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%83%85%E5%86%B5">当我们比编译器知道更多的情况</a></a></li>
        <li><a href="#错误处理指导原则httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml错误处理指导原则"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">错误处理指导原则</a></a></li>
        <li><a href="#创建自定义类型进行有效性验证httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml创建自定义类型进行有效性验证"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E6%80%A7%E9%AA%8C%E8%AF%81">创建自定义类型进行有效性验证</a></a></li>
      </ul>
    </li>
    <li><a href="#总结httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml总结"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E6%80%BB%E7%BB%93">总结</a></a></li>
  </ul>
</nav>
		</div>
    
    <h1 id="一本章任务">一.本章任务</h1>
<p>错误是软件中不可否认的事实，所以 Rust 有一些处理出错情况的特性。在许多情况下，Rust 要求你承认错误的可能性，并在你的代码编译前采取一些行动。这一要求使你的程序更加健壮，因为它可以确保你在将代码部署到生产环境之前就能发现错误并进行适当的处理。</p>
<p>Rust 将错误分为两大类：<strong>可恢复的</strong>（<em>recoverable</em>）和 <strong>不可恢复的</strong>（<em>unrecoverable</em>）错误。对于一个可恢复的错误，比如文件未找到的错误，我们很可能只想向用户报告问题并重试操作。不可恢复的错误总是 bug 出现的征兆，比如试图访问一个超过数组末端的位置，因此我们要立即停止程序。</p>
<p>大多数语言并不区分这两种错误，并采用类似异常这样方式统一处理他们。Rust 没有异常。相反，它有 <code>Result&lt;T, E&gt;</code> 类型，用于处理可恢复的错误，还有 <code>panic!</code> 宏，在程序遇到不可恢复的错误时停止执行。本章首先介绍 <code>panic!</code> 调用，接着会讲到如何返回 <code>Result&lt;T, E&gt;</code>。此外，我们将探讨在决定是尝试从错误中恢复还是停止执行时的注意事项。</p>
<h1 id="二用-panic-处理不可恢复的错误httpskaiserygithubiotrpl-zh-cnch09-01-unrecoverable-errors-with-panichtml用-panic-处理不可恢复的错误">二.<a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E7%94%A8-panic-%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF">用 <code>panic!</code> 处理不可恢复的错误</a></h1>
<p>突然有一天，代码出问题了，而你对此束手无策。对于这种情况，Rust 有 <code>panic!</code>宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。出现这种情况的场景通常是检测到一些类型的 bug，而且程序员并不清楚该如何处理它。</p>
<blockquote>
<h3 id="对应-panic-时的栈展开或终止httpskaiserygithubiotrpl-zh-cnch09-01-unrecoverable-errors-with-panichtml对应-panic-时的栈展开或终止"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E5%AF%B9%E5%BA%94-panic-%E6%97%B6%E7%9A%84%E6%A0%88%E5%B1%95%E5%BC%80%E6%88%96%E7%BB%88%E6%AD%A2">对应 panic 时的栈展开或终止</a></h3>
<p>当出现 panic 时，程序默认会开始 <strong>展开</strong>（<em>unwinding</em>），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接 <strong>终止</strong>（<em>abort</em>），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。如果你需要项目的最终二进制文件越小越好，panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>，可以由展开切换为终止。例如，如果你想要在release模式中 panic 时直接终止：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">profile</span><span class="p">.</span><span class="nx">release</span><span class="p">]</span>
<span class="nx">panic</span> <span class="p">=</span> <span class="s1">&#39;abort&#39;</span>
</code></pre></div></blockquote>
<p>让我们在一个简单的程序中调用 <code>panic!</code>：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;crash and burn&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>运行程序将会出现类似这样的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling panic v0.1.0 (file:///projects/panic)
</span><span class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
</span><span class="go">     Running `target/debug/panic`
</span><span class="go">thread &#39;main&#39; panicked at &#39;crash and burn&#39;, src/main.rs:2:5
</span><span class="go">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre></div><p>最后两行包含 <code>panic!</code> 调用造成的错误信息。第一行显示了 panic 提供的信息并指明了源码中 panic 出现的位置：<em>src/main.rs:2:5</em> 表明这是 <em>src/main.rs</em> 文件的第二行第五个字符。</p>
<p>在这个例子中，被指明的那一行是我们代码的一部分，而且查看这一行的话就会发现 <code>panic!</code> 宏的调用。在其他情况下，<code>panic!</code> 可能会出现在我们的代码所调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 <code>panic!</code> 宏调用，而不是我们代码中最终导致 <code>panic!</code> 的那一行。我们可以使用 <code>panic!</code> 被调用的函数的 backtrace 来寻找代码中出问题的地方。下面我们会详细介绍 backtrace 是什么。</p>
<h3 id="使用-panic-的-backtracehttpskaiserygithubiotrpl-zh-cnch09-01-unrecoverable-errors-with-panichtml使用-panic-的-backtrace"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-01-unrecoverable-errors-with-panic.html#%E4%BD%BF%E7%94%A8-panic-%E7%9A%84-backtrace">使用 <code>panic!</code> 的 backtrace</a></h3>
<p>让我们来看看另一个因为我们代码中的 bug 引起的别的库中 <code>panic!</code> 的例子，而不是直接的宏调用。示例 9-1 有一些尝试通过索引访问 vector 中元素的例子：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">99</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-1：尝试访问超越 vector 结尾的元素，这会造成 <code>panic!</code></p>
<p>这里尝试访问 vector 的第一百个元素（这里的索引是 99 因为索引从 0 开始），不过它只有三个元素。这种情况下 Rust 会 panic。<code>[]</code> 应当返回一个元素，不过如果传递了一个无效索引，就没有可供 Rust 返回的正确的元素。</p>
<p>C 语言中，尝试读取数据结构之后的值是未定义行为（undefined behavior）。你会得到任何对应数据结构中这个元素的内存位置的值，甚至是这些内存并不属于这个数据结构的情况。这被称为 <strong>缓冲区溢出</strong>（<em>buffer overread</em>），并可能会导致安全漏洞，比如攻击者可以像这样操作索引来读取储存在数据结构之后不被允许的数据。</p>
<p>为了保护程序远离这类漏洞，如果尝试读取一个索引不存在的元素，Rust 会停止执行并拒绝继续。尝试运行上面的程序会出现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling panic v0.1.0 (file:///projects/panic)
</span><span class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
</span><span class="go">     Running `target/debug/panic`
</span><span class="go">thread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 99&#39;, src/main.rs:4:5
</span><span class="go">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre></div><p>错误指向 <code>main.rs</code> 的第 4 行，这里我们尝试访问索引 99。下面的说明（note）行提醒我们可以设置 <code>RUST_BACKTRACE</code> 环境变量来得到一个 backtrace。<em>backtrace</em> 是一个执行到目前位置所有被调用的函数的列表。Rust 的 backtrace 跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地。这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码。这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码。让我们将 <code>RUST_BACKTRACE</code> 环境变量设置为任何不是 0 的值来获取 backtrace 看看。示例 9-2 展示了与你看到类似的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span><span class="nv">RUST_BACKTRACE</span><span class="o">=</span><span class="m">1</span> cargo run
<span class="go">thread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 99&#39;, src/main.rs:4:5
</span><span class="go">stack backtrace:
</span><span class="go">   0: rust_begin_unwind
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/std/src/panicking.rs:483
</span><span class="go">   1: core::panicking::panic_fmt
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:85
</span><span class="go">   2: core::panicking::panic_bounds_check
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/panicking.rs:62
</span><span class="go">   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:255
</span><span class="go">   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/slice/index.rs:15
</span><span class="go">   5: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/alloc/src/vec.rs:1982
</span><span class="go">   6: panic::main
</span><span class="go">             at ./src/main.rs:4
</span><span class="go">   7: core::ops::function::FnOnce::call_once
</span><span class="go">             at /rustc/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/library/core/src/ops/function.rs:227
</span><span class="go">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</span></code></pre></div><p>示例 9-2：当设置 <code>RUST_BACKTRACE</code> 环境变量时 <code>panic!</code> 调用所生成的 backtrace 信息</p>
<p>这里有大量的输出！你实际看到的输出可能因不同的操作系统和 Rust 版本而有所不同。为了获取带有这些信息的 backtrace，必须启用 debug 标识。当不使用 <code>--release</code> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用，就像这里一样。</p>
<p>示例 9-2 的输出中，backtrace 的 12 行指向了我们项目中造成问题的行：<em>src/main.rs</em> 的第 4 行。如果你不希望程序 panic，第一个提到我们编写的代码行的位置是你应该开始调查的，以便查明是什么值如何在这个地方引起了 panic。在示例 9-1 中，我们故意编写会 panic 的代码来演示如何使用 backtrace，修复这个 panic 的方法就是不要尝试在一个只包含三个项的 vector 中请求索引是 100 的元素。当将来你的代码出现了 panic，你需要搞清楚在这特定的场景下代码中执行了什么操作和什么值导致了 panic，以及应当如何处理才能避免这个问题。</p>
<p>本章后面的小节 <a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#panic-%E8%BF%98%E6%98%AF%E4%B8%8D-panic">“panic! 还是不 panic!”</a> 会再次回到 <code>panic!</code> 并讲解何时应该、何时不应该使用 <code>panic!</code> 来处理错误情况。接下来，我们来看看如何使用 <code>Result</code> 来从错误中恢复。</p>
<h1 id="三用-result-处理可恢复的错误httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml用-result-处理可恢复的错误">三.<a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E7%94%A8-result-%E5%A4%84%E7%90%86%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF">用 <code>Result</code> 处理可恢复的错误</a></h1>
<p>大部分错误并没有严重到需要程序完全停止执行。有时，一个函数会因为一个容易理解并做出反应的原因失败。例如，如果因为打开一个并不存在的文件而失败，此时我们可能想要创建这个文件，而不是终止进程。</p>
<p>回忆一下第二章 <a href="https://kaisery.github.io/trpl-zh-cn/ch02-00-guessing-game-tutorial.html#%E4%BD%BF%E7%94%A8-result-%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%A4%84%E7%90%86%E6%BD%9C%E5%9C%A8%E7%9A%84%E9%94%99%E8%AF%AF">“使用 <code>Result</code> 类型来处理潜在的错误”</a> 部分中的那个 <code>Result</code> 枚举，它定义有如下两个成员，<code>Ok</code> 和 <code>Err</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>T</code> 和 <code>E</code> 是泛型类型参数；第十章会详细介绍泛型。现在你需要知道的就是 <code>T</code> 代表成功时返回的 <code>Ok</code> 成员中的数据的类型，而 <code>E</code> 代表失败时返回的 <code>Err</code> 成员中的错误的类型。因为 <code>Result</code> 有这些泛型类型参数，我们可以将 <code>Result</code> 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同。</p>
<p>让我们调用一个返回 <code>Result</code> 的函数，因为它可能会失败：如示例 9-3 所示打开一个文件：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-3：打开文件</p>
<p>如何知道 <code>File::open</code> 返回一个 <code>Result</code> 呢？我们可以查看 <a href="https://doc.rust-lang.org/std/index.html">标准库 API 文档</a>，或者可以直接问编译器！如果给 <code>f</code> 某个我们知道 <strong>不是</strong> 函数返回值类型的类型注解，接着尝试编译代码，编译器会告诉我们类型不匹配。然后错误信息会告诉我们 <code>f</code> 的类型 <strong>应该</strong> 是什么。让我们试试！我们知道 <code>File::open</code> 的返回值不是 <code>u32</code> 类型的，所以将 <code>let f</code> 语句改为如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>现在尝试编译会给出如下输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling error-handling v0.1.0 (file:///projects/error-handling)
</span><span class="go">error[E0308]: mismatched types
</span><span class="go"> --&gt; src/main.rs:4:18
</span><span class="go">  |
</span><span class="go">4 |     let f: u32 = File::open(&#34;hello.txt&#34;);
</span><span class="go">  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
</span><span class="go">  |            |
</span><span class="go">  |            expected due to this
</span><span class="go">  |
</span><span class="go">  = note: expected type `u32`
</span><span class="go">             found enum `Result&lt;File, std::io::Error&gt;`
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0308`.
</span><span class="go">error: could not compile `error-handling` due to previous error
</span></code></pre></div><p>这就告诉我们了 <code>File::open</code> 函数的返回值类型是 <code>Result&lt;T, E&gt;</code>。这里泛型参数 <code>T</code> 放入了成功值的类型 <code>std::fs::File</code>，它是一个文件句柄。<code>E</code> 被用在失败值上时 <code>E</code> 的类型是 <code>std::io::Error</code>。</p>
<p>这个返回值类型说明 <code>File::open</code> 调用可能会成功并返回一个可以进行读写的文件句柄。这个函数也可能会失败：例如，文件可能并不存在，或者可能没有访问文件的权限。<code>File::open</code> 需要一个方式告诉我们是成功还是失败，并同时提供给我们文件句柄或错误信息。而这些信息正是 <code>Result</code> 枚举可以提供的。</p>
<p>当 <code>File::open</code> 成功的情况下，变量 <code>f</code> 的值将会是一个包含文件句柄的 <code>Ok</code> 实例。在失败的情况下，<code>f</code> 的值会是一个包含更多关于出现了何种错误信息的 <code>Err</code> 实例。</p>
<p>我们需要在示例 9-3 的代码中增加根据 <code>File::open</code> 返回值进行不同处理的逻辑。示例 9-4 展示了一个使用基本工具处理 <code>Result</code> 的例子：第六章学习过的 <code>match</code> 表达式。</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Problem opening the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-4：使用 <code>match</code> 表达式处理可能会返回的 <code>Result</code> 成员</p>
<p>注意与 <code>Option</code> 枚举一样，<code>Result</code> 枚举和其成员也被导入到了 prelude 中，所以就不需要在 <code>match</code> 分支中的 <code>Ok</code> 和 <code>Err</code> 之前指定 <code>Result::</code>。</p>
<p>这里我们告诉 Rust 当结果是 <code>Ok</code> 时，返回 <code>Ok</code> 成员中的 <code>file</code> 值，然后将这个文件句柄赋值给变量 <code>f</code>。<code>match</code> 之后，我们可以利用这个文件句柄来进行读写。</p>
<p><code>match</code> 的另一个分支处理从 <code>File::open</code> 得到 <code>Err</code> 值的情况。在这种情况下，我们选择调用 <code>panic!</code> 宏。如果当前目录没有一个叫做 <em>hello.txt</em> 的文件，当运行这段代码时会看到如下来自 <code>panic!</code> 宏的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling error-handling v0.1.0 (file:///projects/error-handling)
</span><span class="go">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
</span><span class="go">     Running `target/debug/error-handling`
</span><span class="go">thread &#39;main&#39; panicked at &#39;Problem opening the file: Os { code: 2, kind: NotFound, message: &#34;No such file or directory&#34; }&#39;, src/main.rs:8:23
</span><span class="go">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre></div><p>一如既往，此输出准确地告诉了我们到底出了什么错。</p>
<h3 id="匹配不同的错误httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml匹配不同的错误"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%99%E8%AF%AF">匹配不同的错误</a></h3>
<p>示例 9-4 中的代码不管 <code>File::open</code> 是因为什么原因失败都会 <code>panic!</code>。我们真正希望的是对不同的错误原因采取不同的行为：如果 <code>File::open </code>因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄。如果 <code>File::open</code> 因为任何其他原因失败，例如没有打开文件的权限，我们仍然希望像示例 9-4 那样 <code>panic!</code>。让我们看看示例 9-5，其中 <code>match</code> 增加了另一个分支：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">ErrorKind</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">ErrorKind</span>::<span class="n">NotFound</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fc</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Problem creating the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">other_error</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Problem opening the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">other_error</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-5：使用不同的方式处理不同类型的错误</p>
<p><code>File::open</code> 返回的 <code>Err</code> 成员中的值类型 <code>io::Error</code>，它是一个标准库中提供的结构体。这个结构体有一个返回 <code>io::ErrorKind</code> 值的 <code>kind</code> 方法可供调用。<code>io::ErrorKind</code> 是一个标准库提供的枚举，它的成员对应 <code>io</code> 操作可能导致的不同错误类型。我们感兴趣的成员是 <code>ErrorKind::NotFound</code>，它代表尝试打开的文件并不存在。这样，<code>match</code> 就匹配完 <code>f</code> 了，不过对于 <code>error.kind()</code> 还有一个内层 <code>match</code>。</p>
<p>我们希望在内层 <code>match</code> 中检查的条件是 <code>error.kind()</code> 的返回值是否为 <code>ErrorKind</code>的 <code>NotFound</code> 成员。如果是，则尝试通过 <code>File::create</code> 创建文件。然而因为 <code>File::create</code> 也可能会失败，还需要增加一个内层 <code>match</code> 语句。当文件不能被打开，会打印出一个不同的错误信息。外层 <code>match</code> 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic。</p>
<blockquote>
<p>不同于使用 <code>match</code> 和 <code>Result&lt;T, E&gt;</code></p>
<p>这里有好多 <code>match</code>！<code>match</code> 确实很强大，不过也非常的基础。第十三章我们会介绍闭包（closure），这可以用于很多 <code>Result&lt;T, E&gt;</code> 上定义的方法。在处理代码中的 <code>Result&lt;T, E&gt;</code> 值时这些方法可能会更加简洁。</p>
<p>例如，这是另一个编写与示例 9-5 逻辑相同但是使用闭包和 <code>unwrap_or_else</code> 方法的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">ErrorKind</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">error</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ErrorKind</span>::<span class="n">NotFound</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">File</span>::<span class="n">create</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">error</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Problem creating the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">})</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Problem opening the file: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然这段代码有着如示例 9-5 一样的行为，但并没有包含任何 <code>match</code> 表达式且更容易阅读。在阅读完第十三章后再回到这个例子，并查看标准库文档 <code>unwrap_or_else</code> 方法都做了什么操作。在处理错误时，还有很多这类方法可以消除大量嵌套的 <code>match</code> 表达式。</p>
</blockquote>
<h3 id="失败时-panic-的简写unwrap-和-expecthttpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml失败时-panic-的简写unwrap-和-expect"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%A4%B1%E8%B4%A5%E6%97%B6-panic-%E7%9A%84%E7%AE%80%E5%86%99unwrap-%E5%92%8C-expect">失败时 panic 的简写：<code>unwrap</code> 和 <code>expect</code></a></h3>
<p><code>match</code> 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图。<code>Result&lt;T, E&gt;</code> 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <code>unwrap</code>，它的实现就类似于示例 9-4 中的 <code>match</code> 语句。如果 <code>Result</code> 值是成员 <code>Ok</code>，<code>unwrap</code> 会返回 <code>Ok</code> 中的值。如果 <code>Result</code> 是成员 <code>Err</code>，<code>unwrap</code> 会为我们调用 <code>panic!</code>。这里是一个实践 <code>unwrap</code> 的例子：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果调用这段代码时不存在 <em>hello.txt</em> 文件，我们将会看到一个 <code>unwrap</code> 调用 <code>panic!</code> 时提供的错误信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &#34;No such file or directory&#34; } }&#39;,
src/libcore/result.rs:906:4
</code></pre></div><p>还有另一个类似于 <code>unwrap</code> 的方法它还允许我们选择 <code>panic!</code> 的错误信息：<code>expect</code>。使用 <code>expect</code> 而不是 <code>unwrap</code> 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。<code>expect</code> 的语法看起来像这样：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Failed to open hello.txt&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>expect</code> 与 <code>unwrap</code> 的使用方式一样：返回文件句柄或调用 <code>panic!</code> 宏。<code>expect</code> 在调用 <code>panic!</code> 时使用的错误信息将是我们传递给 <code>expect</code> 的参数，而不像 <code>unwrap</code> 那样使用默认的 <code>panic!</code> 信息。它看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">thread &#39;main&#39; panicked at &#39;Failed to open hello.txt: Error { repr: Os { code:
2, message: &#34;No such file or directory&#34; } }&#39;, src/libcore/result.rs:906:4
</code></pre></div><p>因为这个错误信息以我们指定的文本开始，<code>Failed to open hello.txt</code>，将会更容易找到代码中的错误信息来自何处。如果在多处使用 <code>unwrap</code>，则需要花更多的时间来分析到底是哪一个 <code>unwrap</code> 造成了 panic，因为所有的 <code>unwrap</code> 调用都打印相同的信息。</p>
<h3 id="传播错误httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml传播错误"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF">传播错误</a></h3>
<p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为 <strong>传播</strong>（<em>propagating</em>）错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<p>例如，示例 9-6 展示了一个从文件中读取用户名的函数。如果文件不存在或不能读取，这个函数会将这些错误返回给调用它的代码：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Read</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-6：一个函数使用 <code>match</code> 将错误返回给代码调用者</p>
<p>首先让我们看看函数的返回值：<code>Result&lt;String, io::Error&gt;</code>。这意味着函数返回一个 <code>Result&lt;T, E&gt;</code> 类型的值，其中泛型参数 <code>T</code> 的具体类型是 <code>String</code>，而 <code>E</code> 的具体类型是 <code>io::Error</code>。如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含 <code>String</code> 的 <code>Ok</code> 值 —— 函数从文件中读取到的用户名。如果函数遇到任何错误，函数的调用者会收到一个 <code>Err</code> 值，它储存了一个包含更多这个问题相关信息的 <code>io::Error</code> 实例。这里选择 <code>io::Error</code> 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：<code>File::open</code> 函数和 <code>read_to_string</code> 方法。</p>
<p>函数体以调用 <code>File::open</code> 函数开始。接着使用 <code>match</code> 处理返回值 <code>Result</code>，类似示例 9-4，如果 <code>File::open</code> 成功了，模式变量 <code>file</code> 中的文件句柄就变成了可变变量 <code>f</code> 中的值，接着函数继续执行。在 <code>Err</code> 的情况下，我们没有调用 <code>panic!</code>，而是使用 <code>return</code> 关键字提前结束整个函数，并将来自 <code>File::open</code> 的错误值（现在在模式变量 <code>e</code> 中）作为函数的错误值传回给调用者。</p>
<p>所以 <code>f</code> 中有了一个文件句柄，函数接着在变量 <code>s</code> 中创建了一个新 <code>String</code> 并调用文件句柄 <code>f</code> 的 <code>read_to_string</code> 方法来将文件的内容读取到 <code>s</code> 中。<code>read_to_string</code> 方法也返回一个 <code>Result</code> 因为它也可能会失败：哪怕是 <code>File::open</code> 已经成功了。所以我们需要另一个 <code>match</code> 来处理这个 <code>Result</code>：如果 <code>read_to_string</code> 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 <code>Ok</code> 的 <code>s</code> 中。如果<code>read_to_string</code> 失败了，则像之前处理 <code>File::open</code> 的返回值的 <code>match</code> 那样返回错误值。不过并不需要显式的调用 <code>return</code>，因为这是函数的最后一个表达式。</p>
<p>调用这个函数的代码最终会得到一个包含用户名的 <code>Ok</code> 值，或者一个包含 <code>io::Error</code> 的 <code>Err</code> 值。我们无从得知调用者会如何处理这些值。例如，如果他们得到了一个 <code>Err</code> 值，他们可能会选择 <code>panic!</code> 并使程序崩溃、使用一个默认的用户名或者从文件之外的地方寻找用户名。我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法。</p>
<p>这种传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 <code>?</code> 问号运算符来使其更易于处理。</p>
<h3 id="传播错误的简写-运算符httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml传播错误的简写-运算符"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF%E7%9A%84%E7%AE%80%E5%86%99-%E8%BF%90%E7%AE%97%E7%AC%A6">传播错误的简写：<code>?</code> 运算符</a></h3>
<p>示例 9-7 展示了一个 <code>read_username_from_file</code> 的实现，它实现了与示例 9-6 中的代码相同的功能，不过这个实现使用了 <code>?</code> 运算符：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-7：一个使用 <code>?</code> 运算符向调用者返回错误的函数</p>
<p><code>Result</code> 值之后的 <code>?</code> 被定义为与示例 9-6 中定义的处理 <code>Result</code> 值的 <code>match</code> 表达式有着完全相同的工作方式。如果 <code>Result</code> 的值是 <code>Ok</code>，这个表达式将会返回 <code>Ok</code> 中的值而程序将继续执行。如果值是 <code>Err</code>，<code>Err</code> 中的值将作为整个函数的返回值，就好像使用了 <code>return</code> 关键字一样，这样错误值就被传播给了调用者。</p>
<p>示例 9-6 中的 <code>match</code> 表达式与问号运算符所做的有一点不同：<code>?</code> 运算符所使用的错误值被传递给了 <code>from</code> 函数，它定义于标准库的 <code>From</code> trait 中，其用来将错误从一种类型转换为另一种类型。当 <code>?</code> 运算符调用 <code>from</code> 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 <code>from</code> 函数来定义如何将自身转换为返回的错误类型，<code>?</code> 运算符会自动处理这些转换。</p>
<p>在示例 9-7 的上下文中，<code>File::open</code> 调用结尾的 <code>?</code> 将会把 <code>Ok</code> 中的值返回给变量 <code>f</code>。如果出现了错误，<code>?</code> 运算符会提早返回整个函数并将一些 <code>Err</code> 值传播给调用者。同理也适用于 <code>read_to_string</code> 调用结尾的 <code>?</code>。</p>
<p><code>?</code> 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 <code>?</code> 之后直接使用链式方法调用来进一步缩短代码，如示例 9-8 所示：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-8：问号运算符之后的链式方法调用</p>
<p>在 <code>s</code> 中创建新的 <code>String</code> 被放到了函数开头；这一部分没有变化。我们对 <code>File::open(&quot;hello.txt&quot;)?</code> 的结果直接链式调用了 <code>read_to_string</code>，而不再创建变量 <code>f</code>。仍然需要 <code>read_to_string</code> 调用结尾的 <code>?</code>，而且当 <code>File::open</code> 和 <code>read_to_string</code> 都成功没有失败时返回包含用户名 <code>s</code> 的 <code>Ok</code> 值。其功能再一次与示例 9-6 和示例 9-7 保持一致，不过这是一个与众不同且更符合工程学（ergonomic）的写法。</p>
<p>说到编写这个函数的不同方法，甚至还有一个更短的写法：</p>
<p>文件名: src/main.rs</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-9: 使用 <code>fs::read_to_string</code></p>
<p>将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <code>fs::read_to_string</code> 的函数，它会打开文件、新建一个 <code>String</code>、读取文件的内容，并将内容放入 <code>String</code>，接着返回它。当然，这样做就没有展示所有这些错误处理的机会了，所以我们最初就选择了艰苦的道路。</p>
<h3 id="哪里可以使用--运算符httpskaiserygithubiotrpl-zh-cnch09-02-recoverable-errors-with-resulthtml哪里可以使用--运算符"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-02-recoverable-errors-with-result.html#%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8--%E8%BF%90%E7%AE%97%E7%AC%A6">哪里可以使用 <code>?</code> 运算符</a></h3>
<p><code>?</code> 运算符只能被用于返回值与 <code>?</code> 作用的值相兼容的函数。因为 <code>?</code> 运算符被定义为从函数中提早返回一个值，这与示例 9-6 中的 <code>match</code> 表达式有着完全相同的工作方式。示例 9-6 中 <code>match</code> 作用于一个 <code>Result</code> 值，提早返回的分支返回了一个 <code>Err(e)</code> 值。函数的返回值必须是 <code>Result</code> 才能与这个 <code>return</code> 相兼容。</p>
<p>在示例 9-10 中，让我们看看在返回值不兼容的 <code>main</code> 函数中使用 <code>?</code> 运算符会得到什么错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-10: 尝试在返回 <code>()</code> 的 <code>main</code> 函数中使用 <code>?</code> 的代码不能编译</p>
<p>这段代码打开一个文件，这可能会失败。<code>?</code> 运算符作用于 <code>File::open</code> 返回的 <code>Result</code> 值，不过 <code>main</code> 函数的返回类型是 <code>()</code> 而不是 <code>Result</code>。当编译这些代码，会得到如下错误信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="gp">$ </span>cargo run
<span class="go">   Compiling error-handling v0.1.0 (file:///projects/error-handling)
</span><span class="go">error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
</span><span class="go"> --&gt; src/main.rs:4:36
</span><span class="go">  |
</span><span class="go">3 | / fn main() {
</span><span class="go">4 | |     let f = File::open(&#34;hello.txt&#34;)?;
</span><span class="go">  | |                                    ^ cannot use the `?` operator in a function that returns `()`
</span><span class="go">5 | | }
</span><span class="go">  | |_- this function should return `Result` or `Option` to accept `?`
</span><span class="go">  |
</span><span class="go">  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
</span><span class="go"></span><span class="err">
</span><span class="err"></span><span class="go">For more information about this error, try `rustc --explain E0277`.
</span><span class="go">error: could not compile `error-handling` due to previous error
</span></code></pre></div><p>这个错误指出只能在返回 <code>Result</code> 或者其它实现了 <code>FromResidual</code> 的类型的函数中使用 <code>?</code> 运算符。为了修复这个错误，有两个选择。一个是，如果没有限制的话将函数的返回值改为 <code>Result&lt;T, E&gt;</code>。另一个是使用 <code>match</code> 或 <code>Result&lt;T, E&gt;</code> 的方法中合适的一个来处理 <code>Result&lt;T, E&gt;</code>。</p>
<p>错误信息也提到 <code>?</code> 也可用于 <code>Option&lt;T&gt;</code> 值。如同对 <code>Result</code> 使用 <code>?</code> 一样，只能在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code>。在 <code>Option&lt;T&gt;</code> 上调用 <code>?</code> 运算符的行为与 <code>Result&lt;T, E&gt;</code> 类似：如果值是 <code>None</code>，此时 <code>None</code> 会从函数中提前返回。如果值是 <code>Some</code>，<code>Some</code> 中的值作为表达式的返回值同时函数继续。示例 9-11 中有一个从给定文本中返回第一行最后一个字符的函数的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">last_char_of_first_line</span><span class="p">(</span><span class="n">text</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">text</span><span class="p">.</span><span class="n">lines</span><span class="p">().</span><span class="n">next</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">last</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-11: 在 <code>Option&lt;T&gt;</code> 值上使用 <code>?</code> 运算符</p>
<p>这个函数返回 <code>Option&lt;char&gt;</code> 因为它可能会在这个位置找到一个字符，也可能没有字符。这段代码获取 <code>text</code> 字符串 slice 作为参数并调用其 <code>lines</code> 方法，这会返回一个字符串中每一行的迭代器。因为函数希望检查第一行，所以调用了迭代器 <code>next</code> 来获取迭代器中第一个值。如果 <code>text</code> 是空字符串，<code>next</code> 调用会返回 <code>None</code>，此时我们可以使用 <code>?</code> 来停止并从 <code>last_char_of_first_line</code> 返回 <code>None</code>。如果 <code>text</code> 不是空字符串，<code>next</code> 会返回一个包含 <code>text</code> 中第一行的字符串 slice 的 <code>Some</code> 值。</p>
<p><code>?</code> 会提取这个字符串 slice，然后可以在字符串 slice 上调用 <code>chars</code> 来获取字符的迭代器。我们感兴趣的是第一行的最后一个字符，所以可以调用 <code>last</code> 来返回迭代器的最后一项。这是一个 <code>Option</code>，因为有可能第一行是一个空字符串，例如 <code>text</code> 以一个空行开头而后面的行有文本，像是 <code>&quot;\nhi&quot;</code>。不过，如果第一行有最后一个字符，它会返回在一个 <code>Some</code> 成员中。<code>?</code> 运算符作用于其中给了我们一个简介的表达这种逻辑的方式。如果我们不能在 <code>Option</code> 上使用 <code>?</code> 运算符，则不得不使用更多的方法调用或者 <code>match</code> 表达式来实现这些逻辑。</p>
<p>注意你可以在返回 <code>Result</code> 的函数中对 <code>Result</code> 使用 <code>?</code> 运算符，可以在返回 <code>Option</code> 的函数中对 <code>Option</code> 使用 <code>?</code> 运算符，但是不可以混合搭配。<code>?</code> 运算符不会自动将 <code>Result</code> 转化为 <code>Option</code>，反之亦然；在这些情况下，可以使用类似 <code>Result</code> 的 <code>ok</code> 方法或者 <code>Option</code> 的 <code>ok_or</code> 方法来显式转换。</p>
<p>目前为止，我们所使用的所有 <code>main</code> 函数都返回 <code>()</code>。<code>main</code> 函数是特殊的因为它是可执行程序的入口点和退出点，为了使程序能正常工作，其可以返回的类型是有限制的。</p>
<p>幸运的是 <code>main</code> 函数也可以返回 <code>Result&lt;(), E&gt;</code>， 示例 9-12 中的代码来自示例 9-10 不过修改了 <code>main</code> 的返回值为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> 并在结尾增加了一个 <code>Ok(())</code> 作为返回值。这段代码可以编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;hello.txt&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-12: 修改 <code>main</code> 返回 <code>Result&lt;(), E&gt;</code> 允许对 <code>Result</code> 值使用 <code>?</code> 运算符</p>
<p><code>Box&lt;dyn Error&gt;</code> 类型是一个 <strong>trait 对象</strong>（<em>trait object</em>）第十七章 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-02-trait-objects.html#%E4%B8%BA%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E8%80%8C%E8%AE%BE%E8%AE%A1%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1">“为使用不同类型的值而设计的 trait 对象”</a> 部分会做介绍。目前可以将 <code>Box&lt;dyn Error&gt;</code> 理解为 “任何类型的错误”。在返回 <code>Box&lt;dyn Error&gt;</code> 错误类型 <code>main</code> 函数中对 <code>Result</code> 使用 <code>?</code> 是允许的，因为它允许任何 <code>Err</code> 值提前返回。</p>
<p>当 <code>main</code> 函数返回 <code>Result&lt;(), E&gt;</code>，如果 <code>main</code> 返回 <code>Ok(())</code> 可执行程序会以 <code>0</code> 值退出，而如果 <code>main</code> 返回 <code>Err</code> 值则会以非零值退出；成功退出的程序会返回整数 <code>0</code>，运行错误的程序会返回非 <code>0</code> 的整数。Rust 也会从二进制程序中返回与这个惯例相兼容的整数。</p>
<p><code>main</code> 函数也可以返回任何实现了 <a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>std::process::Termination</code> trait</a> 的类型。截至本书编写时，<code>Termination</code> trait 是一个不稳定功能（unstable feature），只能用于 Nightly Rust 中，所以你不能在 稳定版 Rust（Stable Rust）中用自己的类型去实现，不过有朝一日应该可以！</p>
<p>现在我们讨论过了调用 <code>panic!</code> 或返回 <code>Result</code> 的细节，是时候回到他们各自适合哪些场景的话题了。</p>
<h1 id="四要不要-panichttpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml要不要-panic">四.<a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E8%A6%81%E4%B8%8D%E8%A6%81-panic">要不要 <code>panic!</code></a></h1>
<p>那么，该如何决定何时应该 <code>panic!</code> 以及何时应该返回 <code>Result</code> 呢？如果代码 panic，就没有恢复的可能。你可以选择对任何错误场景都调用 <code>panic!</code>，不管是否有可能恢复，不过这样就是你代替调用者决定了这是不可恢复的。选择返回 <code>Result</code> 值的话，就将选择权交给了调用者，而不是代替他们做出决定。调用者可能会选择以符合他们场景的方式尝试恢复，或者也可能干脆就认为 <code>Err</code> 是不可恢复的，所以他们也可能会调用 <code>panic!</code> 并将可恢复的错误变成了不可恢复的错误。因此返回 <code>Result</code> 是定义可能会失败的函数的一个好的默认选择。</p>
<p>在一些类似示例、原型代码（prototype code）和测试中， panic 比返回 <code>Result</code> 更为合适，不过他们并不常见。让我们讨论一下为何在示例、代码原型和测试中，以及那些人们认为不会失败而编译器不这么看的情况下， panic 是合适的。章节最后会总结一些在库代码中如何决定是否要 panic 的通用指导原则。</p>
<h3 id="示例代码原型和测试都非常适合-panichttpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml示例代码原型和测试都非常适合-panic"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E9%83%BD%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88-panic">示例、代码原型和测试都非常适合 panic</a></h3>
<p>当你编写一个示例来展示一些概念时，在拥有健壮的错误处理代码的同时也会使得例子不那么明确。例如，调用一个类似 <code>unwrap</code> 这样可能 <code>panic!</code> 的方法可以被理解为一个你实际希望程序处理错误方式的占位符，它根据其余代码运行方式可能会各不相同。</p>
<p>类似地，在我们准备好决定如何处理错误之前，<code>unwrap</code>和<code>expect</code>方法在原型设计时非常方便。当我们准备好让程序更加健壮时，它们会在代码中留下清晰的标记。</p>
<p>如果方法调用在测试中失败了，我们希望这个测试都失败，即便这个方法并不是需要测试的功能。因为 <code>panic!</code> 会将测试标记为失败，此时调用 <code>unwrap</code> 或 <code>expect</code> 是恰当的。</p>
<h3 id="当我们比编译器知道更多的情况httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml当我们比编译器知道更多的情况"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E5%BD%93%E6%88%91%E4%BB%AC%E6%AF%94%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E9%81%93%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%83%85%E5%86%B5">当我们比编译器知道更多的情况</a></h3>
<p>当你有一些其他的逻辑来确保 <code>Result</code> 会是 <code>Ok</code> 值时，调用 <code>unwrap</code> 也是合适的，虽然编译器无法理解这种逻辑。你仍然需要处理一个 <code>Result</code> 值：即使在你的特定情况下逻辑上是不可能的，你所调用的任何操作仍然有可能失败。如果通过人工检查代码来确保永远也不会出现 <code>Err</code> 值，那么调用 <code>unwrap</code> 也是完全可以接受的，这里是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">IpAddr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">home</span>: <span class="nc">IpAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></code></pre></div><p>我们通过解析一个硬编码的字符来创建一个 <code>IpAddr</code> 实例。可以看出 <code>127.0.0.1</code> 是一个有效的 IP 地址，所以这里使用 <code>unwrap</code> 是可以接受的。然而，拥有一个硬编码的有效的字符串也不能改变 <code>parse</code> 方法的返回值类型：它仍然是一个 <code>Result</code> 值，而编译器仍然会要求我们处理这个 <code>Result</code>，好像还是有可能出现 <code>Err</code> 成员那样。这是因为编译器还没有智能到可以识别出这个字符串总是一个有效的 IP 地址。如果 IP 地址字符串来源于用户而不是硬编码进程序中的话，那么就 <strong>确实</strong> 有失败的可能性，这时就绝对需要我们以一种更健壮的方式处理 <code>Result</code> 了。</p>
<h3 id="错误处理指导原则httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml错误处理指导原则"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">错误处理指导原则</a></h3>
<p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里，有害状态是指当一些假设、保证、协议或不可变性被打破的状态，例如无效的值、自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况：</p>
<ul>
<li>有害状态是非预期的行为，与偶尔会发生的行为相对，比如用户输入了错误格式的数据。</li>
<li>在此之后代码的运行依赖于不处于这种有害状态，而不是在每一步都检查是否有问题。</li>
<li>没有可行的手段来将有害状态信息编码进所使用的类型中的情况。我们会在第十七章 <a href="https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html#%E5%B0%86%E7%8A%B6%E6%80%81%E5%92%8C%E8%A1%8C%E4%B8%BA%E7%BC%96%E7%A0%81%E4%B8%BA%E7%B1%BB%E5%9E%8B">“将状态和行为编码为类型”</a> 部分通过一个例子来说明我们的意思。</li>
</ul>
<p>如果别人调用你的代码并传递了一个没有意义的值，最好的情况也许就是 <code>panic!</code> 并警告使用你的库的人他的代码中有 bug 以便他能在开发时就修复它。类似的，如果你正在调用不受你控制的外部代码，并且它返回了一个你无法修复的无效状态，那么 <code>panic!</code> 往往是合适的。</p>
<p>然而当错误预期会出现时，返回 <code>Result</code> 仍要比调用 <code>panic!</code> 更为合适。这样的例子包括解析器接收到格式错误的数据，或者 HTTP 请求返回了一个表明触发了限流的状态。在这些例子中，应该通过返回 <code>Result</code> 来表明失败预期是可能的，这样将有害状态向上传播，调用者就可以决定该如何处理这个问题。使用 <code>panic!</code> 来处理这些情况就不是最好的选择。</p>
<p>当代码对值进行操作时，应该首先验证值是有效的，并在其无效时 <code>panic!</code>。这主要是出于安全的原因：尝试操作无效数据会暴露代码漏洞，这就是标准库在尝试越界访问数组时会 <code>panic!</code> 的主要原因：尝试访问不属于当前数据结构的内存是一个常见的安全隐患。函数通常都遵循 <strong>契约</strong>（<em>contracts</em>）：他们的行为只有在输入满足特定条件时才能得到保证。当违反契约时 panic 是有道理的，因为这通常代表调用方的 bug，而且这也不是那种你希望所调用的代码必须处理的错误。事实上所调用的代码也没有合理的方式来恢复，而是需要调用方的 <strong>程序员</strong> 修复其代码。函数的契约，尤其是当违反它会造成 panic 的契约，应该在函数的 API 文档中得到解释。</p>
<p>虽然在所有函数中都拥有许多错误检查是冗长而烦人的。幸运的是，可以利用 Rust 的类型系统（以及编译器的类型检查）为你进行很多检查。如果函数有一个特定类型的参数，可以在知晓编译器已经确保其拥有一个有效值的前提下进行你的代码逻辑。例如，如果你使用了一个并不是 <code>Option</code> 的类型，则程序期望它是 <strong>有值</strong> 的并且不是 <strong>空值</strong>。你的代码无需处理 <code>Some</code> 和 <code>None</code> 这两种情况，它只会有一种情况就是绝对会有一个值。尝试向函数传递空值的代码甚至根本不能编译，所以你的函数在运行时没有必要判空。另外一个例子是使用像 <code>u32</code> 这样的无符号整型，也会确保它永远不为负。</p>
<h3 id="创建自定义类型进行有效性验证httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml创建自定义类型进行有效性验证"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E6%80%A7%E9%AA%8C%E8%AF%81">创建自定义类型进行有效性验证</a></h3>
<p>让我们使用 Rust 类型系统的思想来进一步确保值的有效性，并尝试创建一个自定义类型以进行验证。回忆一下第二章的猜猜看游戏，我们的代码要求用户猜测一个 1 到 100 之间的数字，在将其与秘密数字做比较之前我们从未验证用户的猜测是位于这两个数字之间的，我们只验证它是否为正。在这种情况下，其影响并不是很严重：“Too high” 或 “Too low” 的输出仍然是正确的。但是这是一个很好的引导用户得出有效猜测的辅助，例如当用户猜测一个超出范围的数字或者输入字母时采取不同的行为。</p>
<p>一种实现方式是将猜测解析成 <code>i32</code> 而不仅仅是 <code>u32</code>，来默许输入负数，接着检查数字是否在范围内：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">trim</span><span class="p">().</span><span class="n">parse</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">continue</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The secret number will be between 1 and 100.&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">guess</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secret_number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>if</code> 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 <code>continue</code> 开始下一次循环，请求另一个猜测。<code>if</code> 表达式之后，就可以在知道 <code>guess</code> 在 1 到 100 之间的情况下与秘密数字作比较了。</p>
<p>然而，这并不是一个理想的解决方案：如果让程序仅仅处理 1 到 100 之间的值是一个绝对需要满足的要求，而且程序中的很多函数都有这样的要求，在每个函数中都有这样的检查将是非常冗余的（并可能潜在的影响性能）。</p>
<p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。示例 9-13 中展示了一个定义 <code>Guess</code> 类型的方法，只有在 <code>new</code> 函数接收到 1 到 100 之间的值时才会创建 <code>Guess</code> 的实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">value</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Guess</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="fm">panic!</span><span class="p">(</span><span class="s">&#34;Guess value must be between 1 and 100, got {}.&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">Guess</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>示例 9-13：一个 <code>Guess</code> 类型，它只在值位于 1 和 100 之间时才继续</p>
<p>首先，我们定义了一个包含 <code>i32</code> 类型字段 <code>value</code> 的结构体 <code>Guess</code>。这里是储存猜测值的地方。</p>
<p>接着在 <code>Guess</code> 上实现了一个叫做 <code>new</code> 的关联函数来创建 <code>Guess</code> 的实例。<code>new</code> 定义为接收一个 <code>i32</code> 类型的参数 <code>value</code> 并返回一个 <code>Guess</code>。<code>new</code> 函数中代码的测试确保了其值是在 1 到 100 之间的。如果 <code>value</code> 没有通过测试则调用 <code>panic!</code>，这会警告调用这个函数的程序员有一个需要修改的 bug，因为创建一个 <code>value</code> 超出范围的 <code>Guess</code> 将会违反 <code>Guess::new</code> 所遵循的契约。<code>Guess::new</code> 会出现 panic 的条件应该在其公有 API 文档中被提及；第十四章会涉及到在 API 文档中表明 <code>panic!</code> 可能性的相关规则。如果 <code>value</code> 通过了测试，我们新建一个 <code>Guess</code>，其字段 <code>value</code> 将被设置为参数 <code>value</code> 的值，接着返回这个 <code>Guess</code>。</p>
<p>接着，我们实现了一个借用了 <code>self</code> 的方法 <code>value</code>，它没有任何其他参数并返回一个 <code>i32</code>。这类方法有时被称为 <em>getter</em>，因为它的目的就是返回对应字段的数据。这样的公有方法是必要的，因为 <code>Guess</code> 结构体的 <code>value</code> 字段是私有的。私有的字段 <code>value</code> 是很重要的，这样使用 <code>Guess</code> 结构体的代码将不允许直接设置 <code>value</code> 的值：调用者 <strong>必须</strong> 使用 <code>Guess::new</code> 方法来创建一个 <code>Guess</code> 的实例，这就确保了不会存在一个 <code>value</code> 没有通过 <code>Guess::new</code> 函数的条件检查的 <code>Guess</code>。</p>
<p>于是，一个接收（或返回） 1 到 100 之间数字的函数就可以声明为接收（或返回） <code>Guess</code>的实例，而不是 <code>i32</code>，同时其函数体中也无需进行任何额外的检查。</p>
<h2 id="总结httpskaiserygithubiotrpl-zh-cnch09-03-to-panic-or-not-to-panichtml总结"><a href="https://kaisery.github.io/trpl-zh-cn/ch09-03-to-panic-or-not-to-panic.html#%E6%80%BB%E7%BB%93">总结</a></h2>
<p>Rust 的错误处理功能被设计为帮助你编写更加健壮的代码。<code>panic!</code> 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。Rust 类型系统的 <code>Result</code> 枚举代表操作可能会在一种可以恢复的情况下失败。可以使用 <code>Result</code> 来告诉代码调用者他需要处理潜在的成功或失败。在适当的场景使用 <code>panic!</code> 和 <code>Result</code> 将会使你的代码在面对不可避免的错误时显得更加可靠。</p>
<p>现在我们已经见识过了标准库中 <code>Option</code> 和 <code>Result</code> 泛型枚举的能力了，在下一章让我们聊聊泛型是如何工作的，以及如何在你的代码中使用他们。</p>

    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://qkgoalkeeper.github.io/tags/rust%E6%95%99%E7%A8%8B">rust教程</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://qkgoalkeeper.github.io/categories/rust">rust</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://qkgoalkeeper.github.io/post/rustthe_rust_book9%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" data-title="rust：the_rust_book（9）错误处理" data-tsina="5852167252" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  



</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/golang" title="golang">golang<sup>6</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e5%91%a8%e8%b5%9b" title="leetcode周赛">leetcode周赛<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98" title="leetcode每日一题">leetcode每日一题<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%981-100" title="leetcode简单题1-100">leetcode简单题1-100<sup>21</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98101-200" title="leetcode简单题101-200">leetcode简单题101-200<sup>25</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98201-300" title="leetcode简单题201-300">leetcode简单题201-300<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/python" title="python">python<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/rust" title="rust">rust<sup>16</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e4%bb%a5%e5%a4%aa%e5%9d%8a" title="以太坊">以太坊<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%85%b6%e4%bb%96" title="其他">其他<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>4</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be%e7%9b%b8%e5%85%b3" title="区块链相关">区块链相关<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%be%e7%a8%8b" title="大三上数据库课程">大三上数据库课程<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8bweb%e7%bc%96%e7%a8%8b%e8%af%be%e7%a8%8b" title="大三下web编程课程">大三下web编程课程<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e5%9b%9bleetcode%e7%ae%97%e6%b3%95%e5%88%b7%e9%a2%98" title="大四leetcode算法刷题">大四leetcode算法刷题<sup>300</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb" title="源码解读">源码解读<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://qkgoalkeeper.github.io/tags/bfs" title="bfs">bfs<sup>13</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" title="c&#43;&#43;">c&#43;&#43;<sup>289</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/dfs" title="dfs">dfs<sup>27</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang" title="golang">golang<sup>40</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" title="golang语法">golang语法<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/javascript" title="javascript">javascript<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/leetcode" title="leetcode">leetcode<sup>396</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/rust%e6%95%99%e7%a8%8b" title="rust教程">rust教程<sup>16</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/solidity" title="solidity">solidity<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" title="二分法">二分法<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" title="代码">代码<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" title="优先队列">优先队列<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" title="位运算">位运算<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" title="分治法">分治法<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" title="前缀和">前缀和<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" title="动态规划">动态规划<sup>32</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" title="单调队列">单调队列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" title="双指针">双指针<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" title="哈希表">哈希表<sup>7</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" title="堆">堆<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" title="字典树">字典树<sup>6</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" title="字符串">字符串<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" title="并查集">并查集<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" title="序列化">序列化<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" title="拓扑排序">拓扑排序<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" title="排列">排列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" title="排序">排序<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" title="数学">数学<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" title="数组">数组<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" title="栈">栈<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" title="树">树<sup>25</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" title="源码编译">源码编译<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb" title="源码解读">源码解读<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" title="滑动窗口">滑动窗口<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" title="线段树">线段树<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" title="缓存">缓存<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" title="贪心">贪心<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" title="贪心法">贪心法<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" title="链表">链表<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" title="队列">队列<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" title="随机数">随机数<sup>3</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-11">2022年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-08">2022年08月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-07">2022年07月</a><span class="archive-list-count">22</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-06">2022年06月</a><span class="archive-list-count">26</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-05">2022年05月</a><span class="archive-list-count">14</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-04">2022年04月</a><span class="archive-list-count">24</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-03">2022年03月</a><span class="archive-list-count">32</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-02">2022年02月</a><span class="archive-list-count">61</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-01">2022年01月</a><span class="archive-list-count">77</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-12">2021年12月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-11">2021年11月</a><span class="archive-list-count">30</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-10">2021年10月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-09">2021年09月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-06">2021年06月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-04">2021年04月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-11">2020年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-08">2020年08月</a><span class="archive-list-count">70</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://qkgoalkeeper.github.io/tags/bfs" style="font-size: 12px;">bfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" style="font-size: 12px;">c&#43;&#43;</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/dfs" style="font-size: 12px;">dfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang" style="font-size: 12px;">golang</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" style="font-size: 12px;">golang语法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/javascript" style="font-size: 12px;">javascript</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/leetcode" style="font-size: 12px;">leetcode</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/rust%e6%95%99%e7%a8%8b" style="font-size: 12px;">rust教程</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/solidity" style="font-size: 12px;">solidity</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" style="font-size: 12px;">二分法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" style="font-size: 12px;">代码</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" style="font-size: 12px;">优先队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" style="font-size: 12px;">位运算</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" style="font-size: 12px;">分治法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" style="font-size: 12px;">前缀和</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" style="font-size: 12px;">动态规划</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" style="font-size: 12px;">区块链</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" style="font-size: 12px;">单调队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" style="font-size: 12px;">双指针</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" style="font-size: 12px;">哈希表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" style="font-size: 12px;">堆</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" style="font-size: 12px;">字典树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" style="font-size: 12px;">字符串</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" style="font-size: 12px;">并查集</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" style="font-size: 12px;">序列化</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" style="font-size: 12px;">拓扑排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" style="font-size: 12px;">排列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" style="font-size: 12px;">排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" style="font-size: 12px;">数学</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" style="font-size: 12px;">数据库</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" style="font-size: 12px;">数组</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" style="font-size: 12px;">栈</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" style="font-size: 12px;">树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" style="font-size: 12px;">源码编译</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb" style="font-size: 12px;">源码解读</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" style="font-size: 12px;">滑动窗口</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" style="font-size: 12px;">王道机试指南</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" style="font-size: 12px;">线段树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" style="font-size: 12px;">缓存</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" style="font-size: 12px;">论文解读</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" style="font-size: 12px;">贪心</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" style="font-size: 12px;">贪心法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" style="font-size: 12px;">链表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" style="font-size: 12px;">队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" style="font-size: 12px;">随机数</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  <div class="line">
    <span></span>
    
    <div style='background:no-repeat url("https://qkgoalkeeper.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <section class="info">
    <p>ECNU数据学院在读 <br/> 知乎主页 :https://www.zhihu.com/people/hao-lai-wu-shou-men-yuan <br/>QQ :1421812601</p>
  </section>
  <div class="social-font clearfix">
    <a href='http://weibo.com/qkgoalkeeper' target="_blank" title="weibo"></a>
    <a href='https://twitter.com/coderzh' target="_blank" title="twitter"></a>
    <a href='https://github.com/qkgoalkeeper' target="_blank" title="github"></a>
    <a href='https://www.facebook.com/coderzh' target="_blank" title="facebook"></a>
    <a href='https://www.linkedin.com/coderzh' target="_blank" title="linkedin"></a>
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2022
    
    <a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a>
    
  </p>
</div>
</footer>
  <script src="https://qkgoalkeeper.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/qkgoalkeeper.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://b.bshare.cn/barCode?site=weixin&url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
