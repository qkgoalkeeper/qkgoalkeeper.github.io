<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>atc15-paper-wu论文解读 - qkgoalkeeper&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
  
  <meta name="description" content="LSM trie：一种基于LSM树的用于存储小数据的超大键值存储 0.摘要 键值（KV）存储已成为当今数据中心中大规模应用的主干。单个服务器上存储的数">
  
  <meta itemprop="name" content="atc15-paper-wu论文解读 - qkgoalkeeper&#39;s blog">
  <meta itemprop="description" content="LSM trie：一种基于LSM树的用于存储小数据的超大键值存储 0.摘要 键值（KV）存储已成为当今数据中心中大规模应用的主干。单个服务器上存储的数">
  <meta itemprop="image" content="https://qkgoalkeeper.github.io/img/author.jpg">
  
  
  <meta name="twitter:description" content="">
  
  <link rel="shortcut icon" href="https://qkgoalkeeper.github.io/img/favicon.ico"/>
  <link rel="apple-touch-icon" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="apple-touch-icon-precomposed" href="https://qkgoalkeeper.github.io/apple-touch-icon.png" />
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/highlight/styles/github.css">
  <script src="https://qkgoalkeeper.github.io/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/font/hack/css/hack.min.css">
  <link rel="stylesheet" href="https://qkgoalkeeper.github.io/css/style.css">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-175507250-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-175507250-1');
</script>
  

</head>

<body>
  <header>
    <div>
  <div id="imglogo">
    <a href="https://qkgoalkeeper.github.io/"><img src='https://qkgoalkeeper.github.io/img/logo.svg' alt="qkgoalkeeper&#39;s blog" title="qkgoalkeeper&#39;s blog"/></a>
  </div>
  <div id="textlogo">
    <h1 class="site-name"><a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a></h1>
    <h2 class="blog-motto">ECNU数据学院在读</h2>
  </div>
  <div class="navbar"><a class="navbutton navmobile" href="#" title="menu"></a></div>
  <nav class="animated">
    <ul>
      
      
      <li><a href="/">首页</a></li>
      
      <li><a href="/about">关于</a></li>
      
      
      <li>
        <form class="search" method="get" action="https://www.google.com/search">
          <div>
            <input type="text" id="search" name="q" placeholder='Search'>
          </div>
        </form>
      </li>
    </ul>
  </nav>
</div>

  </header>
  <div id="container">
    <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody">
    <header class="article-info clearfix">
  <h1 itemprop="name">
      <a href="https://qkgoalkeeper.github.io/post/atc15-paper-wu%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" title="atc15-paper-wu论文解读" itemprop="url">atc15-paper-wu论文解读</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://qkgoalkeeper.github.io/" title="qk">qk</a>
    
  </p>
  <p class="article-time">
    <time datetime="2022-01-02 11:55:19 &#43;0800 CST" itemprop="datePublished">2022年01月02日</time>
  </p>
</header>

	<div class="article-content">
    
		<div class="toc-article">
			<strong class="toc-title">文章目录</strong>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#0摘要">0.摘要</a></li>
    <li><a href="#1简介">1.简介</a></li>
    <li><a href="#2lsm-trie设计">2.LSM-trie设计</a>
      <ul>
        <li><a href="#21-lsm树中的写入放大">2.1 LSM树中的写入放大</a></li>
        <li><a href="#22-减少lsm树压缩中写入放大的挑战">2.2 减少LSM树压缩中写入放大的挑战</a></li>
        <li><a href="#23-sstable-trie一种最小化写放大的设计">2.3 sstable-trie：一种最小化写放大的设计</a></li>
        <li><a href="#24-lsm--trie存放小item的大型存储">2.4 LSM  trie：存放小item的大型存储</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>
    
    <h1 id="lsm-trie一种基于lsm树的用于存储小数据的超大键值存储">LSM trie：一种基于LSM树的用于存储小数据的超大键值存储</h1>
<h2 id="0摘要">0.摘要</h2>
<p>键值（KV）存储已成为当今数据中心中大规模应用的主干。单个服务器上存储的数据集可以增长到数十亿个KV项或许多TB，而单个数据项通常很小（其值只有几个字节）。有效地组织这样一个超大的KV存储以支持快速访问是一项艰巨的任务。当前KV存储系统存在以下一个或多个不足之处：（1）数据写入放大率极高，（2）索引集过大（3）读性能急剧下降，索引溢出内存。为了解决这个问题，我们提出了LSM  trie，这是一种KV存储系统，它大大减少了用于定位KV项的元数据，减少了一个数量级的写入放大，并且每次KV读取只需要两次磁盘访问，即使在内存中只能保存少于10%的元数据（Bloom过滤器）时也是如此。为此，LSM-trie构造了一个trie前缀树，它以层次结构存储数据，并使用比LSM-tree更高效的压缩方法对数据进行重新组织。我们的实验表明，LSM-trie可以将LevelDB（一种最先进的KV系统）的写入和读取吞吐量分别提高20倍和10倍。</p>
<h2 id="1简介">1.简介</h2>
<p>键值（KV）存储在保证许多网站的服务质量和用户体验方面发挥着关键作用，包括亚马逊的Dynamo[22]，LinkedIn的V  oldemort[7]，Apache的Cassandra[1]，谷歌的LevelDB[4]，Facebook的andRocksDB[11]。许多高要求的数据密集型互联网应用，如社交网络、电子商务和在线游戏，都依赖于快速访问商店中的数据以获得优质服务。</p>
<p>KV  store在高效实现方面有其独特的优势，它具有扁平的数据组织和使用命令（如用于写入数据的Put（key，value）、用于读取数据的Get（key）和Delete（key））的简化接口。然而，在工作负载特性方面存在一些趋势，这些趋势严重挑战了当今最先进的KV存储实现的高性能和高可扩展性。</p>
<p>首先，非常小的KV项目非常普遍。例如，Facebook曾报告其90%的Memcached  KV池存储的KV项的值小于500字节[13]。在一个专用于存储用户帐户状态的KV池（USR）中，所有值均为2字节。在其非特定的通用池（ETC）中，2、3或11字节的值加起来占存储请求总数的40%。在频繁访问数据的复制池中，99%的KV项小于68字节[26]。在通配符（默认池）和专用于特定应用程序的池中，75%的项小于363字节。在Twitter的KV工作负载中，经过压缩后，每条推文只有362字节，其中只有46字节的文本[3]。在Instagram的一个KV工作负载中，key是媒体ID，value是用户ID。每个KV item的大小只有两个字节[10]。对于给定容量的存储，较小的KV项需要更多元数据来定位它们。元数据可以包括用于定位数据块（例如，4KB磁盘块）的索引和用于确定数据块中是否存在数据的Bloom过滤器。</p>
<p>其次，对单个KV服务器的KV存储容量的需求不断增加。不断增长的需求不仅源于数据密集型应用程序，还源于使用较少的服务器托管分布式存储的成本效益。如今，使用硬盘或SSD在一台服务器上托管大TB的KV存储是一种经济的选择。然而，这将显著增加元数据大小并使内存受到限制，尤其是当重要应用程序（如MapReduce作业）被调度到存储所在的集群时，内存资源与存储服务竞争[19,33]。</p>
<p>第三，许多KV存储对读写都要求高性能。据报道，雅虎典型低延迟工作负载中的读写计数比率近年来已从2到9之间的任何可能值变为1左右[29]。在Yahoo的YCSB基准测试套件的五个核心工作负载中，其中两个具有相同的读写请求份额[18]。例如LevelDB的KV存储，通过在多个级别组织数据来优化写入。但是，当并非所有元数据都可以保存在内存中时，需要多个磁盘读取，每个磁盘读取一个级别的元数据，以满足读取请求，从而降低读取性能。同时，对于某些KV存储，如SILT[24]，尝试通过最小化元数据大小来优化读取，而写入性能可能会在不进行多级增量压缩的情况下受到影响。</p>
<p>在本文中，我们提出了LSM  trie，这是一种KV存储系统，可以在一台服务器上容纳数十亿个容量为数个TB的小型项目，并且内存需求有限。它支持每秒超过500K次写入的持续吞吐量，以及每秒超过50K次读取的持续吞吐量，即使对于没有任何位置的工作负载也是如此，因此几乎不需要caching的帮助。为了实现这一点，LSM-trie使用了三种新技术。首先，它将指数增长模式集成到LSM树（对数结构合并树）中，LSM树是一种常用的KV存储组织，具有线性增长模式。这使得压缩设计能够将写放大减少一个数量级，并大大提高写吞吐量。由于数据修改和删除也作为存储实现中的写入进行处理，因此需要高写入吞吐量。其次，使用trie或前缀树来组织存储中的数据，LSM-trie几乎消除了索引。这允许在内存中保存更多和更强的Bloom过滤器，从而加快读取请求的服务速度。第三，当Bloom筛选器变得太大而无法完全保存在内存中时，LSM  trie可确保磁盘上的Bloom筛选器群集化，以便在大多数情况下，只需读取一个4KB块即可定位数据。</p>
<p>实验表明，LSM  trie与LevelDB、RocksDB和SILT等方案相比，无论系统配置（如内存大小、存储大小、存储设备（SSD或HDD）和访问模式（统一或Zipfian密钥分布）如何，都能将写入吞吐量显著提高20倍。LSM-trie还可以显著提高读取吞吐量，尤其是当可用于运行KV存储的内存受到限制时，提高可达10倍。</p>
<p>请注意，LSM-trie使用散列函数进行数据组织，因此它不支持范围搜索，在许多重要的KV store的设计中也做出了类似的选择，包括亚马逊的Dynamo[22]、LinkedIn的V  oldermort[7]和SILT[24]，因为用户并不总是需要这个命令。此外，通过使用B-link树[17]或dPi树[25]在这些基于散列的存储上方维护索引，可以使用一些技术来支持该命令，并且实验研究表明，就本机支持该命令的存储和依赖外部支持的存储之间的范围搜索性能而言，“没有绝对赢家”[28].</p>
<h2 id="2lsm-trie设计">2.LSM-trie设计</h2>
<p>LSM  trie的设计是由LSM树的数据组织和压缩方案导致的过大写放大引起的[27]。在本节中，我们将在LevelDB的上下文中描述这个问题，LevelDB是Google的LSM树的一个流行实现。然后，我们将在第2节中描述一个基于trie的LSM树实现，它可以显著减少写放大。3.然而，这个优化的LSM树仍然保留一个索引，该索引随着存储大小而增长，最终成为系统可伸缩性的障碍。此外，它可能需要在具有大型存储的磁盘上多次读取Bloom筛选器。在第2.4节，我们描述了一种方法，其中KV项被散列到单独的存储桶中，索引被相应地删除，Bloom过滤器被分组在一起以支持高效访问。</p>
<h3 id="21-lsm树中的写入放大">2.1 LSM树中的写入放大</h3>
<p>基于LSM树的KV存储设计有两个目标：（1）新数据必须快速进入存储以支持高吞吐量写入；和（2）存储中的KV项目进行分类，以支持快速数据定位。我们以一个具有代表性的设计LevelDB为例来解释同时实现这两个目标所面临的挑战。</p>
<p>为了达到第一个目标，LevelDB以较大的单位（几兆字节）写入磁盘，以生成一个名为SSTABLE的磁盘数据结构。具体地说，LevelDB首先使用内存缓冲区（称为MEMTABLE）来接收传入的KV项。当MemTable已满时，它会写入磁盘，成为不可变的SSTable。SSTable中的keyvalue项根据其键进行排序。SSTable存储为文件，KV项放置在文件的4KB块中。为了在SSTable中定位KV项，LevelDB在文件中放置一个索引，记录每个块中第一个KV项的键。通过对索引进行二分搜索，LevelDB知道KV项可能位于哪个块中。因为4KB块是一个磁盘访问单元，所以不需要维护更大的索引来确定块内每个项的字节偏移量。但是，索引不会告诉一个项是否实际在块中。否则，访问该块是不必要的，并且会显著增加读取延迟。为此，LevelDB为每个块维护一个Bloom过滤器，以指示其中是否有项[16]。为了将误报率降至最低，过滤器的大小必须与块中的项目数成比例，通常每个项目10–16位。</p>
<p>为了实现第二个目标，LevelDB构建了一个多级树状结构，以逐步对KV项进行排序。如图1a所示，刚从MemTables转换而来的新SSTables被放置在Level0中。为了快速接纳传入项，新SSTables中的项不会立即与现有SSTables中的项在0级进行排序。相反，每个SSTABLE都成为0级的子级（L0.0、L0.1、L0.2…）（见图1a）。在后台，LevelDB  merge对0级的sstables进行排序，以生成级别1（L1）的非重叠sstable列表，该操作称为compaction。为了快速将更多数据排序到一个列表中，从级别1开始，没有子级别，并且两个相邻级别大小的比率较大（大小（Lk +1）/大小（Lk），其中k=0,1，…）。我们将比率放大因子命名为AF in  short，默认情况下，它在LevelDB中为10。由于每个级别（LK1）都可能是其直接上级（Lk）的10倍大，因此存储在每个级别上都会不断生成指数级更大的排序列表，并且在只有几个级别的情况下变得非常大。但是，这种指数增长模式会导致过大的写入放大率，即对磁盘的实际写入量与用户请求写入的数据量之间的比率。由于每个级别所覆盖的键范围大致相同，要将某一级别的一个SSTable向下推到下一个较低级别DB需要读取此SSTable和较低级别（最坏情况下）的十个SSTable，它们的整个键范围与SSTable的键范围匹配。然后对它们进行合并排序，并将11个结果SSTables写入较低级别。因此写放大率为11（或AF+1）。对于达到k级（k=0,1,2，…）的新keyvalue项，写入放大比可以达到k×（AF  1）。当K值达到5或更大时，放大率可能变得不可接受的大（55或更大）。这样一个昂贵的压缩操作可能会消耗大部分I/O带宽，留下很少用于服务前端用户请求。</p>
<p>对于给定容量的存储，通过限制级别数量来减少写放大的努力将产生相反的效果。一个例子是存储库[24]，它基本上有两个级别（HashStore和SortedStore）。当存储区变大时，其SortedStore比HashStore大得多（即使使用了多个HashStore）。这导致其写入放大率非常高（请参见第3节了解测量结果），这证明了在基于LSM树的存储中使用多个级别进行渐进压缩是合理的。</p>
<h3 id="22-减少lsm树压缩中写入放大的挑战">2.2 减少LSM树压缩中写入放大的挑战</h3>
<p>compaction需要读取排序列表（一个Lk的SSTable和多个与它的键范围相匹配的Lk +1 SSTable），将它们合并到一个排序列表中，然后将其写回LK +1。虽然操作中涉及的任何数据都有助于写入放大，但正是来自较低级别（Lk +1）的较大数据集使得放大率过大。由于compaction的目的是将数据推送到较低的级别，因此访问上层数据对缓解放大的贡献是必要的。如果我们只允许上层的数据参与压缩，那么写放大可以最小化。</p>
<p>为此，我们引入线性增长模式。如图1b所示，除了0级之外，其他级别还包括许多子级别。属于同一级别的子级别具有相同（最大）大小。当在某个级别上生成新的子级别时，存储在此级别上线性增长。但是，当生成一个新的级别时，storeexponentiallygrows（按AF倍）将被删除。在门店增长期间，使用线性和指数增长模式交替产生新（子）层级。换句话说，每个LevelDB的级别都被多个子级别替换。为了最小化写放大，我们可以合并一个级别（Lk）的子级别中的排序数据，以生成下一个较低级别（Lk +1）的新子级别。由于每个子级别中的数据量相似，但下一个较低级别中没有数据，因此可以将写放大降至最低。</p>
<p>LevelDB实现中的一个关键考虑因素是根据涉及的SSTABLE数量（或AF+1）来限制每个压缩的最大成本，以防止后台操作中断性地降低用户请求的服务速度。出于同样的目的，在压缩中使用线性增长模式时，我们在一个级别（Lk）的每个子级别选择一个SSTable，并将这些SSTable合并到Lk +1级别的非重叠SSTable序列中。</p>
<p>压缩中涉及的关键帧范围表示压缩的关键帧范围。在所有将数据从Lk移动到Lk+1的压缩中，我们必须确保它们的key范围不重叠，以防止Lk+1级别的任何两个SSTABLE具有重叠的key范围。然而，LevelDB数据组织无法实现这一点，因为每个子级别的已排序KV项都根据表的固定容量（例如32MB）放入SSTables中。SSTable的key范围大小可能是高度可变的，并且范围在不同子级别中的分布可能不同。因此，上述压实范围不太可能不重叠。</p>
<h3 id="23-sstable-trie一种最小化写放大的设计">2.3 sstable-trie：一种最小化写放大的设计</h3>
<p>为了在压缩中启用不同的键范围，我们不使用KV项在排序列表中的排名（或其位置）来确定它在某个级别中所属的SSTable。相反，我们首先对key使用加密散列函数，如SHA-1，然后使用散列后key进行确定。这实际上将LevelDB的多级结构转换为一个trie，如图2所示。因此，我们将其命名为优化的leveldb sstable  trie。SSTable  trie是一种前缀树，其节点是容器，每个容器包含多个SSTable表。每个节点都有固定数量的子节点，其数量相当于LevelDB中的af（放大系数）。如果该数字假定为8，则可以通过三位二进制（000、001、…、或111）来区分节点的子节点。trie中的节点也可以由二进制串标识，通常具有更多位。从根节点开始，我们可以将二进制串分割为连续的三个位组，其中第一个组表示根的子级。由于每个位组标识对应节点的子节点，因此我们可以按照位组查找到对应于二进制文件的节点的路径。trie中具有相同深度的所有节点构成trie结构中的一个级别，相当于LevelDB中的一个级别。每个容器都有一堆SSTables（见图2）。trie标高由多个稳定桩组成。trie标高桩相同位置的所有SSTABLE构成trie的子标高，对应于标高DB中的子标高。</p>
<p>由于每个KV项也由二进制串（哈希键）标识，因此其在级别中的位置是通过将哈希键的前缀与级别中节点的标识相匹配来确定的（见图2）。与LevelDB级别的KV项目放置不同，trie级别的KV项目位置独立于同一级别的其他键。压实操作仅涉及一个容器中的一堆SSTABLE。压缩后，根据各自的散列键将堆中的项目移动到容器的子项中，而不是像LevelDB那样在排序列表中进行排名。通过使用散列键，每个压缩的键范围是唯一的，并且压缩生成的SSTABLE是不重叠的。这样的压缩导致最小的写放大。图3说明了trie中的压缩操作。请注意，使用SHA1作为哈希函数来生成哈希键可以保证在每个（子）级别上均匀分布KV项，无论原始键的分布如何。</p>
<h3 id="24-lsm--trie存放小item的大型存储">2.4 LSM  trie：存放小item的大型存储</h3>
<p>我们的目标是在服务器中实现容量和KV项计数方面的非常大的KV存储。设计这样一个存储的一大挑战是其元数据的管理，这些元数据通常必须在核心（DRAM）之外。对于给定的KV项目，每个（子）级别最多有一个SSTable可将项目存储在LevelDB中，因为每个（子）级别都已排序，且其SSTables的键范围不重叠。存储维护一个非常小的内存搜索树，以标识每个级别的SSTable。在每个SSTable文件的末尾存储一个索引和Bloom过滤器，以便于在表中搜索。索引USENIX协会2015  USENIX年度技术会议75用于识别4KB区块，并为每个区块维护一个Bloom过滤器，以判断区块中是否可能存在KV项目。KV存储中的索引和Bloom过滤器可能会增长很大。具体来说，索引的大小与存储的容量（或4KB块的数量）成正比，Bloom过滤器的大小与项目总数成正比。对于大型存储，元数据很难在内存中容纳。例如，一个10TB存储容量为200B  KV的项目需要大约125GB的空间来存储每键10位的过滤器，30GB的空间来存储索引。虽然现在甚至在不久的将来，在一台服务器上安装一个HDD阵列甚至一个10TB大小的SSD阵列都是可以负担得起的，但将如此大的DRAM仅用于元数据并不划算。因此，我们必须假设只有当存储区变大时，大部分元数据才在磁盘上。因为在KV存储工作负载中通常不假定位置[14,31]，所以事实上大多数读取都需要在读取数据之前从磁盘检索元数据。关键问题是如何在为KV项的读取请求提供服务时最小化元数据读取的数量。这些元数据可能存储在多个SSTABLE中，每个SSTABLE处于不同的级别。由于元数据与单个SSM表关联并分布在这些表上，因此在当前LSM树的结构中，多次读取似乎是不可避免的。SSTable  trie引入了线性增长模式，这导致了LSM  trie的设计，它删除了几乎所有的索引，并允许每个读取请求访问一个元数据磁盘。在描述设计之前，让我们先讨论一下SSTable  trie。使用线性增长模式可以显著增加级别数。由于多级KV项目组织需要从级别0开始，对请求的项目进行连续的级别搜索，直到找到该项目为止，因此它依赖于每个级别中的Bloom过滤器，在没有项目的情况下跳过尽可能多的级别。然而，由于每个Bloom过滤器都有一个误报率（对于每个项目10位的设置，误报率约为0.82%），因此，随着级别计数的增加（例如，从7级结构的5.7%到56级结构的46%），搜索没有该项目的级别的概率会增加。因此，必须通过使用更多比特来增强Bloom过滤器。例如，使用每项16位的设置将确保整个120级结构的误报率低于5%。与磁盘容量相比，较大的Bloom过滤器的额外磁盘空间最小。正如我们将要展示的，LSM-trie删除索引，并且只使用一次磁盘访问来读取Bloom过滤器。</p>
<h4 id="241-核心外元数据">2.4.1 核心外元数据</h4>
<p>对于给定的KV项，每个（子）级别最多有一个SSTable可将该项存储在LevelDB中，因为每个（子）级别都已排序，且其SSTables的键范围不重叠。存储维护一个非常小的内存搜索树，以标识每个级别的SSTable。在每个SSTable文件的末尾存储一个索引和Bloom过滤器，以便于在表中搜索。索引用于识别4KB区块，并为每个区块维护一个Bloom过滤器，以判断区块中是否可能存在KV项目。KV存储中的索引和Bloom过滤器可能会增长很大。具体来说，索引的大小与存储的容量（或4KB块的数量）成正比，Bloom过滤器的大小与项目总数成正比。对于大型存储，元数据很难在内存中容纳。例如，一个10TB存储容量为200B  KV的项目需要大约125GB的空间来存储每键10位的过滤器，30GB的空间来存储索引。虽然现在甚至在不久的将来，在一台服务器上安装一个HDD阵列甚至一个10TB大小的SSD阵列都是可以负担得起的，但将如此大的DRAM仅用于元数据并不划算。因此，我们必须假设只有当存储区变大时，大部分元数据才在磁盘上。因为在KV存储工作负载中通常不假定位置[14,31]，所以事实上大多数读取都需要在读取数据之前从磁盘检索元数据。关键问题是如何在为KV项的读取请求提供服务时最小化元数据读取的数量。这些元数据可能存储在多个SSTABLE中，每个SSTABLE处于不同的级别。由于元数据与单个SSM表关联并分布在这些表上，因此在当前LSM树的结构中，多次读取似乎是不可避免的。SSTable  trie引入了线性增长模式，这导致了LSM  trie的设计，它删除了几乎所有的索引，并允许每个读取请求访问一个元数据磁盘。在描述设计之前，让我们先讨论一下SSTable  trie。使用线性增长模式可以显著增加级别数。由于多级KV项目组织需要从级别0开始，对请求的项目进行连续的级别搜索，直到找到该项目为止，因此它依赖于每个级别中的Bloom过滤器，在没有项的情况下跳过尽可能多的级别。然而，由于每个Bloom过滤器都有一个误报率（对于每个项目10位的设置，误报率约为0.82%），因此，随着级别计数的增加（例如，从7级结构的5.7%到56级结构的46%），搜索没有该项目的级别的概率会增加。因此，必须通过使用更多比特来增强Bloom过滤器。例如，使用每项16位的设置将确保整个120级结构的误报率低于5%。与磁盘容量相比，较大的Bloom过滤器的额外磁盘空间最小。正如我们将要展示的，LSM-trie删除索引，并且只使用一次磁盘访问来读取Bloom过滤器。</p>
<h4 id="242-使用htables删除索引">2.4.2 使用HTables删除索引</h4>
<p>LSM trie通过合并高效的元数据管理，代表了对SSTable trie的改进。一个主要更改是在SSTable trie中用Htable(基于散列的item组织)替换SSTable。在SSTable中，对item进行排序，并需要索引来定位块。在HTable中，每个块被视为一个桶，用于接收密钥散列到其中的KV项。虽然每个KV项都有一个SHA1生成的160位哈希键，其前缀已用于标识SSTable  trie中的SSTable或LSM  trie中的HTable，但我们使用其后缀来确定KV项的HTable中的bucket。具体地说，如果一个HTable中有m个桶，则应在桶（h mod m）中放置一个带有HashKey H的KV项。</p>
<p>为了消除HTable中的索引，LSM-trie必须使用固定大小的bucket。此外，由于bloomfilter应用于单个bucket，如果其过滤器指示bucket中可能存在查找项，则将读取整个bucket。因此，为了提高访问效率，存储桶的大小应与磁盘块（4KB）相同。然而，一个具有挑战性的问题是，根据散列到桶中的KV项的集合大小，桶是否可以进行负载平衡。众所周知，使用加密散列函数允许每个bucket具有统计上相等的机会来接收新项目，并且每个bucket中的项目计数遵循正态分布。除了key的分布外，item大小和item大小的变化也会增加bucket负载的变化。</p>
<p>图5显示了在我们将KV项（其key为Zipfian分布）存储到包含8192个4KB存储桶的32MB  HTTable中后，HTTable中存储桶负载在存储桶之间的分布。对于每个绘图，item大小为具有不同平均大小的均匀分布，大小在1b到a之间，大约是其各自平均值的两倍。在每一个实验中，我们都会不断地将KV项目写入存储，直到95%满为止。通过使用高度倾斜的Zipfian分布，结果代表了对bucket负载分布不均匀性的保守估计。3如图所示，随着平均item大小的增加，超载bucket和欠载bucket越来越多。</p>
<p>显然，LSM  trie必须将过多的项目移出过载的存储桶，以确保每个存储桶的数据小于等于4KB。与SSTable一样，HTable也是不可变的。在构建HTable的过程中，我们使用贪婪算法将最初散列到重载bucket中的一些项迁移到负载不足的bucket中进行存储。如图6所示，铲斗首先根据其初始负载排序到一个列表中。然后，我们在列表中执行成对迁移操作，在该操作中，将最少数量的KV项从负载最重的存储桶（源）移动到负载最轻的存储桶（目标），直到源中的剩余项可以装入存储桶。源bucket将从列表中删除，我们将保持列表的排序。然后，我们在较短的列表上重复迁移操作。操作将继续，直到列表的源存储桶未过载或列表的目标存储桶也已过载。为了最大限度地减少出现第二种情况的可能性，我们对可存储在HTable中的KV项的总大小设置了一个限制，即固定HTable容量的95%（默认情况下为32MB）。这种方法是有效的。例如，在可用容量略有减少的情况下，我们没有观察到一个项目从过载桶中移出，但无法容纳在平均项目尺寸为400B的HTables的欠载桶中，并且在1B和800B之间重新分配。图7显示了负载平衡后的bucket负载分布。</p>
<p>在创建新的HTable期间，为了处理无法接收到任何常规存储桶中的溢出项目（主要是由于KV项目过大），LSM  trie设置了一个特殊存储桶来接收这些项目。特殊包装中的项目已重新编制索引。索引保存在HTable文件中，也缓存在内存中，以便有效地定位item。由于bucket仅设计用于少数大型KV项目，其索引应为最小尺寸。通常，访问一致的大型项目（几个KBs或更大）的工作负载应该使用SSTable  trie。事实上，在大多数KV存储中，此类工作负载不会对其元数据管理造成挑战。</p>
<p>关于负载平衡策略，有几个问题需要解决。一个是如何有效地识别从桶中溢出的item。为了将簿记成本降到最低，我们在键上使用哈希函数对桶中的KV项进行排序，并根据它们的排序逻辑地将它们放入桶中。Wet然后使用bucket容量（4KB）作为水印。跨越或高于水印的任何item都被视为迁移的溢出item。我们只需要在水印namedHashMark处记录该项的哈希值，以便将来查找以了解该项是否已迁移。对于hash函数，我们只需在160位hashkey中选择一个32位中缀（例如，从64位到95位），如图8所示。</p>
<p>我们还记录项目迁移的位置（目标存储桶ID）。迁移的项可以进一步迁移，搜索该项需要遍历多个bucket。为了最大限度地减少重复迁移项的机会，我们通过将32位中缀旋转特定位数来调整哈希函数，其中位数是bucket  ID的函数。这样，不同的函数可以应用于不同的bucket，而Anitem不太可能在重复迁移时保持在水桶水位线以上。</p>
<p>每个bucket关于其溢出项的元数据包括源bucketID（2B）、迁移目标ID（2B）和HashMark（4B）。它们存储在磁盘上的存储桶中。设计问题是是否在内存中缓存元数据。如果我们缓存每个bucket的元数据，成本将与SSTable中的索引相当，SSTable为每个块（bucket）记录一个键。实际上，如果我们不需要在一个HTable查找中读取一个bucket，那么就没有必要记录所有bucket的元数据。如图5所示，溢出项在桶上的分布是高度倾斜的。因此，我们只需要缓存最重载的存储桶的元数据（默认情况下为20%），并使这些项的查找重新定向到各自的目标存储桶，而无需磁盘读取。这样，通过略微增加磁盘读取，LSM  trie可以显著减少其缓存的元数据。例如，当KV项目的平均值为100B，且其尺寸均匀分布在1B和200B之间时，只有1个。每次查找只需读取1个bucket，缓存的元数据只有14KB（1792×8B），约为SSTable索引大小的1/10。</p>
<p>与LevelDB类似，LSM  trie为每个桶维护一个Bloom过滤器，以快速确定是否存在KV项目。从桶中移出KV项目不需要更新桶的Bloom过滤器，因为这些KV项目在逻辑上仍保留在桶中，并且仅在物理上存储在其他桶中。它们的物理位置稍后会通过bucket的迁移相关元数据显示出来。</p>
<h4 id="243-集群bloom筛选器以实现高效访问">2.4.3 集群Bloom筛选器以实现高效访问</h4>
<p>LSM trie并不认为所有Bloom筛选器都可以缓存在内存中。需要检查每个（子）级的Bloom过滤器，直到找到所需的项目。LSM  trie确保在一个级别中为读取请求提供服务所需但未缓存的所有Bloom筛选器都可以通过一次磁盘读取检索到内存中。为此，LSM  trie将与一列Buckets相关联的所有Bloom过滤器收集到一个名为BloomCluster的简单磁盘块,如图9所示。由于在子级别上应用了相同的哈希函数，因此如果KV项在容器中，它只能出现在桶的一个特定列中。这样，一个级别只需读取一次Bloom过滤器磁盘。</p>
<p>虽然LSM  trie设计用于支持高达10TB的存储，但其数据的组织方式是，访问存储中的任何项目最多需要读取一次元数据（Bloom筛选器）。原型LSM  trie系统使用32MB的HTables和8的放大因子（AF）。这家商店有五层。在前四个级别中，LSM  trie使用线性和指数增长模式。也就是说，每个级别由八个子级别组成。5前32个子级别的所有Bloom过滤器均为4。5GB，假设平均项目大小为64B，每个密钥使用16位Bloom筛选器。在单个HTables中添加关于项迁移的元数据（最多0.5GB），LSM  trie只需要5GB内存来保存所有必要的元数据。在第五级，也就是最后一级，LSM  trie只使用线性增长模式。由于该级别的一个子级别的容量为128G，因此需要8个这样的子级别才能使存储达到1TB，80个这样的子级别才能达到10TB。所有子级别的BloomFilter都被很好地聚集到一个BloomCluster中，因此一个读取请求只需要对BloomFilter进行一次磁盘读取。尽管误报率随着电平计数的增加而增加，但可以通过使用kv项目的额外比特来很好地限制误报率，如表1所示。当LSM  trie使用每项16位Bloom过滤器时，即使对于112个子级别的10TB  KV存储，误报率也仅为5%左右。在更糟糕的情况下，只有2.05次磁盘读取，一次用于群集，一次用于群集。数据平均为1.05。</p>
<p>在LSM  trie结构中，同一密钥的多个KV项（包括用于删除操作的特殊项）可以同时停留在最后一级的不同子级中，而不会被合并，因为该级没有合并排序操作。在同一密钥的项中，只有最高子级别的项处于活动状态，其他项被视为垃圾。这可能会导致磁盘空间未充分利用，尤其是当该级别包含大量垃圾时。为了改善这种影响，我们定期随机抽取几个可回收容器，并评估它们的平均垃圾率。当比率大于阈值时，我们会定期或在系统未加载时，逐个容器地在容器中安排垃圾收集操作。</p>

    
	</div>
  <footer class="article-footer clearfix">
  

<div class="article-tags">
  <span></span>
  
  <a href="https://qkgoalkeeper.github.io/tags/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">论文解读</a>
  
</div>





<div class="article-categories">
  <span></span>
  
  <a class="article-category-link" href="https://qkgoalkeeper.github.io/categories/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB">论文解读</a>
  
</div>



  <div class="article-share" id="share">
    <div data-url="https://qkgoalkeeper.github.io/post/atc15-paper-wu%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/" data-title="atc15-paper-wu论文解读" data-tsina="5852167252" class="share clearfix">
    </div>
  </div>
</footer>

	</article>
  



</div>

    <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>
<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
  

<div class="categorieslist">
  <p class="asidetitle">分类</p>
  <ul>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/golang" title="golang">golang<sup>6</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e5%91%a8%e8%b5%9b" title="leetcode周赛">leetcode周赛<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98" title="leetcode每日一题">leetcode每日一题<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%981-100" title="leetcode简单题1-100">leetcode简单题1-100<sup>21</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98101-200" title="leetcode简单题101-200">leetcode简单题101-200<sup>25</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/leetcode%e7%ae%80%e5%8d%95%e9%a2%98201-300" title="leetcode简单题201-300">leetcode简单题201-300<sup>24</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e4%bb%a5%e5%a4%aa%e5%9d%8a" title="以太坊">以太坊<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%85%b6%e4%bb%96" title="其他">其他<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%8c%ba%e5%9d%97%e9%93%be%e7%9b%b8%e5%85%b3" title="区块链相关">区块链相关<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8a%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%be%e7%a8%8b" title="大三上数据库课程">大三上数据库课程<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e4%b8%89%e4%b8%8bweb%e7%bc%96%e7%a8%8b%e8%af%be%e7%a8%8b" title="大三下web编程课程">大三下web编程课程<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e5%a4%a7%e5%9b%9bleetcode%e7%ae%97%e6%b3%95%e5%88%b7%e9%a2%98" title="大四leetcode算法刷题">大四leetcode算法刷题<sup>300</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
    
    <li><a href="https://qkgoalkeeper.github.io/categories/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
    
  </ul>
</div>



  

<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
      
			<li><a href="https://qkgoalkeeper.github.io/tags/bfs" title="bfs">bfs<sup>13</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" title="c&#43;&#43;">c&#43;&#43;<sup>289</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/dfs" title="dfs">dfs<sup>27</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang" title="golang">golang<sup>39</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" title="golang语法">golang语法<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/javascript" title="javascript">javascript<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/leetcode" title="leetcode">leetcode<sup>395</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/solidity" title="solidity">solidity<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" title="二分法">二分法<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" title="代码">代码<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" title="优先队列">优先队列<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" title="位运算">位运算<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" title="分治法">分治法<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" title="前缀和">前缀和<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" title="动态规划">动态规划<sup>32</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" title="区块链">区块链<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" title="单调队列">单调队列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" title="双指针">双指针<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" title="哈希表">哈希表<sup>7</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" title="堆">堆<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" title="字典树">字典树<sup>6</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" title="字符串">字符串<sup>4</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" title="并查集">并查集<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" title="序列化">序列化<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" title="拓扑排序">拓扑排序<sup>3</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" title="排列">排列<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" title="排序">排序<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" title="数学">数学<sup>5</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" title="数据库">数据库<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" title="数组">数组<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" title="栈">栈<sup>8</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" title="树">树<sup>25</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" title="源码编译">源码编译<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" title="滑动窗口">滑动窗口<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" title="王道机试指南">王道机试指南<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" title="线段树">线段树<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" title="缓存">缓存<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" title="论文解读">论文解读<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" title="贪心">贪心<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" title="贪心法">贪心法<sup>1</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" title="链表">链表<sup>10</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" title="队列">队列<sup>2</sup></a></li>
      
			<li><a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" title="随机数">随机数<sup>3</sup></a></li>
      
		</ul>
</div>



  
  <div class="archiveslist">
    <p class="asidetitle">归档</p>
    <ul class="archive-list">
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-07">2022年07月</a><span class="archive-list-count">6</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-06">2022年06月</a><span class="archive-list-count">26</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-05">2022年05月</a><span class="archive-list-count">14</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-04">2022年04月</a><span class="archive-list-count">24</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-03">2022年03月</a><span class="archive-list-count">32</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-02">2022年02月</a><span class="archive-list-count">61</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2022-01">2022年01月</a><span class="archive-list-count">77</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-12">2021年12月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-11">2021年11月</a><span class="archive-list-count">30</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-10">2021年10月</a><span class="archive-list-count">31</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-09">2021年09月</a><span class="archive-list-count">5</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-06">2021年06月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2021-04">2021年04月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-11">2020年11月</a><span class="archive-list-count">1</span>
      </li>
      
      
      <li class="archive-list-item">
        <a class="archive-list-link" href="https://qkgoalkeeper.github.io/post/#2020-08">2020年08月</a><span class="archive-list-count">70</span>
      </li>
      
    </ul>

  </div>


  

<div class="tagcloudlist">
  <p class="asidetitle">标签云</p>
  <div class="tagcloudlist clearfix">
    
    <a href="https://qkgoalkeeper.github.io/tags/bfs" style="font-size: 12px;">bfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/c&#43;&#43;" style="font-size: 12px;">c&#43;&#43;</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/dfs" style="font-size: 12px;">dfs</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang" style="font-size: 12px;">golang</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/golang%e8%af%ad%e6%b3%95" style="font-size: 12px;">golang语法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/javascript" style="font-size: 12px;">javascript</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/leetcode" style="font-size: 12px;">leetcode</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/solidity" style="font-size: 12px;">solidity</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%ba%8c%e5%88%86%e6%b3%95" style="font-size: 12px;">二分法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bb%a3%e7%a0%81" style="font-size: 12px;">代码</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97" style="font-size: 12px;">优先队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e4%bd%8d%e8%bf%90%e7%ae%97" style="font-size: 12px;">位运算</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%88%86%e6%b2%bb%e6%b3%95" style="font-size: 12px;">分治法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%89%8d%e7%bc%80%e5%92%8c" style="font-size: 12px;">前缀和</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92" style="font-size: 12px;">动态规划</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be" style="font-size: 12px;">区块链</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97" style="font-size: 12px;">单调队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%8f%8c%e6%8c%87%e9%92%88" style="font-size: 12px;">双指针</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%93%88%e5%b8%8c%e8%a1%a8" style="font-size: 12px;">哈希表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%a0%86" style="font-size: 12px;">堆</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e5%85%b8%e6%a0%91" style="font-size: 12px;">字典树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ad%97%e7%ac%a6%e4%b8%b2" style="font-size: 12px;">字符串</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%b9%b6%e6%9f%a5%e9%9b%86" style="font-size: 12px;">并查集</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e5%ba%8f%e5%88%97%e5%8c%96" style="font-size: 12px;">序列化</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f" style="font-size: 12px;">拓扑排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%88%97" style="font-size: 12px;">排列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%8e%92%e5%ba%8f" style="font-size: 12px;">排序</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e5%ad%a6" style="font-size: 12px;">数学</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e6%8d%ae%e5%ba%93" style="font-size: 12px;">数据库</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%95%b0%e7%bb%84" style="font-size: 12px;">数组</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%88" style="font-size: 12px;">栈</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%a0%91" style="font-size: 12px;">树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%ba%90%e7%a0%81%e7%bc%96%e8%af%91" style="font-size: 12px;">源码编译</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3" style="font-size: 12px;">滑动窗口</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%8e%8b%e9%81%93%e6%9c%ba%e8%af%95%e6%8c%87%e5%8d%97" style="font-size: 12px;">王道机试指南</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%ba%bf%e6%ae%b5%e6%a0%91" style="font-size: 12px;">线段树</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e7%bc%93%e5%ad%98" style="font-size: 12px;">缓存</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%ae%ba%e6%96%87%e8%a7%a3%e8%af%bb" style="font-size: 12px;">论文解读</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83" style="font-size: 12px;">贪心</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e8%b4%aa%e5%bf%83%e6%b3%95" style="font-size: 12px;">贪心法</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%93%be%e8%a1%a8" style="font-size: 12px;">链表</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%98%9f%e5%88%97" style="font-size: 12px;">队列</a>
    
    <a href="https://qkgoalkeeper.github.io/tags/%e9%9a%8f%e6%9c%ba%e6%95%b0" style="font-size: 12px;">随机数</a>
    
  </div>
</div>



  

</aside>
</div>

  </div>
  <footer><div id="footer" >
  <div class="line">
    <span></span>
    
    <div style='background:no-repeat url("https://qkgoalkeeper.github.io/img/author.jpg") left top;-webkit-background-size:6.875em 6.875em;-moz-background-size:6.875em 6.875em;background-size:6.875em 6.875em;' class="author" ></div>
  </div>
  <section class="info">
    <p>ECNU数据学院在读 <br/> 知乎主页 :https://www.zhihu.com/people/hao-lai-wu-shou-men-yuan <br/>QQ :1421812601</p>
  </section>
  <div class="social-font clearfix">
    <a href='http://weibo.com/qkgoalkeeper' target="_blank" title="weibo"></a>
    <a href='https://twitter.com/coderzh' target="_blank" title="twitter"></a>
    <a href='https://github.com/qkgoalkeeper' target="_blank" title="github"></a>
    <a href='https://www.facebook.com/coderzh' target="_blank" title="facebook"></a>
    <a href='https://www.linkedin.com/coderzh' target="_blank" title="linkedin"></a>
  </div>
  <p class="copyright">Powered by <a href="http://gohugo.io" target="_blank" title="hugo">hugo</a> and Theme by <a href="https://github.com/coderzh/hugo-pacman-theme" target="_blank" title="hugo-pacman-theme">hugo-pacman-theme</a> © 2022
    
    <a href="https://qkgoalkeeper.github.io/" title="qkgoalkeeper&#39;s blog">qkgoalkeeper&#39;s blog</a>
    
  </p>
</div>
</footer>
  <script src="https://qkgoalkeeper.github.io/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
done = false;
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  $('form.search').on('submit', function (event) {
    if (false === done) {
      event.preventDefault();
      var orgVal = $(this).find('#search').val();
      $(this).find('#search').val('site:https:\/\/qkgoalkeeper.github.io\/ ' + orgVal);
      done = true;
      $(this).submit();
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://b.bshare.cn/barCode?site=weixin&url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});
</script>


<link rel="stylesheet" href="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://qkgoalkeeper.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
});
</script>




</body>
</html>
